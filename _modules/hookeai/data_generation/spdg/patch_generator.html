<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>hookeai.data_generation.spdg.patch_generator &mdash; hookeai 1.0.0 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/readthedocs-custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            hookeai
          </a>
              <div class="version">
                1.0.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/getting_started/overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/getting_started/installation.html">Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Features</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/features/overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/features/data_generation.html">Data generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/features/material_models.html">Material model architectures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/features/local_model_updating.html">Local material model updating</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/features/global_model_updating.html">Global material model updating</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/features/data_analysis.html">Data analysis and visualization tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/features/tensor_matrix.html">Tensorial algebra and matrix operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/features/other.html">Other utilities</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../_autosummary/hookeai.html">Code</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">License</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../license.html">MIT License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">hookeai</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">hookeai.data_generation.spdg.patch_generator</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for hookeai.data_generation.spdg.patch_generator</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Finite element material patch generator.</span>

<span class="sd">Classes</span>
<span class="sd">-------</span>
<span class="sd">class FiniteElementPatchGenerator</span>
<span class="sd">    Finite element material patch generator.</span>
<span class="sd">    </span>
<span class="sd">Functions</span>
<span class="sd">---------</span>
<span class="sd">rotation_tensor_from_euler_angles</span>
<span class="sd">    Set rotation tensor from Euler angles (Bunge convention).</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#                                                                       Modules</span>
<span class="c1"># =============================================================================</span>
<span class="c1"># Standard</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="c1"># Third-party</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">shapely.geometry</span>
<span class="c1"># Local</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">data_generation.spdg.patch</span><span class="w"> </span><span class="kn">import</span> <span class="n">FiniteElementPatch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">simulators.links.discretization.finite_element</span><span class="w"> </span><span class="kn">import</span> <span class="n">FiniteElement</span>
<span class="c1">#</span>
<span class="c1">#                                                          Authorship &amp; Credits</span>
<span class="c1"># =============================================================================</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Bernardo Ferreira (bernardo_ferreira@brown.edu)&#39;</span>
<span class="n">__credits__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Bernardo Ferreira&#39;</span><span class="p">,</span> <span class="p">]</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s1">&#39;Stable&#39;</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">FiniteElementPatchGenerator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Finite element material patch generator.</span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    _n_dim : int</span>
<span class="sd">        Number of spatial dimensions.</span>
<span class="sd">    _patch_dims : tuple[float]</span>
<span class="sd">        Patch size in each dimension.</span>
<span class="sd">    _n_corners : int</span>
<span class="sd">        Number of corners of the patch.</span>
<span class="sd">    _n_edges : int</span>
<span class="sd">        Number of edges of the patch.</span>
<span class="sd">    _corners_mapping : dict</span>
<span class="sd">        For each corner label (key, str[int]), store the corner internal index.</span>
<span class="sd">        Corners are labeled from 1 to number of corners.</span>
<span class="sd">    _corners_coords_ref : numpy.ndarray(2d)</span>
<span class="sd">        Patch corners coordinates in the reference configuration</span>
<span class="sd">        (numpy.ndarray(n_corners, n_dim)).</span>
<span class="sd">    _edges_per_dim : dict</span>
<span class="sd">        For each dimension (key, str[int]), store the edges</span>
<span class="sd">        (item, tuple[tuple]) oriented along that dimension in the reference</span>
<span class="sd">        configuration. Each edge is stored as tuple[int](2) containing the</span>
<span class="sd">        indexes of the two corresponding corners. Corners are stored such that</span>
<span class="sd">        edges nodes are sorted in asceding order of coordinate.        </span>
<span class="sd">    _edges_diag_per_dim : dict</span>
<span class="sd">        For each dimension (key, str[int]), store the edges reference diagonal</span>
<span class="sd">        (item, tuple[tuple]) for edges oriented along that dimension in the</span>
<span class="sd">        reference configuration. Each reference diagonal is stored as a</span>
<span class="sd">        tuple[int](2) containing the indexes of the two corresponding corners.</span>
<span class="sd">    _edges_mapping : dict</span>
<span class="sd">        For each edge label (key, str[int]), store the edge orientation</span>
<span class="sd">        dimension and internal index consistent with `_edges_per_dim`</span>
<span class="sd">        (tuple(2)). Edges are labeled from 1 to number of edges.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    generate_deformed_patch(self, elem_type, n_elems_per_dim, \</span>
<span class="sd">                            corners_lab_bc=None, corners_lab_disp_range=None, \</span>
<span class="sd">                            edges_lab_def_order=None, \</span>
<span class="sd">                            edges_lab_disp_range=None, \</span>
<span class="sd">                            translation_range=None, \</span>
<span class="sd">                            rotation_angles_range=None, \</span>
<span class="sd">                            deformation_noise=0.0, \</span>
<span class="sd">                            max_iter=10, is_verbose=False)</span>
<span class="sd">        Generate finite element deformed patch.</span>
<span class="sd">    _build_corners_bc(self, corners_lab_bc=None)</span>
<span class="sd">        Build boundary conditions on patch corners.</span>
<span class="sd">    _build_corners_disp_range(self, corners_lab_disp_range=None, \</span>
<span class="sd">                              corners_bc=None)</span>
<span class="sd">        Build patch corners displacement range.</span>
<span class="sd">    _build_edges_poly_orders(self, edges_lab_def_order=None)</span>
<span class="sd">        Build patch edges deformation polynomials orders.</span>
<span class="sd">    _build_edges_disp_range(self, edges_lab_disp_range=None)</span>
<span class="sd">        Build patch edges displacements range.</span>
<span class="sd">    _set_corners_attributes(self)</span>
<span class="sd">        Set patch corners attributes.</span>
<span class="sd">    _set_corners_coords_ref(self)</span>
<span class="sd">        Set patch corners coordinates (reference configuration).</span>
<span class="sd">    _set_edges_attributes(self)</span>
<span class="sd">        Set patch edges attributes.</span>
<span class="sd">    _get_matching_edges_idxs(self)</span>
<span class="sd">        Get matching edges indexes along each dimension.</span>
<span class="sd">    _get_n_edge_nodes_per_dim(self, elem_type, n_elems_per_dim)</span>
<span class="sd">        Get number of patch edge nodes along each dimension.</span>
<span class="sd">    _get_elem_type_attributes(self, elem_type)</span>
<span class="sd">        Get finite element type attributes.</span>
<span class="sd">    _get_corners_random_displacements(self, corners_disp_range, \</span>
<span class="sd">                                      edges_poly_orders=None)</span>
<span class="sd">        Compute patch corners random displacements.</span>
<span class="sd">    _get_deformed_boundary_edge(self, nodes_coords_ref, left_node_def, \</span>
<span class="sd">                                right_node_def, poly_order,</span>
<span class="sd">                                poly_bounds_range=None, is_plot=False)</span>
<span class="sd">    _polynomial_sampler(order, left_point, right_point, lower_bound=None, \</span>
<span class="sd">                        upper_bound=None, is_plot=False)</span>
<span class="sd">        Generate random polynomial by sampling points within given bounds.</span>
<span class="sd">    _get_patch_centroid(self, corners_coords, edges_coords)</span>
<span class="sd">        Compute patch centroid.</span>
<span class="sd">    _build_boundary_coords_array(self, edges_coords, is_close_polygon)</span>
<span class="sd">        Build patch boundary nodes coordinates array.</span>
<span class="sd">    _is_admissible_simulation(self, edges_coords)</span>
<span class="sd">        Check whether simulation of patch is physically admissible.</span>
<span class="sd">    _get_orthogonal_dims(self, dim)</span>
<span class="sd">        Get orthogonal dimensions to given dimension.</span>
<span class="sd">    _rotation_tensor_deformed_edge(self, edge_dim, edge_index, \</span>
<span class="sd">                                   corners_coords_def)</span>
<span class="sd">        Set rotation tensor to deformed boundary edge local coordinates.</span>
<span class="sd">    _transform_to_edge_local_coordinates(self, init_node_def, end_node_def, \</span>
<span class="sd">                                         nodes_coords_ref, \</span>
<span class="sd">                                         translation = None, rotation = None)</span>
<span class="sd">        Transform from patch coordinates to deformed edge local coordinates.</span>
<span class="sd">    _transform_from_edge_local_coordinates(self, local_nodes_coords_def, \</span>
<span class="sd">                                           translation=None, rotation=None)</span>
<span class="sd">        Transform from deformed edge local coordinates to patch coordinates.</span>
<span class="sd">    _rotate_coords_array(coords_array, r)</span>
<span class="sd">        Rotate coordinates array.</span>
<span class="sd">    _generate_finite_element_mesh(self, elem_type, n_elems_per_dim)</span>
<span class="sd">        Generate patch finite element mesh (reference configuration).</span>
<span class="sd">    _get_elem_node_index(self, elem_type, n_elems_per_dim, global_index)</span>
<span class="sd">        Get element node local index from global mesh index.</span>
<span class="sd">    _get_mesh_boundary_nodes_disps(self, edges_coords_ref, edges_coords_def,</span>
<span class="sd">                                   mesh_nodes_matrix, mesh_nodes_coords_ref,</span>
<span class="sd">                                   is_interp_face_disps=False)</span>
<span class="sd">    _get_node_label_from_coords(mesh_nodes_coords_ref, node_coords)</span>
<span class="sd">        Get finite element mesh node label from coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator.__init__"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.__init__">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">,</span> <span class="n">patch_dims</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructor.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_dim : int</span>
<span class="sd">            Number of spatial dimensions.</span>
<span class="sd">        patch_dims : tuple[float]</span>
<span class="sd">            Patch size in each dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">=</span> <span class="n">n_dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_patch_dims</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">patch_dims</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set patch number of corners and edges</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_corners</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_edges</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_corners</span> <span class="o">=</span> <span class="mi">8</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_edges</span> <span class="o">=</span> <span class="mi">24</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Invalid number of spatial dimensions.&#39;</span><span class="p">)</span>
        <span class="c1"># Set corners attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_corners_attributes</span><span class="p">()</span>
        <span class="c1"># Set patch corners coordinates (reference configuration)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_corners_coords_ref</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set edges attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_edges_attributes</span><span class="p">()</span></div>
    <span class="c1"># -------------------------------------------------------------------------  </span>
<div class="viewcode-block" id="FiniteElementPatchGenerator.generate_deformed_patch"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.generate_deformed_patch">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">generate_deformed_patch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem_type</span><span class="p">,</span> <span class="n">n_elems_per_dim</span><span class="p">,</span>
                                <span class="n">corners_lab_bc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">corners_lab_disp_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">edges_lab_def_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">edges_lab_disp_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">translation_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">rotation_angles_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">deformation_noise</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                                <span class="n">max_iter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">is_verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate finite element deformed patch.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elem_type : str</span>
<span class="sd">            Finite element type.</span>
<span class="sd">        n_elems_per_dim : tuple[int]</span>
<span class="sd">            Number of finite elements per dimension.</span>
<span class="sd">        corners_lab_bc : dict, default=None</span>
<span class="sd">            Boundary conditions (item, tuple[int](n_dim)) for each patch</span>
<span class="sd">            corner label (key, str[int]). Corners are labeled from 1 to number</span>
<span class="sd">            of corners. The tuple[int](n_dim) prescribes 0 (free) or 1 (fixed)</span>
<span class="sd">            for each degree of freedom. Corners are labeled from 1 to number of</span>
<span class="sd">            corners. Unspecified corners are assumed free by default.</span>
<span class="sd">        corners_lab_disp_range : dict, default=None</span>
<span class="sd">            Displacement range along each dimension (item, tuple[tuple(2)]) for</span>
<span class="sd">            each corner label (key, str[int]). Corners are labeled from 1 to</span>
<span class="sd">            number of corners. Range is specified as tuple(min, max) for each</span>
<span class="sd">            dimension. If None, a null displacement range is set by default.</span>
<span class="sd">        edges_lab_def_order : {int, dict}, default=None</span>
<span class="sd">            Deformation polynomial order (item, int) for each edge label</span>
<span class="sd">            (key, str[int]). Edges are labeled from 1 to number of edges.</span>
<span class="sd">            If a single order is provided, then it is assumed for all the</span>
<span class="sd">            edges. Zero order is assumed for unspecified edges. If None, zero</span>
<span class="sd">            order is assumed for all the edges.</span>
<span class="sd">        edges_lab_disp_range : dict, default=None</span>
<span class="sd">            Displacement range (item, tuple[float](2)) for each edge</span>
<span class="sd">            label (key, str[int]). Edges are labeled from 1 to number of edges.</span>
<span class="sd">            Range is specified as a tuple(min, max) where: (1) displacement</span>
<span class="sd">            range is orthogonal and relative to the edge (defined by limiting</span>
<span class="sd">            corner nodes in the deformed configuration), (2) positive/negative</span>
<span class="sd">            displacement corresponds to outward/inward direction with respect</span>
<span class="sd">            to the patch. Null displacement range is assumed for unspecified</span>
<span class="sd">            edges. If None, null displacement range is set by default.</span>
<span class="sd">        translation_range : dict, default=None</span>
<span class="sd">            Translational displacement range (item, tuple[float](2)) along each</span>
<span class="sd">            dimension (key, str[int]). Range is specified as tuple(min, max)</span>
<span class="sd">            for each dimension. Null range is assumed for unspecified</span>
<span class="sd">            dimensions. If None, then there is no translational motion.</span>
<span class="sd">        rotation_angles_range : dict, default=None</span>
<span class="sd">            Rotational angle (degrees) range (item, tuple[float](2)) for each</span>
<span class="sd">            Euler angle (key, str). Euler angles follow Bunge convention</span>
<span class="sd">            (Z1-X2-Z3) and are labeled (&#39;alpha&#39;, &#39;beta&#39;, &#39;gamma&#39;),</span>
<span class="sd">            respectively. Null range is assumed for unspecified angles. If</span>
<span class="sd">            None, then there is no rotational motion.</span>
<span class="sd">        deformation_noise : float, default=0.0</span>
<span class="sd">            Parameter that controls the normally distributed noise superimposed</span>
<span class="sd">            to the boundary edges interior nodes coordinates in the deformed</span>
<span class="sd">            configuration. Defines the noise standard deviation along given</span>
<span class="sd">            dimension after being multiplied by the corresponding patch size.</span>
<span class="sd">        max_iter : int, default=10</span>
<span class="sd">            Maximum number of iterations to get a geometrically admissible</span>
<span class="sd">            deformed patch configuration.</span>
<span class="sd">        is_verbose : bool, default=False</span>
<span class="sd">            If True, enable verbose output.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_admissible : bool</span>
<span class="sd">            If True, the patch is geometrically admissible.</span>
<span class="sd">        patch : FiniteElementPatch</span>
<span class="sd">            Finite element patch. If `is_admissible` is False, then returns</span>
<span class="sd">            None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Generating finite element deformed material patch&#39;</span>
                  <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">-------------------------------------------------&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&gt; Setting patch reference configuration...&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set corners boundary conditions</span>
        <span class="n">corners_bc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_corners_bc</span><span class="p">(</span><span class="n">corners_lab_bc</span><span class="o">=</span><span class="n">corners_lab_bc</span><span class="p">)</span>
        <span class="c1"># Build corners displacement range</span>
        <span class="n">corners_disp_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_corners_disp_range</span><span class="p">(</span>
            <span class="n">corners_lab_disp_range</span><span class="o">=</span><span class="n">corners_lab_disp_range</span><span class="p">,</span>
            <span class="n">corners_bc</span><span class="o">=</span><span class="n">corners_bc</span><span class="p">)</span>
        <span class="c1"># Build edges deformation polynomials orders and displacement range</span>
        <span class="n">edges_poly_orders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_edges_poly_orders</span><span class="p">(</span>
            <span class="n">edges_lab_def_order</span><span class="o">=</span><span class="n">edges_lab_def_order</span><span class="p">)</span>
        <span class="n">edges_disp_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_edges_disp_range</span><span class="p">(</span>
            <span class="n">edges_lab_disp_range</span><span class="o">=</span><span class="n">edges_lab_disp_range</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get corners coordinates (reference configuration)</span>
        <span class="n">corners_coords_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corners_coords_ref</span>
        <span class="c1"># Get edges attributes</span>
        <span class="n">edges_per_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_per_dim</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get number of patch edge nodes along each dimension</span>
        <span class="n">n_edge_nodes_per_dim</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_n_edge_nodes_per_dim</span><span class="p">(</span><span class="n">elem_type</span><span class="p">,</span> <span class="n">n_elems_per_dim</span><span class="p">)</span>
        <span class="c1"># Set edges nodes coordinates (reference configuration)</span>
        <span class="n">edges_coords_ref</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">):</span>
            <span class="c1"># Get number of patch edge nodes</span>
            <span class="n">n_edge_nodes</span> <span class="o">=</span> <span class="n">n_edge_nodes_per_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># Initialize edges nodes coordinates along dimension</span>
            <span class="n">edges_coords_ref</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Loop over edges</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">cid_init</span><span class="p">,</span> <span class="n">cid_end</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edges_per_dim</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]:</span>
                <span class="c1"># Build edge nodes coordinates assuming a regular</span>
                <span class="c1"># discretization (evenly spaced nodes)</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_edge_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">))</span>
                <span class="c1"># Loop over dimensions</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">):</span>
                    <span class="n">coords</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">corners_coords_ref</span><span class="p">[</span><span class="n">cid_init</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span>
                                               <span class="n">corners_coords_ref</span><span class="p">[</span><span class="n">cid_end</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span>
                                               <span class="n">num</span><span class="o">=</span><span class="n">n_edge_nodes</span><span class="p">)</span>
                <span class="c1"># Store edge nodes coordinates</span>
                <span class="n">edges_coords_ref</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">if</span> <span class="n">is_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&gt; Random generation iterative loop:&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize outputs</span>
        <span class="n">is_admissible</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">patch</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Loop over randomly generated deformed configurations</span>
        <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="k">if</span> <span class="n">is_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">  &gt; Iteration &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">iter</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    &gt; Generating corners displacements...&#39;</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Compute corners random displacements</span>
            <span class="n">corners_disp</span><span class="p">,</span> <span class="n">corners_disp_range</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_corners_random_displacements</span><span class="p">(</span>
                    <span class="n">corners_disp_range</span><span class="p">,</span> <span class="n">edges_poly_orders</span><span class="o">=</span><span class="n">edges_poly_orders</span><span class="p">)</span>
            <span class="c1"># Compute corners deformed coordinates</span>
            <span class="n">corners_coords_def</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corners_coords_ref</span> <span class="o">+</span> <span class="n">corners_disp</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="k">if</span> <span class="n">is_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    &gt; Generating edges random displacements...&#39;</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Compute edges nodes coordinates (deformed configuration)   </span>
            <span class="n">edges_coords_def</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">):</span>
                <span class="c1"># Initialize edges nodes coordinates along dimension</span>
                <span class="n">edges_coords_def</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Loop over edges</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">cid_init</span><span class="p">,</span> <span class="n">cid_end</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges_per_dim</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]):</span>
                    <span class="c1"># Get edge nodes coordinates (reference configuration)</span>
                    <span class="n">nodes_coords_ref</span> <span class="o">=</span> <span class="n">edges_coords_ref</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)][</span><span class="n">j</span><span class="p">]</span>
                    <span class="c1"># Get edge corners coordinates (deformed configuration)</span>
                    <span class="n">init_node_def</span> <span class="o">=</span> <span class="n">corners_coords_def</span><span class="p">[</span><span class="n">cid_init</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="n">end_node_def</span> <span class="o">=</span> <span class="n">corners_coords_def</span><span class="p">[</span><span class="n">cid_end</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Get rotation tensor from patch coordinates to deformed</span>
                    <span class="c1"># boundary edge local coordinates</span>
                    <span class="n">rotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotation_tensor_deformed_edge</span><span class="p">(</span>
                        <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">corners_coords_def</span><span class="p">)[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">]</span>
                    <span class="c1"># Get translation from patch coordinates to deformed</span>
                    <span class="c1"># boundary edge local coordinates</span>
                    <span class="n">translation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">init_node_def</span><span class="p">)</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Transform from patch coordinates to deformed edge local</span>
                    <span class="c1"># coordinates</span>
                    <span class="n">local_init_node_def</span><span class="p">,</span> <span class="n">local_end_node_def</span><span class="p">,</span> \
                        <span class="n">local_nodes_coords_ref</span> <span class="o">=</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">_transform_to_edge_local_coordinates</span><span class="p">(</span>
                            <span class="n">init_node_def</span><span class="p">,</span> <span class="n">end_node_def</span><span class="p">,</span> <span class="n">nodes_coords_ref</span><span class="p">,</span>
                            <span class="n">translation</span><span class="p">,</span> <span class="n">rotation</span><span class="p">)</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Get edge deformation polynomial order</span>
                    <span class="n">poly_order</span> <span class="o">=</span> <span class="n">edges_poly_orders</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)][</span><span class="n">j</span><span class="p">]</span>
                    <span class="c1"># Get edge displacement range</span>
                    <span class="n">disp_amp</span> <span class="o">=</span> <span class="n">edges_disp_range</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)][</span><span class="n">j</span><span class="p">]</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Discard out-of-deformation-plane spatial dimension</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="c1"># Store three-dimensional edge nodes deformed</span>
                        <span class="c1"># boundary edge local coordinates (reference</span>
                        <span class="c1"># configuration)</span>
                        <span class="n">local_nodes_coords_ref_3d</span> <span class="o">=</span> <span class="n">local_nodes_coords_ref</span>
                        <span class="c1"># Discard out-of-deformation-plane spatial dimension</span>
                        <span class="n">local_init_node_def</span> <span class="o">=</span> <span class="n">local_init_node_def</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
                        <span class="n">local_end_node_def</span> <span class="o">=</span> <span class="n">local_end_node_def</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
                        <span class="n">local_nodes_coords_ref</span> <span class="o">=</span> <span class="n">local_nodes_coords_ref</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Generate randomly deformed boundary edge node coordinates</span>
                    <span class="c1"># in the edge local coordinates (deformation plane)</span>
                    <span class="n">local_nodes_coords_def</span><span class="p">,</span> <span class="n">local_nodes_disp</span> <span class="o">=</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">_get_deformed_boundary_edge</span><span class="p">(</span>
                            <span class="n">local_nodes_coords_ref</span><span class="p">,</span> <span class="n">local_init_node_def</span><span class="p">,</span>
                            <span class="n">local_end_node_def</span><span class="p">,</span> <span class="n">poly_order</span><span class="p">,</span>
                            <span class="n">poly_bounds_range</span><span class="o">=</span><span class="n">disp_amp</span><span class="p">,</span>
                            <span class="n">noise</span><span class="o">=</span><span class="n">deformation_noise</span><span class="p">)</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Restore out-of-deformation-plane spatial dimension</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="c1"># Get edge number of nodes</span>
                        <span class="n">n_nodes</span> <span class="o">=</span> <span class="n">local_nodes_coords_def</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="c1"># Set out-of-deformation-plane coordinates</span>
                        <span class="n">local_nodes_coords_def</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">local_nodes_coords_def</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_nodes</span><span class="p">,</span> <span class="mi">1</span><span class="p">))))</span>
                        <span class="c1"># Compute boundary edge nodes displacements</span>
                        <span class="n">local_nodes_disp</span> <span class="o">=</span> \
                            <span class="n">local_nodes_coords_def</span> <span class="o">-</span> <span class="n">local_nodes_coords_ref_3d</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Get translation from deformed boundary edge local</span>
                    <span class="c1"># coordinates to patch coordinates</span>
                    <span class="n">translation</span> <span class="o">=</span> <span class="o">-</span><span class="n">init_node_def</span>
                    <span class="c1"># Get rotation tensor from deformed boundary edge local</span>
                    <span class="c1"># coordinates to patch coordinates</span>
                    <span class="n">rotation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Transform from deformed edge local coordinates to patch</span>
                    <span class="c1"># coordinates</span>
                    <span class="n">nodes_coords_def</span> <span class="o">=</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">_transform_from_edge_local_coordinates</span><span class="p">(</span>
                            <span class="n">local_nodes_coords_def</span><span class="p">,</span> <span class="n">translation</span><span class="p">,</span> <span class="n">rotation</span><span class="p">)</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Store edge nodes coordinates (deformed configuration)</span>
                    <span class="n">edges_coords_def</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodes_coords_def</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~            </span>
            <span class="c1"># Compute random rigid body motions</span>
            <span class="n">rbm_translation</span><span class="p">,</span> <span class="n">rbm_rotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_rigid_motions</span><span class="p">(</span>
                <span class="n">translation_range</span><span class="p">,</span> <span class="n">rotation_angles_range</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Get patch centroid (deformed configuration)</span>
            <span class="n">centroid_def</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_patch_centroid</span><span class="p">(</span><span class="n">corners_coords_def</span><span class="p">,</span>
                                                    <span class="n">edges_coords_def</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Superimpose rigid body motions (translation and rotation)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">):</span>
                <span class="c1"># Loop over edges</span>
                <span class="k">for</span> <span class="n">coords_array</span> <span class="ow">in</span> <span class="n">edges_coords_def</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]:</span>
                    <span class="c1"># Get number of boundary edge nodes</span>
                    <span class="n">n_nodes</span> <span class="o">=</span> <span class="n">coords_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Rigid body rotation (around deformed configuration</span>
                    <span class="c1"># centroid)</span>
                    <span class="k">if</span> <span class="n">centroid_def</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">rotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># Build centroid tile array (local)</span>
                        <span class="n">centroid_def_tile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">centroid_def</span><span class="p">,</span> <span class="p">(</span><span class="n">n_nodes</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                        <span class="c1"># Superimpose rigid body rotation around centroid</span>
                        <span class="c1"># (in-place update)</span>
                        <span class="n">coords_array</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> \
                            <span class="n">centroid_def_tile</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rotate_coords_array</span><span class="p">(</span>
                                <span class="n">coords_array</span> <span class="o">-</span> <span class="n">centroid_def_tile</span><span class="p">,</span> <span class="n">rbm_rotation</span><span class="p">)</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Rigid body translation</span>
                    <span class="k">if</span> <span class="n">translation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># Build translation tile array (local)</span>
                        <span class="n">translation_tile</span> <span class="o">=</span> \
                            <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">rbm_translation</span><span class="p">,</span> <span class="p">(</span><span class="n">n_nodes</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                        <span class="c1"># Superimpose rigid body translation (in-place update)</span>
                        <span class="n">coords_array</span> <span class="o">+=</span> <span class="n">translation_tile</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Check whether simulation of patch is physically admissible</span>
            <span class="n">is_admissible</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_admissible_simulation</span><span class="p">(</span><span class="n">edges_coords_def</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ </span>
            <span class="k">if</span> <span class="n">is_verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    &gt; Is admissible deformation? &#39;</span><span class="p">,</span> <span class="n">is_admissible</span><span class="p">)</span>  
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~            </span>
            <span class="c1"># If admissible deformation is achieved, then generate finite</span>
            <span class="c1"># element patch and leave iterative loop</span>
            <span class="k">if</span> <span class="n">is_admissible</span><span class="p">:</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="k">if</span> <span class="n">is_verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    &gt; Generating finite element mesh...&#39;</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Generate finite element mesh (reference configuration)</span>
                <span class="n">mesh_nodes_matrix</span><span class="p">,</span> <span class="n">mesh_nodes_coords_ref</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_generate_finite_element_mesh</span><span class="p">(</span><span class="n">elem_type</span><span class="p">,</span>
                                                       <span class="n">n_elems_per_dim</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="k">if</span> <span class="n">is_verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    &gt; Computing boundary nodes displacements...&#39;</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Compute finite element mesh boundary nodes displacements</span>
                <span class="n">mesh_boundary_nodes_disps</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_get_mesh_boundary_nodes_disps</span><span class="p">(</span>
                        <span class="n">edges_coords_ref</span><span class="p">,</span> <span class="n">edges_coords_def</span><span class="p">,</span>
                        <span class="n">mesh_nodes_matrix</span><span class="p">,</span> <span class="n">mesh_nodes_coords_ref</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="k">if</span> <span class="n">is_verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;    &gt; Generating finite element patch...&#39;</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Generate finite element patch</span>
                <span class="n">patch</span> <span class="o">=</span> <span class="n">FiniteElementPatch</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_patch_dims</span><span class="p">),</span> <span class="n">elem_type</span><span class="p">,</span>
                    <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">n_elems_per_dim</span><span class="p">),</span>
                    <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh_nodes_matrix</span><span class="p">),</span>
                    <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh_nodes_coords_ref</span><span class="p">),</span>
                    <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mesh_boundary_nodes_disps</span><span class="p">))</span>
                <span class="c1"># Leave iterative loop</span>
                <span class="k">break</span> 
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">if</span> <span class="n">is_verbose</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_admissible</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&gt; Generation status: Success</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&gt; Generation status: Failure</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">is_admissible</span><span class="p">,</span> <span class="n">patch</span></div>
    <span class="c1"># ------------------------------------------------------------------------- </span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._build_corners_bc"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._build_corners_bc">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_build_corners_bc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corners_lab_bc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_random_min</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build boundary conditions on patch corners.</span>
<span class="sd">        </span>
<span class="sd">        If boundary conditions are not provided, then a random set of minimal</span>
<span class="sd">        constraints is prescribed.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        corners_lab_bc : dict, default=None</span>
<span class="sd">            Boundary conditions (item, tuple[int](n_dim)) for each patch</span>
<span class="sd">            corner label (key, str[int]). The tuple[int](n_dim)] prescribes 0</span>
<span class="sd">            (free) or 1 (fixed) for each degree of freedom. Unspecified corners</span>
<span class="sd">            are assumed free by default.</span>
<span class="sd">        is_random_min : bool, False</span>
<span class="sd">            Prescribe a random set of minimal constraints. This option</span>
<span class="sd">            overrides any prescribed boundary conditions.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        corners_bc : tuple[tuple]</span>
<span class="sd">            Boundary conditions applied to the corners of the patch. For each</span>
<span class="sd">            node, a tuple(n_dim) prescribes 0 (free) or 1 (fixed) for each</span>
<span class="sd">            degree of freedom.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Build corners boundary conditions</span>
        <span class="k">if</span> <span class="n">is_random_min</span><span class="p">:</span>
            <span class="c1"># Set number of minimal constraints</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">n_min_bc</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_min_bc</span> <span class="o">=</span> <span class="mi">6</span>
            <span class="c1"># Generate random set of minimal constraints</span>
            <span class="n">random_bc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_corners</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">random_bc</span><span class="p">[:</span><span class="n">n_min_bc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">random_bc</span><span class="p">)</span>
            <span class="c1"># Build corners boundary conditions </span>
            <span class="n">corners_bc</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_corners</span><span class="p">):</span>
                <span class="n">corners_bc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="nb">tuple</span><span class="p">([</span><span class="n">random_bc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Initialize corners boundary conditions</span>
            <span class="n">corners_bc</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="o">*</span><span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_corners</span><span class="p">)]</span>
            <span class="c1"># Build corners boundary conditions</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">corners_lab_bc</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="c1"># Loop over prescribed corners</span>
                <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">corners_lab_bc</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="c1"># Get corner internal index</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corners_mapping</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
                    <span class="c1"># Check corner prescribed boundary condition</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">corners_lab_bc</span><span class="p">[</span><span class="n">label</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Corner boundary conditions must &#39;</span>
                                           <span class="s1">&#39;be prescribed as a &#39;</span>
                                           <span class="s1">&#39;tuple[int](n_dim).&#39;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">corners_lab_bc</span><span class="p">[</span><span class="n">label</span><span class="p">])</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Corner boundary conditions must &#39;</span>
                                           <span class="s1">&#39;be prescribed as a &#39;</span>
                                           <span class="s1">&#39;tuple[int](n_dim).&#39;</span><span class="p">)</span>                
                    <span class="c1"># Set corner boundary conditions</span>
                    <span class="n">corners_bc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">corners_lab_bc</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">corners_bc</span><span class="p">)</span> </div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._build_corners_disp_range"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._build_corners_disp_range">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_build_corners_disp_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corners_lab_disp_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                                  <span class="n">corners_bc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build patch corners displacement range.</span>
<span class="sd">         </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        corners_lab_disp_range : dict, default=None</span>
<span class="sd">            Displacement range along each dimension (item, tuple[tuple(2)]) for</span>
<span class="sd">            each corner label (key, str[int]). Corners are labeled from 1 to</span>
<span class="sd">            number of corners. Range is specified as tuple(min, max) for each</span>
<span class="sd">            dimension.  If None, a null displacement range is set by default.</span>
<span class="sd">        corners_bc : tuple[tuple], default=None</span>
<span class="sd">            Boundary conditions applied to the corners of the patch. For each</span>
<span class="sd">            node, a tuple(n_dim) prescribes 0 (free) or 1 (fixed) for each</span>
<span class="sd">            degree of freedom.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        corners_disp_range : numpy.ndarray(3d)</span>
<span class="sd">            Patch corners displacements range</span>
<span class="sd">            (numpy.ndarray(n_corners, n_dim, k), where k=0 (min) and k=1</span>
<span class="sd">            (max)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize corners displacement range</span>
        <span class="n">corners_disp_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_corners</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="c1"># Set corners displacement range</span>
        <span class="k">if</span> <span class="n">corners_lab_disp_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Loop over corners</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_corners</span><span class="p">):</span>
                <span class="c1"># Loop over dimensions</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">):</span>
                        <span class="c1"># Set null displacement range</span>
                        <span class="n">corners_disp_range</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">corners_lab_disp_range</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># Get mapping between corners labels and internal indexing</span>
            <span class="n">corners_mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corners_mapping</span>
            <span class="c1"># Loop over corners</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_corners</span><span class="p">):</span>
                <span class="c1"># Get corner label, dimension and internal index</span>
                <span class="n">label</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">corners_mapping</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">corners_lab_disp_range</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="c1"># Check displacement ranges</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">corners_lab_disp_range</span><span class="p">[</span><span class="n">label</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Corner displacement ranges &#39;</span>
                                           <span class="s1">&#39;must be a tuple of tuples.&#39;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">corners_lab_disp_range</span><span class="p">[</span><span class="n">label</span><span class="p">])</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Corner displacement range &#39;</span>
                                           <span class="s1">&#39;must be specified for all &#39;</span>
                                           <span class="s1">&#39;dimensions.&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">range_dims</span> <span class="o">=</span> <span class="n">corners_lab_disp_range</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
                    <span class="c1"># Loop over dimensions</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">):</span>
                        <span class="c1"># Check displacement range</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">range_dims</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Corner displacement range &#39;</span>
                                               <span class="s1">&#39;must be a tuple(min, max) &#39;</span>
                                               <span class="s1">&#39;along each dimension.&#39;</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">range_dims</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Corner displacement range &#39;</span>
                                               <span class="s1">&#39;must be a tuple(min, max) &#39;</span>
                                               <span class="s1">&#39;along each dimension.&#39;</span><span class="p">)</span>
                        <span class="c1"># Set corner displacement range</span>
                        <span class="n">corners_disp_range</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">range_dims</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>       
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Invalid specification of &#39;</span>
                               <span class="s1">&#39;corners_lab_disp_range.&#39;</span><span class="p">)</span>         
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Enforce boundary conditions</span>
        <span class="k">if</span> <span class="n">corners_bc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_corners</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">corners_bc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">corners_disp_range</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~     </span>
        <span class="k">return</span> <span class="n">corners_disp_range</span>             </div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._build_edges_poly_orders"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._build_edges_poly_orders">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_build_edges_poly_orders</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges_lab_def_order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build patch edges deformation polynomials orders.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edges_lab_def_order : {int, dict}, default=None</span>
<span class="sd">            Deformation polynomial order (item, int) for each edge label</span>
<span class="sd">            (key, str[int]). Edges are labeled from 1 to number of edges.</span>
<span class="sd">            If a single order is provided, then it is assumed for all the</span>
<span class="sd">            edges. Zero order is assumed for unspecified edges. If None, zero</span>
<span class="sd">            order is assumed for all the edges.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        edges_poly_orders : dict</span>
<span class="sd">            For each dimension (key, str[int]), store the corresponding edges</span>
<span class="sd">            deformation polynomials orders (item, list[int]).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set number of edges oriented along each dimension</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">n_edges_per_dim</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_edges_per_dim</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize edges deformation polynomials orders</span>
        <span class="n">edges_poly_orders</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="n">n_edges_per_dim</span><span class="o">*</span><span class="p">[</span><span class="mi">0</span><span class="p">,]</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)}</span>
        <span class="c1"># Build edges deformation polynomials orders</span>
        <span class="k">if</span> <span class="n">edges_lab_def_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Set zero order deformation polynomial by default</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">):</span>
                <span class="n">edges_poly_orders</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">n_edges_per_dim</span><span class="o">*</span><span class="p">[</span><span class="mi">0</span><span class="p">,]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edges_lab_def_order</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="c1"># Enforce minimum of zero order polynomial</span>
            <span class="n">edges_lab_def_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">edges_lab_def_order</span><span class="p">))</span>
            <span class="c1"># Set edges deformation polynomials orders</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">):</span>
                <span class="n">edges_poly_orders</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> \
                    <span class="n">n_edges_per_dim</span><span class="o">*</span><span class="p">[</span><span class="n">edges_lab_def_order</span><span class="p">,]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edges_lab_def_order</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># Get mapping between edges labels and internal indexing</span>
            <span class="n">edges_mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_mapping</span>
            <span class="c1"># Set edges deformation polynomials orders</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_edges</span><span class="p">):</span>
                <span class="c1"># Get edge label, dimension and internal index</span>
                <span class="n">label</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">edges_mapping</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">edges_mapping</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># Set edge deformation polynomials order</span>
                <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">edges_lab_def_order</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>                    
                    <span class="c1"># Get deformation polynomial order</span>
                    <span class="n">order</span> <span class="o">=</span> <span class="n">edges_lab_def_order</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Edge polynomial order must be a &#39;</span>
                                           <span class="s1">&#39;non-negative integer.&#39;</span><span class="p">)</span>
                    <span class="c1"># Enforce minimum polynomial order</span>
                    <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">order</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Assume zero order polynomial</span>
                    <span class="n">order</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># Set edge deformation polynomial order</span>
                <span class="n">edges_poly_orders</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">order</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Invalid specification of edges_lab_def_order.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~     </span>
        <span class="k">return</span> <span class="n">edges_poly_orders</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._build_edges_disp_range"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._build_edges_disp_range">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_build_edges_disp_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges_lab_disp_range</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build patch edges displacements range.</span>
<span class="sd">         </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edges_lab_disp_range : dict, default=None</span>
<span class="sd">            Displacement range (item, tuple[float](2)) for each edge</span>
<span class="sd">            label (key, str[int]). Edges are labeled from 1 to number of edges.</span>
<span class="sd">            Range is specified as a tuple(min, max) where: (1) displacement</span>
<span class="sd">            range is orthogonal and relative to the edge (defined by limiting</span>
<span class="sd">            corner nodes in the deformed configuration), (2) positive/negative</span>
<span class="sd">            displacement corresponds to outward/inward direction with respect</span>
<span class="sd">            to the patch. Null displacement range is assumed for unspecified</span>
<span class="sd">            edges. If None, null displacement range is set by default.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        edge_disp_range : dict</span>
<span class="sd">            For each dimension (key, str[int]), store the corresponding edges</span>
<span class="sd">            displacement range (item, tuple[tuple(min, max)]).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set number of edges oriented along each dimension</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">n_edges_per_dim</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_edges_per_dim</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize edges displacements range</span>
        <span class="n">edge_disp_range</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="n">n_edges_per_dim</span><span class="o">*</span><span class="p">[(),]</span>
                           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)}</span>
        <span class="c1"># Build edges displacements range</span>
        <span class="k">if</span> <span class="n">edges_lab_disp_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Set null displacement range by default</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">):</span>
                <span class="n">edge_disp_range</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">n_edges_per_dim</span><span class="o">*</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edges_lab_disp_range</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># Get mapping between edges labels and internal indexing</span>
            <span class="n">edges_mapping</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_mapping</span>
            <span class="c1"># Set edges displacements range</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_edges</span><span class="p">):</span>
                <span class="c1"># Get edge label, dimension and internal index</span>
                <span class="n">label</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">edges_mapping</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">edges_mapping</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># Set edge displacement range</span>
                <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">edges_lab_disp_range</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>                    
                    <span class="c1"># Get displacement range</span>
                    <span class="n">disp_range</span> <span class="o">=</span> <span class="n">edges_lab_disp_range</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">disp_range</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Edge displacement range must &#39;</span>
                                           <span class="s1">&#39;be a tuple(min, max).&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Assume null displacement range</span>
                    <span class="n">disp_range</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="c1"># Set edge displacement range</span>
                <span class="n">edge_disp_range</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">disp_range</span>
            <span class="c1"># Loop over dimensions</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">):</span>
                <span class="n">edge_disp_range</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">edge_disp_range</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Invalid specification of &#39;</span>
                               <span class="s1">&#39;edges_lab_disp_range.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~     </span>
        <span class="k">return</span> <span class="n">edge_disp_range</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._set_corners_attributes"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._set_corners_attributes">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_set_corners_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set patch corners attributes.&quot;&quot;&quot;</span> 
        <span class="c1"># Set mapping between corners labels and internal indexing</span>
        <span class="n">corners_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_corners</span><span class="p">)}</span>     
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_corners_mapping</span> <span class="o">=</span> <span class="n">corners_mapping</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._set_corners_coords_ref"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._set_corners_coords_ref">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_set_corners_coords_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set patch corners coordinates (reference configuration).&quot;&quot;&quot;</span>
        <span class="c1"># Get patch dimensions</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patch_dims</span>
        <span class="c1"># Set corners coordinates</span>
        <span class="n">corners_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_corners</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">corners_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
            <span class="n">corners_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">])</span>
            <span class="n">corners_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="n">corners_coords</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">corners_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
            <span class="n">corners_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
            <span class="n">corners_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">])</span>
            <span class="n">corners_coords</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">])</span>
            <span class="n">corners_coords</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
            <span class="n">corners_coords</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
            <span class="n">corners_coords</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
            <span class="n">corners_coords</span><span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_corners_coords_ref</span> <span class="o">=</span> <span class="n">corners_coords</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._set_edges_attributes"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._set_edges_attributes">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_set_edges_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set patch edges attributes.&quot;&quot;&quot;</span> 
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Set edges connectities with respect to corners</span>
            <span class="n">edges_per_dim</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
                             <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))}</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Set edges reference diagonal with respect to corners</span>
            <span class="n">edges_diag_per_dim</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
                                  <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))}</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Set mapping between edges labels and internal indexing</span>
            <span class="n">edges_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                             <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Set edges connectities with respect to corners</span>
            <span class="n">edges_per_dim</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
                                   <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">)),</span>
                             <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
                                   <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)),</span>
                             <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
                                   <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">))}</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Set edges reference diagonal with respect to corners</span>
            <span class="n">edges_diag_per_dim</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
                                        <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
                                  <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span>
                                        <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
                                  <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
                                        <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">))}</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Set mapping between edges labels and internal indexing</span>
            <span class="n">edges_mapping</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;6&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s1">&#39;7&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;8&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                <span class="s1">&#39;9&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="s1">&#39;10&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="s1">&#39;11&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;12&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                <span class="s1">&#39;13&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="s1">&#39;14&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="s1">&#39;15&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="s1">&#39;16&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                <span class="s1">&#39;17&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="s1">&#39;18&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="s1">&#39;19&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="s1">&#39;20&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
                <span class="s1">&#39;21&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="s1">&#39;22&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="s1">&#39;23&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="s1">&#39;24&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="mi">7</span><span class="p">)}</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges_per_dim</span> <span class="o">=</span> <span class="n">edges_per_dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges_diag_per_dim</span> <span class="o">=</span> <span class="n">edges_diag_per_dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges_mapping</span> <span class="o">=</span> <span class="n">edges_mapping</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._get_matching_edges_idxs"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._get_matching_edges_idxs">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_get_matching_edges_idxs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get matching edges indexes along each dimension.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matching_edges_idxs_per_dim : dict</span>
<span class="sd">            For each dimension (key, str[int]), store maching edges internal</span>
<span class="sd">            indexes (item, tuple[tuple]). Matching edges share the same</span>
<span class="sd">            connectivities with respect to corners.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize matching edges indexes</span>
        <span class="n">matching_edges_idxs_per_dim</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">):</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)}</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Loop over dimensions</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">):</span>
            <span class="c1"># Get unique edges connectivities with respect to corners</span>
            <span class="n">unique_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edges_per_dim</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Loop over unique edges</span>
            <span class="k">for</span> <span class="n">target_pair</span> <span class="ow">in</span> <span class="n">unique_edges</span><span class="p">:</span>
                <span class="c1"># Get matching edges indexes</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edges_per_dim</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
                     <span class="k">if</span> <span class="n">pair</span> <span class="o">==</span> <span class="n">target_pair</span><span class="p">])</span>
                <span class="c1"># Store unique edge indexes</span>
                <span class="n">matching_edges_idxs_per_dim</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Convert to tuple</span>
            <span class="n">matching_edges_idxs_per_dim</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> \
                <span class="nb">tuple</span><span class="p">(</span><span class="n">matching_edges_idxs_per_dim</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">matching_edges_idxs_per_dim</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._get_n_edge_nodes_per_dim"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._get_n_edge_nodes_per_dim">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_get_n_edge_nodes_per_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem_type</span><span class="p">,</span> <span class="n">n_elems_per_dim</span><span class="p">):</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get number of patch edge nodes along each dimension.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elem_type : str</span>
<span class="sd">            Finite element type.</span>
<span class="sd">        n_elems_per_dim : tuple[int]</span>
<span class="sd">            Number of finite elements per dimension.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n_edge_nodes_per_dim : tuple[int]</span>
<span class="sd">            Number of patch edge nodes along each dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get number of edge nodes per element</span>
        <span class="n">n_edge_nodes_elem</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="n">elem_type</span><span class="p">)</span><span class="o">.</span><span class="n">get_n_edge_nodes</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute number of patch edge nodes along each dimension</span>
        <span class="n">n_edge_nodes_per_dim</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Loop over each dimension</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">):</span>
            <span class="c1"># Compute number of edge nodes</span>
            <span class="n">n_edge_nodes_per_dim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_elems_per_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">n_edge_nodes_elem</span>
                                        <span class="o">-</span> <span class="p">(</span><span class="n">n_elems_per_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">n_edge_nodes_per_dim</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._get_corners_random_displacements"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._get_corners_random_displacements">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_get_corners_random_displacements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corners_disp_range</span><span class="p">,</span>
                                          <span class="n">edges_poly_orders</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute patch corners random displacements.</span>
<span class="sd">        </span>
<span class="sd">        Edges deformation polynomial order may be updated in-place to enforce</span>
<span class="sd">        a zero order deformation polynomial in all matching edges if at least</span>
<span class="sd">        one of them has been prescribed a zero order deformation polynomial.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        corners_disp_range : numpy.ndarray(3d)</span>
<span class="sd">            Patch corners displacements range</span>
<span class="sd">            (numpy.ndarray(n_corners, n_dim, k), where k=0 (min) and k=1</span>
<span class="sd">            (max)).</span>
<span class="sd">        edges_poly_orders : dict, default=None</span>
<span class="sd">            For each dimension (key, str[int]), store the corresponding edges</span>
<span class="sd">            deformation polynomials orders (item, tuple[int]).</span>
<span class="sd">              </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        corners_disp : numpy.ndarray(2d)</span>
<span class="sd">            Patch corners displacements (numpy.ndarray(n_corners, n_dim)).</span>
<span class="sd">        corners_disp_range : numpy.ndarray(3d)</span>
<span class="sd">            Patch corners displacements range</span>
<span class="sd">            (numpy.ndarray(n_corners, n_dim, k), where k=0 (min) and k=1</span>
<span class="sd">            (max)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize corners displacements</span>
        <span class="n">corners_disp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_corners</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">))</span>
        <span class="c1"># Loop over corners</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_corners</span><span class="p">):</span>
            <span class="c1"># Loop over dimensions</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">):</span>
                <span class="c1"># Get displacement bounds</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="n">corners_disp_range</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                          <span class="n">corners_disp_range</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="c1"># Sample random displacement along dimension: uniform</span>
                <span class="c1"># distribution</span>
                <span class="n">corners_disp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                       <span class="n">high</span><span class="o">=</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Enforce edge zero order deformation polynomial</span>
        <span class="k">if</span> <span class="n">edges_poly_orders</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Get matching edges indexes along each dimension</span>
            <span class="n">matching_edges_idxs_per_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_matching_edges_idxs</span><span class="p">()</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Loop over dimensions</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">):</span>
                <span class="c1"># Get orthogonal dimensions</span>
                <span class="n">orth_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_orthogonal_dims</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="c1"># Loop over edges</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">cid_init</span><span class="p">,</span> <span class="n">cid_end</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_edges_per_dim</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]):</span>
                    <span class="c1"># If edge zero order deformation polynomial</span>
                    <span class="k">if</span> <span class="n">edges_poly_orders</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># Loop over orthogonal dimensions</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">orth_dims</span><span class="p">:</span>
                            <span class="c1"># Get displacement ranges</span>
                            <span class="n">range_l</span> <span class="o">=</span> <span class="p">(</span><span class="n">corners_disp_range</span><span class="p">[</span><span class="n">cid_init</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                       <span class="n">corners_disp_range</span><span class="p">[</span><span class="n">cid_init</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                            <span class="n">range_r</span> <span class="o">=</span> <span class="p">(</span><span class="n">corners_disp_range</span><span class="p">[</span><span class="n">cid_end</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                       <span class="n">corners_disp_range</span><span class="p">[</span><span class="n">cid_end</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                            <span class="c1"># Check displacement range intersection</span>
                            <span class="n">min_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">range_l</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">range_r</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                            <span class="n">max_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">range_l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">range_r</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                            <span class="k">if</span> <span class="n">min_max</span> <span class="o">&gt;</span> <span class="n">max_min</span><span class="p">:</span>
                                <span class="c1"># If non-null intersection range, then sample</span>
                                <span class="c1"># random displacement along dimension on that</span>
                                <span class="c1"># range: uniform distribution</span>
                                <span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_min</span><span class="p">,</span> <span class="n">min_max</span><span class="p">)</span>
                                <span class="n">disp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                         <span class="n">high</span><span class="o">=</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># If null intersection range, then sample</span>
                                <span class="c1"># random displacement along dimension on each</span>
                                <span class="c1"># range (uniform distribution) and take the</span>
                                <span class="c1"># average value</span>
                                <span class="n">disp_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">range_l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                           <span class="n">high</span><span class="o">=</span><span class="n">range_l</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                                <span class="n">disp_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">range_r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                           <span class="n">high</span><span class="o">=</span><span class="n">range_r</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                                <span class="n">disp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">((</span><span class="n">disp_l</span><span class="p">,</span> <span class="n">disp_r</span><span class="p">))</span>
                            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                            <span class="c1"># Enforce the same displacement on both corners</span>
                            <span class="n">corners_disp</span><span class="p">[</span><span class="n">cid_init</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">disp</span>
                            <span class="n">corners_disp</span><span class="p">[</span><span class="n">cid_end</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">disp</span>
                        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                        <span class="c1"># Loop over matching edges indexes</span>
                        <span class="k">for</span> <span class="n">indexes</span> <span class="ow">in</span> <span class="n">matching_edges_idxs_per_dim</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]:</span>
                            <span class="c1"># Check for current edge matching indexes</span>
                            <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
                                <span class="c1"># Enforce matching edge zero order deformation</span>
                                <span class="c1"># polynomial (in-place update)</span>
                                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
                                    <span class="n">edges_poly_orders</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~     </span>
        <span class="k">return</span> <span class="n">corners_disp</span><span class="p">,</span> <span class="n">corners_disp_range</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._get_deformed_boundary_edge"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._get_deformed_boundary_edge">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_get_deformed_boundary_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes_coords_ref</span><span class="p">,</span> <span class="n">left_node_def</span><span class="p">,</span>
                                    <span class="n">right_node_def</span><span class="p">,</span> <span class="n">poly_order</span><span class="p">,</span>
                                    <span class="n">poly_bounds_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                                    <span class="n">is_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get randomly deformed boundary edge node coordinates in 2D plane.</span>
<span class="sd">        </span>
<span class="sd">        The boundary edge nodes (reference configuration) must be sorted</span>
<span class="sd">        along the first dimension (either ascending or descending order).</span>
<span class="sd">        </span>
<span class="sd">        The deformed configuration of the boundary edge is computed by sampling</span>
<span class="sd">        a random polynomial along the second dimension of the deformed boundary</span>
<span class="sd">        edge local coordinates.</span>
<span class="sd">        </span>
<span class="sd">        The boundary edge nodes are then projected to the deformed</span>
<span class="sd">        configuration and the corresponding displacements are computed based on</span>
<span class="sd">        the reference coordinates.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes_coords_ref : numpy.ndarray(2d)</span>
<span class="sd">            Boundary edge nodes coordinates in the reference configuration</span>
<span class="sd">            (numpy.ndarray(n_edge_nodes, 2)). </span>
<span class="sd">        left_node_def : numpy.ndarray(1d)</span>
<span class="sd">            Boundary edge leftmost node coordinates in the deformed</span>
<span class="sd">            configuration (numpy.ndarray(2)).</span>
<span class="sd">        right_node_def : numpy.ndarray(1d)</span>
<span class="sd">            Boundary edge rightmost node coordinates in the deformed</span>
<span class="sd">            configuration (numpy.ndarray(2)).</span>
<span class="sd">        poly_order : int</span>
<span class="sd">            Order of random polynomial sampled to generate the deformed</span>
<span class="sd">            configuration of the boundary edge.</span>
<span class="sd">        poly_bounds_range : tuple[float], default=None</span>
<span class="sd">            Polynomial range along second dimension. Range is relative to</span>
<span class="sd">            midplane defined by both boundary edge nodes along the second</span>
<span class="sd">            dimension.</span>
<span class="sd">        noise : float, default=0.0</span>
<span class="sd">            Parameter that controls the normally distributed noise superimposed</span>
<span class="sd">            to the boundary edges interior nodes coordinates in the deformed</span>
<span class="sd">            configuration. Defines the noise standard deviation along given</span>
<span class="sd">            dimension after being multiplied by the corresponding patch size.</span>
<span class="sd">        is_plot : bool, default=False</span>
<span class="sd">            If True, plot boundary edge reference and deformed configurations.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nodes_coords_def : numpy.ndarray(2d)</span>
<span class="sd">            Boundary edge nodes coordinates in the deformed configuration</span>
<span class="sd">            (numpy.ndarray(n_edge_nodes, 2)).</span>
<span class="sd">        nodes_disp : numpy.ndarray(2d)</span>
<span class="sd">            Boundary edge nodes displacements (numpy.ndarray(n_edge_nodes, 2)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check limit nodes</span>
        <span class="k">if</span> <span class="n">left_node_def</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">right_node_def</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Invalid boundary edge limit nodes coordinates &#39;</span>
                               <span class="s1">&#39;along first dimension.&#39;</span><span class="p">)</span>
        <span class="c1"># Check if boundary edge nodes coordinates in the reference</span>
        <span class="c1"># configuration are sorted</span>
        <span class="n">is_sorted_ascend</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">arr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">is_sorted_descend</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">arr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sorted_ascend</span><span class="p">(</span><span class="n">nodes_coords_ref</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_sorted_descend</span><span class="p">(</span><span class="n">nodes_coords_ref</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Boundary edge nodes coordinates must be &#39;</span>
                               <span class="s1">&#39;sorted in ascending or descending order along &#39;</span>
                               <span class="s1">&#39;the first dimension.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize flip boundary edge nodes order flag</span>
        <span class="n">is_flipped</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Check if boundary edge nodes are sorted in ascending order along</span>
        <span class="c1"># first dimension</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_sorted_ascend</span><span class="p">(</span><span class="n">nodes_coords_ref</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># Set flip boundary edge nodes order flag</span>
            <span class="n">is_flipped</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># Flip boundary edge nodes order (reference configuration)</span>
            <span class="n">nodes_coords_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">nodes_coords_ref</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get reference coordinate</span>
        <span class="n">ref_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">left_node_def</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">right_node_def</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="c1"># Compute polynomial bounds</span>
        <span class="k">if</span> <span class="n">poly_bounds_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Assume null polynomial bounds range</span>
            <span class="n">poly_lower_bound</span> <span class="o">=</span> <span class="n">ref_coord</span>
            <span class="n">poly_upper_bound</span> <span class="o">=</span> <span class="n">ref_coord</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">poly_bounds_range</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Polynomial bounds range must be &#39;</span>
                                   <span class="s1">&#39;specified as a tuple(min, max).&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly_bounds_range</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Polynomial bounds range must be &#39;</span>
                                   <span class="s1">&#39;specified as a tuple(min, max).&#39;</span><span class="p">)</span>
            <span class="c1"># Compute polynomial bounds from range</span>
            <span class="n">poly_lower_bound</span> <span class="o">=</span> <span class="n">ref_coord</span> <span class="o">+</span> <span class="n">poly_bounds_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">poly_upper_bound</span> <span class="o">=</span> <span class="n">ref_coord</span> <span class="o">+</span> <span class="n">poly_bounds_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Generate random polynomial</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_polynomial_sampler</span><span class="p">(</span>
            <span class="n">poly_order</span><span class="p">,</span> <span class="n">left_node_def</span><span class="p">,</span> <span class="n">right_node_def</span><span class="p">,</span>
            <span class="n">lower_bound</span><span class="o">=</span><span class="n">poly_lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="o">=</span><span class="n">poly_upper_bound</span><span class="p">)</span>
        <span class="c1"># Polynomial evaluation</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">coefficients</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">i</span>
                           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coefficients</span><span class="p">))])</span>
        <span class="c1"># 1D coordinates linear mapping</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">linear_coord_map</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x1_lower</span><span class="p">,</span> <span class="n">x1_upper</span><span class="p">,</span> <span class="n">x2_lower</span><span class="p">,</span> <span class="n">x2_upper</span><span class="p">):</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">x2_upper</span> <span class="o">-</span> <span class="n">x2_lower</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">x1_upper</span> <span class="o">-</span> <span class="n">x1_lower</span><span class="p">)</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="n">x2_lower</span> <span class="o">+</span> <span class="n">ratio</span><span class="o">*</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x1_lower</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">x2</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set number of points for polynomial first-order approximation</span>
        <span class="n">n_poly_points</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="c1"># Compute point index step length</span>
        <span class="n">point_step</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">n_poly_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Compute first-order approximation of polynomial cord lengths</span>
        <span class="n">cord_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_poly_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Get cord points coordinates along first dimension</span>
            <span class="n">x1_l</span> <span class="o">=</span> <span class="n">linear_coord_map</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">point_step</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                                    <span class="n">left_node_def</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">right_node_def</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">x1_r</span> <span class="o">=</span> <span class="n">linear_coord_map</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">point_step</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                                    <span class="n">left_node_def</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">right_node_def</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># Compute cord points coordinates from polynomial</span>
            <span class="n">point_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x1_l</span><span class="p">,</span> <span class="n">polynomial</span><span class="p">(</span><span class="n">x1_l</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">)])</span>
            <span class="n">point_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x1_r</span><span class="p">,</span> <span class="n">polynomial</span><span class="p">(</span><span class="n">x1_r</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">)])</span>
            <span class="c1"># Compute linear distance between cord points</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">point_r</span> <span class="o">-</span> <span class="n">point_l</span><span class="p">)</span>
            <span class="c1"># Store cord length</span>
            <span class="n">cord_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cord_lengths</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>            
        <span class="c1"># Compute points fractional positions along polynomial</span>
        <span class="n">total_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cord_lengths</span><span class="p">)</span>
        <span class="n">frac_point_positions</span> <span class="o">=</span> \
            <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">total_length</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cord_lengths</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
                                         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_poly_points</span><span class="p">)])</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get number of boundary edge nodes</span>
        <span class="n">n_nodes</span> <span class="o">=</span> <span class="n">nodes_coords_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Initialize boundary edge nodes deformed coordinates</span>
        <span class="n">nodes_coords_def</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_nodes</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="c1"># Set boundary edge limit nodes deformed coordinates</span>
        <span class="n">nodes_coords_def</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">left_node_def</span>
        <span class="n">nodes_coords_def</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">right_node_def</span>
        <span class="c1"># Compute first-order approximation of boundary edge reference</span>
        <span class="c1"># configuration cord lengths</span>
        <span class="n">cord_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_nodes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Get boundary cord points coordinates</span>
            <span class="n">point_l</span> <span class="o">=</span> <span class="n">nodes_coords_ref</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">point_r</span> <span class="o">=</span> <span class="n">nodes_coords_ref</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="c1"># Compute linear distance between cord points</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">point_r</span> <span class="o">-</span> <span class="n">point_l</span><span class="p">)</span>
            <span class="c1"># Store cord length</span>
            <span class="n">cord_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cord_lengths</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span> 
        <span class="c1"># Compute nodes fractional positions along boundary edge</span>
        <span class="n">total_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cord_lengths</span><span class="p">)</span>
        <span class="n">frac_node_positions</span> <span class="o">=</span> \
            <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">total_length</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cord_lengths</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
                                         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">)])</span>
        <span class="c1"># Loop over boundary edge interior nodes</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_nodes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Get boundary edge node fractional position</span>
            <span class="n">frac_node_position</span> <span class="o">=</span> <span class="n">frac_node_positions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># Find node position index with respect to polynomial points</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">frac_point_positions</span><span class="p">,</span> <span class="n">frac_node_position</span><span class="p">,</span>
                                    <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
            <span class="c1"># Get adjacent polynomial points fractional position</span>
            <span class="n">index_l</span> <span class="o">=</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">fp_l</span> <span class="o">=</span> <span class="n">frac_point_positions</span><span class="p">[</span><span class="n">index_l</span><span class="p">]</span>
            <span class="n">index_r</span> <span class="o">=</span> <span class="n">index</span>
            <span class="n">fp_r</span> <span class="o">=</span> <span class="n">frac_point_positions</span><span class="p">[</span><span class="n">index_r</span><span class="p">]</span>
            <span class="c1"># Get node index fractional position</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">index_l</span><span class="o">*</span><span class="n">point_step</span> \
                <span class="o">+</span> <span class="p">((</span><span class="n">frac_node_position</span> <span class="o">-</span> <span class="n">fp_l</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">fp_r</span> <span class="o">-</span> <span class="n">fp_l</span><span class="p">))</span><span class="o">*</span><span class="n">point_step</span>
            <span class="c1"># Compute node coordinate along first dimension</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">linear_coord_map</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left_node_def</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">right_node_def</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># Store node deformed coordinates</span>
            <span class="n">nodes_coords_def</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">polynomial</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">)])</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize node deformed coordinates noise</span>
        <span class="n">nodes_coords_noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">nodes_coords_def</span><span class="p">)</span>
        <span class="c1"># Loop over dimensions</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="c1"># Set noise standard deviation</span>
            <span class="n">noise_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_patch_dims</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># Sample coordinates noise along dimension: normal distribution</span>
            <span class="n">nodes_coords_noise</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span>
                <span class="n">loc</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">noise_std</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">nodes_coords_def</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># Add noise to interior nodes deformed coordinates</span>
        <span class="n">nodes_coords_def</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">nodes_coords_noise</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Revert boundary edge nodes to original order (reference</span>
        <span class="c1"># configuration)</span>
        <span class="k">if</span> <span class="n">is_flipped</span><span class="p">:</span>
            <span class="n">nodes_coords_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">nodes_coords_ref</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        </span>
        <span class="c1"># Compute boundary edge nodes displacements</span>
        <span class="n">nodes_disp</span> <span class="o">=</span> <span class="n">nodes_coords_def</span> <span class="o">-</span> <span class="n">nodes_coords_ref</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Plot boundary edge reference and deformed configurations</span>
        <span class="k">if</span> <span class="n">is_plot</span><span class="p">:</span>
            <span class="c1"># Generate plot</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
            <span class="c1"># Plot reference boundary edge</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">nodes_coords_ref</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">)],</span>
                    <span class="p">[</span><span class="n">nodes_coords_ref</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">)],</span>
                    <span class="s1">&#39;-o&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span> 
            <span class="c1"># Plot deformed boundary edge polynomial</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">left_node_def</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">right_node_def</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">100</span><span class="p">)</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="p">[</span><span class="n">polynomial</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">x1</span><span class="p">]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#1f77b4&#39;</span><span class="p">)</span>
            <span class="c1"># Plot deformed boundary edge nodes</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">nodes_coords_def</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">)],</span>
                    <span class="p">[</span><span class="n">nodes_coords_def</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_nodes</span><span class="p">)],</span>
                    <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#d62728&#39;</span><span class="p">)</span>
            <span class="c1"># Set axes properties</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span> <span class="n">adjustable</span><span class="o">=</span><span class="s1">&#39;box&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">nodes_coords_def</span><span class="p">,</span> <span class="n">nodes_disp</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._polynomial_sampler"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._polynomial_sampler">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_polynomial_sampler</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">left_point</span><span class="p">,</span> <span class="n">right_point</span><span class="p">,</span> <span class="n">lower_bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">upper_bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate random polynomial by sampling points within given bounds.</span>
<span class="sd">        </span>
<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        order : int</span>
<span class="sd">            Order of polynomial.</span>
<span class="sd">        left_point : tuple[float]</span>
<span class="sd">            Leftmost control point of polynomial. Sets sampling lower bound</span>
<span class="sd">            along first dimension.</span>
<span class="sd">        right_point : tuple[float]</span>
<span class="sd">            Rightmost control point of polynomial. Sets sampling upper bound</span>
<span class="sd">            along first dimension.</span>
<span class="sd">        lower_bound : float, default=None</span>
<span class="sd">            Sampling lower bound along second dimension. If None, lower bound</span>
<span class="sd">            is set from limit control points.</span>
<span class="sd">        upper_bound : float, default=None</span>
<span class="sd">            Sampling upper bound along second dimension. If None, upper bound</span>
<span class="sd">            is set from limit control points.</span>
<span class="sd">        is_plot : bool, default=False</span>
<span class="sd">            If True, plot randomly generated polynomial.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coefficients : tuple[float]</span>
<span class="sd">            Polynomial coefficients sorted by increasing order terms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set number of sampled internal points</span>
        <span class="n">n_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">order</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># Set total number of points</span>
        <span class="n">n_point</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">n_int</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Check sampling boundaries</span>
        <span class="k">if</span> <span class="n">lower_bound</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">left_point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">right_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">upper_bound</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">left_point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">right_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="c1"># Set sampling boundaries</span>
        <span class="n">sampling_bounds</span> <span class="o">=</span> <span class="p">((</span><span class="n">left_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">right_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                           <span class="p">(</span><span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">))</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        </span>
        <span class="c1"># Get sampling points coordinates along first dimension: evenly spaced</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">sampling_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                         <span class="n">stop</span><span class="o">=</span><span class="n">sampling_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                         <span class="n">num</span><span class="o">=</span><span class="n">n_point</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Get sampling points coordinates along second dimension: uniform</span>
        <span class="c1"># distribution</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">sampling_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                               <span class="n">high</span><span class="o">=</span><span class="n">sampling_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                               <span class="n">size</span><span class="o">=</span><span class="n">n_int</span><span class="p">)</span>
        <span class="c1"># Set sampling points</span>
        <span class="n">sampling_points</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_int</span><span class="p">)]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Assemble polynomial points</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">left_point</span><span class="p">,</span> <span class="n">right_point</span><span class="p">]</span> <span class="o">+</span> <span class="n">sampling_points</span>
        <span class="c1"># Build matrix and right-hand side</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_point</span><span class="p">,</span> <span class="n">n_point</span><span class="p">))</span>
        <span class="n">rhs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_point</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_point</span><span class="p">):</span>
            <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">control_points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_point</span><span class="p">)]</span>
            <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">control_points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Solve system of equations for polynomial coefficients</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">rhs</span><span class="p">))</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Plot polynomial</span>
        <span class="k">if</span> <span class="n">is_plot</span><span class="p">:</span>
            <span class="c1"># Evaluate polynomial</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">polynomial</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">coefficients</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">i</span>
                               <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coefficients</span><span class="p">))])</span>
            <span class="c1"># Generate plot</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
            <span class="c1"># Plot reference line (second dimension)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">left_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">right_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;k-&#39;</span><span class="p">)</span>
            <span class="c1"># Plot sampling bounds (second dimension)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">left_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">right_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="p">[</span><span class="n">lower_bound</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">],</span> <span class="s1">&#39;k--&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">left_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">right_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="p">[</span><span class="n">upper_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">],</span> <span class="s1">&#39;k--&#39;</span><span class="p">)</span>
            <span class="c1"># Plot polynomial</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">left_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">right_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">100</span><span class="p">)</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="p">[</span><span class="n">polynomial</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">x1</span><span class="p">]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#1f77b4&#39;</span><span class="p">)</span>
            <span class="c1"># Plot polynomial randomly sampled control points</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">([</span><span class="n">control_points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_point</span><span class="p">)],</span>
                       <span class="p">[</span><span class="n">control_points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_point</span><span class="p">)],</span>
                       <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#d62728&#39;</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="c1"># Set axes properties</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;x1&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;x2&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span> <span class="n">adjustable</span><span class="o">=</span><span class="s1">&#39;box&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">coefficients</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._get_random_rigid_motions"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._get_random_rigid_motions">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_get_random_rigid_motions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">translation_range</span><span class="p">,</span>
                                  <span class="n">rotation_angles_range</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get random rigid body motion tensors (translation and rotation).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        translation_range : dict, default=None</span>
<span class="sd">            Translational displacement range (item, tuple[float](2)) along each</span>
<span class="sd">            dimension (key, str[int]). Range is specified as tuple(min, max)</span>
<span class="sd">            for each dimension. Null range is assumed for unspecified</span>
<span class="sd">            dimensions. If None, then there is no translational motion.</span>
<span class="sd">        rotation_angles_range : dict, default=None</span>
<span class="sd">            Rotational angle (degrees) range (item, tuple[float](2)) for each</span>
<span class="sd">            Euler angle (key, str). Euler angles follow Bunge convention</span>
<span class="sd">            (Z1-X2-Z3) and are labeled (&#39;alpha&#39;, &#39;beta&#39;, &#39;gamma&#39;),</span>
<span class="sd">            respectively. Null range is assumed for unspecified angles. If</span>
<span class="sd">            None, then there is no rotational motion.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        translation : numpy.ndarray(1d)</span>
<span class="sd">            Translation array (numpy.ndarray(n_dim)).</span>
<span class="sd">        rotation : numpy.ndarray(2d)</span>
<span class="sd">            Rotation tensor (for given rotation angle theta, active</span>
<span class="sd">            transformation (+ theta) and passive transformation (- theta)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set translation array</span>
        <span class="k">if</span> <span class="n">translation_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">translation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Initialize translation array</span>
            <span class="n">translation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)</span>
            <span class="c1"># Loop over dimensions</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">):</span>
                <span class="c1"># Sample translation along dimension</span>
                <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">translation_range</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="c1"># Get translation bounds</span>
                    <span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="n">translation_range</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)][</span><span class="mi">0</span><span class="p">],</span>
                              <span class="n">translation_range</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="c1"># Sample translation along dimension: uniform distribution</span>
                    <span class="n">translation</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set rotation tensor</span>
        <span class="k">if</span> <span class="n">rotation_angles_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rotation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Initialize Euler angles</span>
            <span class="n">rotation_angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="c1"># Loop over Euler angles</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">angle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">((</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="s1">&#39;beta&#39;</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">)):</span>
                <span class="c1"># Process only first Euler angle under two dimensions</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">angle</span> <span class="o">!=</span> <span class="s1">&#39;alpha&#39;</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Sample Euler angle</span>
                <span class="k">if</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">rotation_angles_range</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="c1"># Get angle bounds</span>
                    <span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="n">rotation_angles_range</span><span class="p">[</span><span class="n">angle</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                              <span class="n">rotation_angles_range</span><span class="p">[</span><span class="n">angle</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="c1"># Sample angle: uniform distribution</span>
                    <span class="n">rotation_angles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">high</span><span class="o">=</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># Compute rotation tensor</span>
            <span class="n">rotation</span> <span class="o">=</span> <span class="n">rotation_tensor_from_euler_angles</span><span class="p">(</span>
                <span class="nb">tuple</span><span class="p">(</span><span class="n">rotation_angles</span><span class="p">))[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">translation</span><span class="p">,</span> <span class="n">rotation</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._get_patch_centroid"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._get_patch_centroid">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_get_patch_centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corners_coords</span><span class="p">,</span> <span class="n">edges_coords</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute patch centroid.</span>
<span class="sd">        </span>
<span class="sd">        In the three-dimensional case, the patch (geometrical) centroid is</span>
<span class="sd">        approximated by the average of the corners coordinates.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        corners_coords : numpy.ndarray(2d)</span>
<span class="sd">            Patch corners coordinates (numpy.ndarray(n_corners, n_dim)).</span>
<span class="sd">        edges_coords : dict[list[numpy.ndarray(2d)]]</span>
<span class="sd">            For each dimension (key, str[int]), store the corresponding edges</span>
<span class="sd">            coordinates (item, list[numpy.ndarray(2d)]). Each edge coordinates</span>
<span class="sd">            are stored as a numpy.ndarray(n_edge_nodes, n_dim). Corner nodes</span>
<span class="sd">            are assumed part of the edge.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        centroid : numpy.ndarray(2d)</span>
<span class="sd">            Patch centroid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get patch (geometrical) centroid</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Build boundary nodes coordinates array (close polygon)</span>
            <span class="n">boundary_coords_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_boundary_coords_array</span><span class="p">(</span>
                <span class="n">edges_coords</span><span class="p">,</span> <span class="n">is_close_polygon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Generate boundary polygon</span>
            <span class="n">polygon</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">boundary_coords_array</span><span class="p">)</span>
            <span class="c1"># Get boundary polygon centroid</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Approximate patch (geometrical) centroid by averaging the corners</span>
            <span class="c1"># coordinates</span>
            <span class="n">centroid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">corners_coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">centroid</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._build_boundary_coords_array"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._build_boundary_coords_array">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_build_boundary_coords_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges_coords</span><span class="p">,</span>
                                     <span class="n">is_close_polygon</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build patch boundary nodes coordinates array.</span>
<span class="sd">        </span>
<span class="sd">        In the two-dimensional case, boundary nodes are sorted in clockwise</span>
<span class="sd">        order. A closed polygon is obtained by setting is_close_polygon to</span>
<span class="sd">        True.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edges_coords : dict</span>
<span class="sd">            For each dimension (key, str[int]), store the corresponding edges</span>
<span class="sd">            coordinates (item, list[numpy.ndarray(2d)]). Each edge coordinates</span>
<span class="sd">            are stored as a numpy.ndarray(n_edge_nodes, n_dim). Corner nodes</span>
<span class="sd">            are assumed part of the edge.</span>
<span class="sd">        is_close_polygon : bool, default=False</span>
<span class="sd">            If True, then close the polygon by adding a copy of the first node</span>
<span class="sd">            to the end of the boundary nodes coordinates array.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        boundary_coords_array : numpy.ndarray(2d)</span>
<span class="sd">            Boundary nodes coordinates array (numpy.ndarray(n_points, n_dim)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Initialize polygon coordinates</span>
            <span class="n">coords_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Set edges clockwise order based on corners indexes</span>
            <span class="n">edges_clockwise</span> <span class="o">=</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Loop over edges in clockwise order</span>
            <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">edges_clockwise</span><span class="p">:</span>
                <span class="c1"># Loop over edges</span>
                <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="c1"># Get edge dimension and internal index</span>
                    <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_mapping</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_mapping</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="c1"># Get edge corners</span>
                    <span class="n">corners</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_per_dim</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">index</span><span class="p">]</span>
                    <span class="c1"># Check if target edge</span>
                    <span class="n">is_target_edge</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Append edge </span>
                    <span class="k">if</span> <span class="n">is_target_edge</span><span class="p">:</span>
                        <span class="c1"># Get edge nodes coordinates</span>
                        <span class="n">edge_coords</span> <span class="o">=</span> <span class="n">edges_coords</span><span class="p">[</span><span class="n">dim</span><span class="p">][</span><span class="n">index</span><span class="p">]</span>                        
                        <span class="c1"># Set nodes sorting</span>
                        <span class="n">is_flip</span> <span class="o">=</span> <span class="n">target</span> <span class="o">!=</span> <span class="n">corners</span>
                        <span class="c1"># Sort edge nodes according to clockwise order</span>
                        <span class="k">if</span> <span class="n">is_flip</span><span class="p">:</span>
                            <span class="n">edge_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">edge_coords</span><span class="p">)</span>
                        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                        <span class="c1"># Append edge nodes to polygon coordinates</span>
                        <span class="n">coords_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords_array</span><span class="p">,</span>
                                                 <span class="n">edge_coords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Close polygon coordinates</span>
            <span class="k">if</span> <span class="n">is_close_polygon</span><span class="p">:</span>
                <span class="n">coords_array</span> <span class="o">=</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords_array</span><span class="p">,</span> <span class="n">coords_array</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Missing 3D implementation.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">coords_array</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._is_admissible_simulation"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._is_admissible_simulation">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_is_admissible_simulation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges_coords_def</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check whether simulation of patch is physically admissible.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edges_coords_def : dict[list[numpy.ndarray(2d)]]</span>
<span class="sd">            For each dimension (key, str[int]), store the corresponding edges</span>
<span class="sd">            coordinates (item, list[numpy.ndarray(2d)]) (deformed</span>
<span class="sd">            configuration). Each edge coordinates are stored as a</span>
<span class="sd">            numpy.ndarray(n_edge_nodes, n_dim). Corner nodes are assumed part</span>
<span class="sd">            of the edge.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_admissible : bool</span>
<span class="sd">            If True, the patch simulation is physically admissible.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check patch simulation physical admissibility</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Build boundary nodes coordinates array (close polygon)</span>
            <span class="n">coords_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_boundary_coords_array</span><span class="p">(</span>
                <span class="n">edges_coords_def</span><span class="p">,</span> <span class="n">is_close_polygon</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Generate polygon</span>
            <span class="n">polygon</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">coords_array</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Check if polygon geometry is valid</span>
            <span class="n">is_geometry_valid</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">is_valid</span>
            <span class="c1"># Check if polygon is sorted counter-clockwise</span>
            <span class="n">is_counterclockwise</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">is_ccw</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Set whether simulation of patch is physically admissible</span>
            <span class="n">is_admissible</span> <span class="o">=</span> <span class="n">is_geometry_valid</span> <span class="ow">and</span> <span class="n">is_counterclockwise</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Unavailable checking procedure</span>
            <span class="n">is_admissible</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">is_admissible</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._get_orthogonal_dims"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._get_orthogonal_dims">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_get_orthogonal_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get orthogonal dimensions to given dimension.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : int</span>
<span class="sd">            Dimension.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        orthogonal_dims : tuple[int]</span>
<span class="sd">            Orthogonal dimensions to given dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orthogonal_dims</span> <span class="o">=</span> \
            <span class="nb">tuple</span><span class="p">({</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)}</span><span class="o">.</span><span class="n">difference</span><span class="p">({</span><span class="n">dim</span><span class="p">,}))</span>
        <span class="k">return</span> <span class="n">orthogonal_dims</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._rotation_tensor_deformed_edge"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._rotation_tensor_deformed_edge">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_rotation_tensor_deformed_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_dim</span><span class="p">,</span> <span class="n">edge_index</span><span class="p">,</span>
                                       <span class="n">corners_coords_def</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set rotation tensor to deformed boundary edge local coordinates.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge_dim : int</span>
<span class="sd">            Dimension along which edge is oriented in the reference</span>
<span class="sd">            configuration.</span>
<span class="sd">        edge_index : int</span>
<span class="sd">            Edge index with respect to edges oriented along the corresponding</span>
<span class="sd">            dimension.</span>
<span class="sd">        corners_coords_def : numpy.ndarray(2d)</span>
<span class="sd">            Patch corners coordinates in the deformed configuration</span>
<span class="sd">            (numpy.ndarray(n_corners, n_dim)).</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rotation : numpy.ndarray(2d)</span>
<span class="sd">            Rotation tensor (for given rotation angle theta, active</span>
<span class="sd">            transformation (- theta) and passive transformation (+ theta)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize rotation tensor</span>
        <span class="n">rotation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get edge corners</span>
        <span class="n">cid_init</span><span class="p">,</span> <span class="n">cid_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_per_dim</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">edge_dim</span><span class="p">)][</span><span class="n">edge_index</span><span class="p">]</span>
        <span class="c1"># Get edge initial end end corner node coordinates</span>
        <span class="n">init_node_def</span> <span class="o">=</span> <span class="n">corners_coords_def</span><span class="p">[</span><span class="n">cid_init</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">end_node_def</span> <span class="o">=</span> <span class="n">corners_coords_def</span><span class="p">[</span><span class="n">cid_end</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># Get edge reference diagonal corners</span>
        <span class="n">diagid_init</span><span class="p">,</span> <span class="n">diagid_end</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_edges_diag_per_dim</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">edge_dim</span><span class="p">)][</span><span class="n">edge_index</span><span class="p">]</span>
        <span class="n">dinit_node_def</span> <span class="o">=</span> <span class="n">corners_coords_def</span><span class="p">[</span><span class="n">diagid_init</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">dend_node_def</span> <span class="o">=</span> <span class="n">corners_coords_def</span><span class="p">[</span><span class="n">diagid_end</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute edge direction unit vector</span>
        <span class="n">edge_dir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">end_node_def</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">init_node_def</span><span class="p">)</span>
        <span class="n">edge_dir</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">edge_dir</span><span class="p">))</span><span class="o">*</span><span class="n">edge_dir</span>
        <span class="c1"># Compute edge reference diagonal direction unit vector</span>
        <span class="n">diag_dir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dend_node_def</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dinit_node_def</span><span class="p">)</span>
        <span class="n">diag_dir</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">diag_dir</span><span class="p">))</span><span class="o">*</span><span class="n">diag_dir</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Add out-of-plane spatial dimension</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">edge_dir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_dir</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">diag_dir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">diag_dir</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute out-of-plane direction unit vector</span>
        <span class="n">oop_dir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">diag_dir</span><span class="p">,</span> <span class="n">edge_dir</span><span class="p">)</span>
        <span class="n">oop_dir</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">oop_dir</span><span class="p">))</span><span class="o">*</span><span class="n">oop_dir</span>
        <span class="c1"># Compute edge deformation plane unit vector</span>
        <span class="n">orth_dir</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">edge_dir</span><span class="p">,</span> <span class="n">oop_dir</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Build rotation tensor</span>
        <span class="n">rotation</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">edge_dir</span>
        <span class="n">rotation</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">orth_dir</span>
        <span class="n">rotation</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">oop_dir</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Check rotation tensor</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">rotation</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">rotation</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;The rotation tensor is not orthogonal.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">rotation</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._transform_to_edge_local_coordinates"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._transform_to_edge_local_coordinates">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_transform_to_edge_local_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">init_node_def</span><span class="p">,</span> <span class="n">end_node_def</span><span class="p">,</span>
                                             <span class="n">nodes_coords_ref</span><span class="p">,</span>
                                             <span class="n">translation</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                             <span class="n">rotation</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transform from patch coordinates to deformed edge local coordinates.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        init_node_def : numpy.ndarray(2d)</span>
<span class="sd">            Boundary edge initial corner node coordinates (deformed</span>
<span class="sd">            configuration) stored as numpy.ndarray(n_dim).</span>
<span class="sd">        end_node_def : numpy.ndarray(2d)</span>
<span class="sd">            Boundary edge ending corner node coordinates (deformed</span>
<span class="sd">            configuration) stored as numpy.ndarray(n_dim).</span>
<span class="sd">        nodes_coords_ref : numpy.ndarray(2d)</span>
<span class="sd">            Boundary edge nodes coordinates (reference configuration) stored as</span>
<span class="sd">            numpy.ndarray(n_edge_nodes, n_dim).</span>
<span class="sd">        translation : numpy.ndarray(1d), default=None</span>
<span class="sd">            Translation from patch coordinates to deformed boundary edge local</span>
<span class="sd">            coordinates stored as numpy.ndarray(n_dim).</span>
<span class="sd">        rotation : numpy.ndarray(2d), default=None</span>
<span class="sd">            Rotation tensor from patch coordinates to deformed boundary edge</span>
<span class="sd">            local coordinates stored as numpy.ndarray(n_dim, n_dim).</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        local_init_node_def : numpy.ndarray(1d)</span>
<span class="sd">            Boundary edge initial corner node coordinates (deformed</span>
<span class="sd">            configuration) in deformed boundary edge local coordinates stored</span>
<span class="sd">            as numpy.ndarray(n_dim).</span>
<span class="sd">        local_end_node_def : numpy.ndarray(1d)</span>
<span class="sd">            Boundary edge ending corner node coordinates (deformed</span>
<span class="sd">            configuration) in deformed boundary edge local coordinates stored</span>
<span class="sd">            as numpy.ndarray(n_dim).</span>
<span class="sd">        local_nodes_coords_ref : numpy.ndarray(2d)</span>
<span class="sd">            Boundary edge nodes coordinates (reference configuration) in</span>
<span class="sd">            deformed boundary edge local coordinates stored as</span>
<span class="sd">            numpy.ndarray(n_edge_nodes, n_dim).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set default translation and rotation</span>
        <span class="k">if</span> <span class="n">translation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">translation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rotation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rotation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Transform boundary edge initial and ending nodes to deformed edge</span>
        <span class="c1"># local coordinates    </span>
        <span class="n">local_init_node_def</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">init_node_def</span><span class="p">)</span> <span class="o">-</span> <span class="n">translation</span>
        <span class="n">local_end_node_def</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">end_node_def</span><span class="p">)</span> <span class="o">-</span> <span class="n">translation</span>
        <span class="c1"># Transform boundary nodes coordinates to deformed edge local</span>
        <span class="c1"># coordinates </span>
        <span class="n">local_nodes_coords_ref</span> <span class="o">=</span> \
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_rotate_coords_array</span><span class="p">(</span><span class="n">nodes_coords_ref</span><span class="p">,</span> <span class="n">rotation</span><span class="p">)</span> \
            <span class="o">-</span><span class="mf">1.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">translation</span><span class="p">,</span> <span class="p">(</span><span class="n">nodes_coords_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">local_init_node_def</span><span class="p">,</span> <span class="n">local_end_node_def</span><span class="p">,</span> <span class="n">local_nodes_coords_ref</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._transform_from_edge_local_coordinates"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._transform_from_edge_local_coordinates">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_transform_from_edge_local_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">local_nodes_coords_def</span><span class="p">,</span>
                                               <span class="n">translation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                               <span class="n">rotation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transform from deformed edge local coordinates to patch coordinates.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        local_nodes_coords_def : numpy.ndarray(2d)</span>
<span class="sd">            Boundary edge nodes coordinates (deformed configuration) in</span>
<span class="sd">            deformed boundary edge local coordinates and stored as</span>
<span class="sd">            numpy.ndarray(n_edge_nodes, n_dim).</span>
<span class="sd">        translation : numpy.ndarray(1d), default=None</span>
<span class="sd">            Translation from deformed boundary edge local coordinates to patch</span>
<span class="sd">            coordinates stored as numpy.ndarray(n_dim).</span>
<span class="sd">        rotation : numpy.ndarray(2d), default=None</span>
<span class="sd">            Rotation tensor from deformed boundary edge local coordinates to</span>
<span class="sd">            patch coordinates stored as numpy.ndarray(n_dim, n_dim).</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nodes_coords_def : numpy.ndarray(2d)</span>
<span class="sd">            Boundary edge nodes coordinates (deformed configuration) stored as</span>
<span class="sd">            numpy.ndarray(n_edge_nodes, n_dim).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set default translation and rotation</span>
        <span class="k">if</span> <span class="n">translation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">translation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rotation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rotation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Transform boundary nodes deformed edge local coordinates to patch</span>
        <span class="c1"># coordinates</span>
        <span class="n">nodes_coords_def</span> <span class="o">=</span> \
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_rotate_coords_array</span><span class="p">(</span><span class="n">local_nodes_coords_def</span><span class="p">,</span> <span class="n">rotation</span><span class="p">)</span> \
            <span class="o">-</span><span class="mf">1.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">translation</span><span class="p">,</span> <span class="p">(</span><span class="n">local_nodes_coords_def</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">nodes_coords_def</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._rotate_coords_array"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._rotate_coords_array">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_rotate_coords_array</span><span class="p">(</span><span class="n">coords_array</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rotate coordinates array.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coords_array : numpy.ndarray(2d)</span>
<span class="sd">            Coordinates array (numpy.ndarray(n_points, n_dim)).</span>
<span class="sd">        r : numpy.ndarray (2d)</span>
<span class="sd">            Rotation tensor (for given rotation angle theta, active</span>
<span class="sd">            transformation (+ theta) and passive transformation (- theta)).</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rot_coords_array : numpy.ndarray(2d)</span>
<span class="sd">            Coordinates array (numpy.ndarray(n_points, n_dim)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get number of points</span>
        <span class="n">n_points</span> <span class="o">=</span> <span class="n">coords_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Get number of spatial dimensions</span>
        <span class="n">n_dim</span> <span class="o">=</span> <span class="n">coords_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Compute rotated coordinates array</span>
        <span class="n">rot_coords_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">coords_array</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_points</span><span class="p">):</span>
            <span class="n">rot_coords_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">r</span><span class="p">[:</span><span class="n">n_dim</span><span class="p">,</span> <span class="p">:</span><span class="n">n_dim</span><span class="p">],</span>
                                               <span class="n">coords_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">rot_coords_array</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._generate_finite_element_mesh"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._generate_finite_element_mesh">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_generate_finite_element_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem_type</span><span class="p">,</span> <span class="n">n_elems_per_dim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate patch finite element mesh (reference configuration).</span>
<span class="sd">        </span>
<span class="sd">        The finite element mesh is regular and uniform, assuming a spatial</span>
<span class="sd">        discretization in quadrilateral (2D) / hexahedral (3D) elements.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elem_type : str</span>
<span class="sd">            Finite element type.</span>
<span class="sd">        n_elems_per_dim : tuple[int]</span>
<span class="sd">            Number of finite elements per dimension. </span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mesh_nodes_matrix : numpy.ndarray(2d or 3d)</span>
<span class="sd">            Finite element mesh nodes matrix</span>
<span class="sd">            (numpy.ndarray[int](n_edge_nodes_per_dim) where each element</span>
<span class="sd">            corresponds to a given node position and whose value is set either</span>
<span class="sd">            as the global node label or zero (if the node does not exist).</span>
<span class="sd">            Nodes are labeled from 1 to n_nodes.</span>
<span class="sd">        mesh_nodes_coords : dict</span>
<span class="sd">            Coordinates (item, numpy.ndarray(n_dim)) of each finite element</span>
<span class="sd">            mesh node (key, str[int]). Nodes are labeled from 1 to n_nodes.   </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get finite element</span>
        <span class="n">elem</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="n">elem_type</span><span class="p">)</span>
        <span class="c1"># Get number of edge nodes per element</span>
        <span class="n">n_edge_nodes_elem</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">get_n_edge_nodes</span><span class="p">()</span>
        <span class="c1"># Get element nodes matrix</span>
        <span class="n">nodes_matrix</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">get_nodes_matrix</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute number of patch edge nodes along each dimension</span>
        <span class="n">n_edge_nodes_per_dim</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Loop over each dimension</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">):</span>
            <span class="c1"># Compute number of edge nodes</span>
            <span class="n">n_edge_nodes_per_dim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_elems_per_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">n_edge_nodes_elem</span>
                                        <span class="o">-</span> <span class="p">(</span><span class="n">n_elems_per_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># Compute node coordinates step along each dimension</span>
        <span class="n">coord_step_per_dim</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_patch_dims</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">n_elems_per_dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">n_edge_nodes_elem</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)])</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize mesh nodes matrix</span>
        <span class="n">mesh_nodes_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_edge_nodes_per_dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># Initialize mesh nodes coordinates</span>
        <span class="n">mesh_nodes_coords</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize node label</span>
        <span class="n">node_label</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># Build mesh nodes matrix and coordinates</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_edge_nodes_per_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_edge_nodes_per_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="c1"># Get element node local index</span>
                    <span class="n">elem_node_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_elem_node_index</span><span class="p">(</span>
                        <span class="n">elem_type</span><span class="p">,</span> <span class="n">n_elems_per_dim</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                    <span class="c1"># Set mesh node</span>
                    <span class="k">if</span> <span class="n">nodes_matrix</span><span class="p">[</span><span class="n">elem_node_index</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># Set mesh node label</span>
                        <span class="n">mesh_nodes_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_label</span>
                        <span class="c1"># Set mesh node coordinates</span>
                        <span class="n">mesh_nodes_coords</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">node_label</span><span class="p">)]</span> <span class="o">=</span> \
                            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="o">*</span><span class="n">coord_step_per_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                      <span class="n">j</span><span class="o">*</span><span class="n">coord_step_per_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                        <span class="c1"># Increment nodel label</span>
                        <span class="n">node_label</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_edge_nodes_per_dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_edge_nodes_per_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_edge_nodes_per_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="c1"># Get element node local index</span>
                        <span class="n">elem_node_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_elem_node_index</span><span class="p">(</span>
                            <span class="n">elem_type</span><span class="p">,</span> <span class="n">n_elems_per_dim</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
                        <span class="c1"># Set mesh node</span>
                        <span class="k">if</span> <span class="n">nodes_matrix</span><span class="p">[</span><span class="n">elem_node_index</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># Set mesh node label</span>
                            <span class="n">mesh_nodes_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_label</span>
                            <span class="c1"># Set mesh node coordinates</span>
                            <span class="n">mesh_nodes_coords</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">node_label</span><span class="p">)]</span> <span class="o">=</span> \
                                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="o">*</span><span class="n">coord_step_per_dim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                          <span class="n">j</span><span class="o">*</span><span class="n">coord_step_per_dim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                          <span class="n">k</span><span class="o">*</span><span class="n">coord_step_per_dim</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
                            <span class="c1"># Increment nodel label</span>
                            <span class="n">node_label</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">mesh_nodes_matrix</span><span class="p">,</span> <span class="n">mesh_nodes_coords</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._get_elem_node_index"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._get_elem_node_index">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_get_elem_node_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem_type</span><span class="p">,</span> <span class="n">n_elems_per_dim</span><span class="p">,</span> <span class="n">global_index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get element node local index from global mesh index.</span>
<span class="sd">        </span>
<span class="sd">        Shared nodes between adjacent elements are assumed to belong to the</span>
<span class="sd">        element from the lower coordinate side.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elem_type : str</span>
<span class="sd">            Finite element type.</span>
<span class="sd">        n_elems_per_dim : tuple[int]</span>
<span class="sd">            Number of finite elements per dimension.</span>
<span class="sd">        global_index : tuple[int]</span>
<span class="sd">            Global mesh node index.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        local_index : tuple[int]</span>
<span class="sd">            Finite element node index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get finite element</span>
        <span class="n">elem</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="n">elem_type</span><span class="p">)</span>
        <span class="c1"># Get number of edge nodes per element</span>
        <span class="n">n_edge_nodes_elem</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">get_n_edge_nodes</span><span class="p">()</span>
        <span class="c1"># Get number of patch edge nodes along each dimension</span>
        <span class="n">n_edge_nodes_per_dim</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_n_edge_nodes_per_dim</span><span class="p">(</span><span class="n">elem_type</span><span class="p">,</span> <span class="n">n_elems_per_dim</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get global mesh finite element index</span>
        <span class="n">elem_index</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span>
            <span class="p">(</span><span class="n">global_index</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">n_edge_nodes_per_dim</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="o">*</span><span class="n">n_elems_per_dim</span><span class="p">[</span><span class="n">k</span><span class="p">]))))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)])</span>
        <span class="c1"># Get finite element node local index</span>
        <span class="n">local_index</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">global_index</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">elem_index</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n_edge_nodes_elem</span> <span class="o">-</span> <span class="p">(</span><span class="n">elem_index</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)])</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">local_index</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._get_mesh_boundary_nodes_disps"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._get_mesh_boundary_nodes_disps">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_get_mesh_boundary_nodes_disps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges_coords_ref</span><span class="p">,</span>
                                       <span class="n">edges_coords_def</span><span class="p">,</span> <span class="n">mesh_nodes_matrix</span><span class="p">,</span>
                                       <span class="n">mesh_nodes_coords_ref</span><span class="p">,</span>
                                       <span class="n">is_interp_face_disps</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute finite element patch boundary displacements.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edges_coords_ref : dict[list[numpy.ndarray(2d)]]</span>
<span class="sd">            For each dimension (key, str[int]), store the corresponding edges</span>
<span class="sd">            coordinates in the reference configuration</span>
<span class="sd">            (item, list[numpy.ndarray(2d)]). Each edge coordinates are stored</span>
<span class="sd">            as a numpy.ndarray(n_edge_nodes, n_dim). Corner nodes are assumed</span>
<span class="sd">            part of the edge.</span>
<span class="sd">        edges_coords_def : dict[list[numpy.ndarray(2d)]]</span>
<span class="sd">            For each dimension (key, str[int]), store the corresponding edges</span>
<span class="sd">            coordinates in the deformed configuration</span>
<span class="sd">            (item, list[numpy.ndarray(2d)]). Each edge coordinates are stored</span>
<span class="sd">            as a numpy.ndarray(n_edge_nodes, n_dim). Corner nodes are assumed</span>
<span class="sd">            part of the edge.</span>
<span class="sd">        mesh_nodes_matrix : numpy.ndarray(2d or 3d)</span>
<span class="sd">            Finite element mesh nodes matrix</span>
<span class="sd">            (numpy.ndarray[int](n_edge_nodes_per_dim) where each element</span>
<span class="sd">            corresponds to a given node position and whose value is set either</span>
<span class="sd">            as the global node label or zero (if the node does not exist).</span>
<span class="sd">            Nodes are labeled from 1 to n_nodes.</span>
<span class="sd">        mesh_nodes_coords_ref : dict</span>
<span class="sd">            Coordinates (item, numpy.ndarray(n_dim)) of each finite element</span>
<span class="sd">            mesh node (key, str[int]) in the reference configuration. Nodes are</span>
<span class="sd">            labeled from 1 to n_nodes.</span>
<span class="sd">        is_interp_face_disps : bool, default=True</span>
<span class="sd">            If True, then faces nodes displacements are computed by</span>
<span class="sd">            interpolating the corresponding edges nodes displacements. If</span>
<span class="sd">            False, then faces nodes degrees of freedom are left free.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mesh_boundary_nodes_disps : dict</span>
<span class="sd">            Displacements (item, numpy.ndarray(n_dim)) prescribed on each</span>
<span class="sd">            finite element mesh boundary node (key, str[int]). Free degrees of</span>
<span class="sd">            freedom must be set as None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize finite element mesh boundary nodes displacements</span>
        <span class="n">mesh_boundary_nodes_disps</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Build boundary nodes displacements</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Loop over dimensions</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">):</span>
                <span class="c1"># Loop over edges</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edges_per_dim</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)])):</span>
                    <span class="c1"># Get edge nodes coordinates</span>
                    <span class="n">edge_nodes_coords_ref</span> <span class="o">=</span> <span class="n">edges_coords_ref</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)][</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">edge_nodes_coords_def</span> <span class="o">=</span> <span class="n">edges_coords_def</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)][</span><span class="n">j</span><span class="p">]</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Loop over edge nodes</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">edge_nodes_coords_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="c1"># Get node coordinates</span>
                        <span class="n">coord_ref</span> <span class="o">=</span> <span class="n">edge_nodes_coords_ref</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span>
                        <span class="n">coord_def</span> <span class="o">=</span> <span class="n">edge_nodes_coords_def</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span>
                        <span class="c1"># Compute node displacement</span>
                        <span class="n">disp</span> <span class="o">=</span> <span class="n">coord_def</span> <span class="o">-</span> <span class="n">coord_ref</span>
                        <span class="c1"># Get node label</span>
                        <span class="n">label</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_get_node_label_from_coords</span><span class="p">(</span>
                            <span class="n">mesh_nodes_coords_ref</span><span class="p">,</span> <span class="n">coord_ref</span><span class="p">)</span>
                        <span class="c1"># Store node displacement</span>
                        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mesh_boundary_nodes_disps</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="n">mesh_boundary_nodes_disps</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">disp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get matching edges indexes along each dimension</span>
            <span class="n">matching_edges_idxs_per_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_matching_edges_idxs</span><span class="p">()</span>
            <span class="c1"># Loop over dimensions</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">):</span>
                <span class="c1"># Loop over matching edges indexes</span>
                <span class="k">for</span> <span class="n">indexes</span> <span class="ow">in</span> <span class="n">matching_edges_idxs_per_dim</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]:</span>
                    <span class="c1"># Get edge nodes coordinates (reference configuration)</span>
                    <span class="n">edge_nodes_coords_ref</span> <span class="o">=</span> \
                        <span class="n">edges_coords_ref</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)][</span><span class="n">indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>                    
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Average edges nodes coordinates (deformed configuration)</span>
                    <span class="n">edge_nodes_coords_def</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">edges_coords_def</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)][</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">],</span>
                        <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="c1"># Broadcast average edges nodes coordinates</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
                        <span class="n">edges_coords_def</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_nodes_coords_def</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Loop over edge nodes</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">edge_nodes_coords_ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="c1"># Get node coordinates</span>
                        <span class="n">coord_ref</span> <span class="o">=</span> <span class="n">edge_nodes_coords_ref</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span>
                        <span class="n">coord_def</span> <span class="o">=</span> <span class="n">edge_nodes_coords_def</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span>
                        <span class="c1"># Compute node displacement</span>
                        <span class="n">disp</span> <span class="o">=</span> <span class="n">coord_def</span> <span class="o">-</span> <span class="n">coord_ref</span>
                        <span class="c1"># Get node label</span>
                        <span class="n">label</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_get_node_label_from_coords</span><span class="p">(</span>
                            <span class="n">mesh_nodes_coords_ref</span><span class="p">,</span> <span class="n">coord_ref</span><span class="p">)</span>
                        <span class="c1"># Store node displacement</span>
                        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mesh_boundary_nodes_disps</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="n">mesh_boundary_nodes_disps</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">disp</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Enforce faces nodes displacements</span>
            <span class="k">if</span> <span class="n">is_interp_face_disps</span><span class="p">:</span>
                <span class="c1"># Set faces nodes</span>
                <span class="n">faces_nodes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="n">mesh_nodes_matrix</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span>
                               <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="n">mesh_nodes_matrix</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                               <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="n">mesh_nodes_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>
                               <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="n">mesh_nodes_matrix</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>
                               <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="n">mesh_nodes_matrix</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:],</span>
                               <span class="s1">&#39;6&#39;</span><span class="p">:</span> <span class="n">mesh_nodes_matrix</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]}</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Loop over faces</span>
                <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">face_nodes</span> <span class="ow">in</span> <span class="n">faces_nodes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="c1"># Get number of nodes along each dimension</span>
                    <span class="n">n_node_1</span><span class="p">,</span> <span class="n">n_node_2</span> <span class="o">=</span> <span class="n">face_nodes</span><span class="o">.</span><span class="n">shape</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Loop over face nodes</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_node_2</span><span class="p">):</span>
                        <span class="c1"># Loop over face nodes</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_node_1</span><span class="p">):</span>
                            <span class="c1"># Get face node label</span>
                            <span class="n">label</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">face_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                            <span class="c1"># Skip if node does not exist</span>
                            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="k">continue</span>
                            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                            <span class="c1"># Interpolate displacement along first dimension</span>
                            <span class="n">disp_1</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">i</span><span class="o">/</span><span class="n">n_node_1</span><span class="p">)</span><span class="o">*</span><span class="n">mesh_boundary_nodes_disps</span><span class="p">[</span>
                                    <span class="nb">str</span><span class="p">(</span><span class="n">face_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">])]</span>
                                <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="n">n_node_1</span><span class="p">)</span><span class="o">*</span><span class="n">mesh_boundary_nodes_disps</span><span class="p">[</span>
                                    <span class="nb">str</span><span class="p">(</span><span class="n">face_nodes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">])])</span>
                            <span class="c1"># Interpolate displacement along second dimension</span>
                            <span class="n">disp_2</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">j</span><span class="o">/</span><span class="n">n_node_2</span><span class="p">)</span><span class="o">*</span><span class="n">mesh_boundary_nodes_disps</span><span class="p">[</span>
                                    <span class="nb">str</span><span class="p">(</span><span class="n">face_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])]</span>
                                <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="o">/</span><span class="n">n_node_2</span><span class="p">)</span><span class="o">*</span><span class="n">mesh_boundary_nodes_disps</span><span class="p">[</span>
                                    <span class="nb">str</span><span class="p">(</span><span class="n">face_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])])</span>
                            <span class="c1"># Compute node displacement</span>
                            <span class="n">disp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">disp_1</span><span class="p">,</span> <span class="n">disp_2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                            <span class="c1"># Store node displacement</span>
                            <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span>
                                    <span class="n">mesh_boundary_nodes_disps</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                                <span class="n">mesh_boundary_nodes_disps</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">disp</span>          
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       </span>
        <span class="k">return</span> <span class="n">mesh_boundary_nodes_disps</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FiniteElementPatchGenerator._get_node_label_from_coords"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator.html#hookeai.data_generation.spdg.patch_generator.FiniteElementPatchGenerator._get_node_label_from_coords">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_node_label_from_coords</span><span class="p">(</span><span class="n">mesh_nodes_coords_ref</span><span class="p">,</span> <span class="n">node_coords</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get finite element mesh node label from coordinates.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mesh_nodes_coords_ref : dict</span>
<span class="sd">            Coordinates (item, numpy.ndarray(n_dim)) of each finite element</span>
<span class="sd">            mesh node (key, str[int]) in the reference configuration. Nodes are</span>
<span class="sd">            labeled from 1 to n_nodes.</span>
<span class="sd">        node_coords : numpy.ndarray(1d)</span>
<span class="sd">            Target node coordinates (numpy.ndarray(n_dim)). </span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nodel_label : str[int]</span>
<span class="sd">            Target node label.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize node label</span>
        <span class="n">node_label</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Loop over mesh nodes</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">coords</span> <span class="ow">in</span> <span class="n">mesh_nodes_coords_ref</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Check for coordinates match</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">node_coords</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
                <span class="n">node_label</span> <span class="o">=</span> <span class="n">label</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ </span>
        <span class="k">if</span> <span class="n">node_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Node label has not been found.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~        </span>
        <span class="k">return</span> <span class="n">node_label</span>    </div></div>
<span class="c1"># =============================================================================</span>
<div class="viewcode-block" id="rotation_tensor_from_euler_angles"><a class="viewcode-back" href="../../../../_autosummary/hookeai.data_generation.spdg.patch_generator.rotation_tensor_from_euler_angles.html#hookeai.data_generation.spdg.patch_generator.rotation_tensor_from_euler_angles">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">rotation_tensor_from_euler_angles</span><span class="p">(</span><span class="n">euler_deg</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set rotation tensor from Euler angles (Bunge convention).</span>

<span class="sd">    The rotation tensor is defined as</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\mathbf{R} =</span>
<span class="sd">           \\begin{bmatrix}</span>
<span class="sd">               c_1 c_3 - c_2 s_1 s_3 &amp; -c_1 s_3 - c_2 c_3 s_1 &amp; s_1 s_2 \\\\</span>
<span class="sd">               c_3 s_1 + c_1 c_2 s_3 &amp; c_1 c_2 c_3 - s_1 s_3 &amp; - c_1 s_2 \\\\</span>
<span class="sd">               s_2 s_3 &amp; c_3 s_2 &amp; c_2</span>
<span class="sd">           \\end{bmatrix}</span>

<span class="sd">    where</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\begin{align}</span>
<span class="sd">           c_1 = \\cos(\\alpha) \\qquad s_1 = \\sin(\\alpha) \\\\</span>
<span class="sd">           c_2 = \\cos(\\beta) \\qquad s_2 = \\sin(\\beta) \\\\</span>
<span class="sd">           c_3 = \\cos(\\gamma) \\qquad s_3 = \\sin(\\gamma)</span>
<span class="sd">        \\end{align}</span>

<span class="sd">    and :math:`(\\alpha, \\beta, \\gamma)` are the Euler angles corresponding</span>
<span class="sd">    to the Bunge convention (Z1-X2-Z3).</span>

<span class="sd">    ----</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    euler_deg : tuple</span>
<span class="sd">        Euler angles (degrees) sorted according to Bunge convention (Z1-X2-Z3).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    r : numpy.ndarray(2d)</span>
<span class="sd">        Rotation tensor (for given rotation angle theta, active transformation</span>
<span class="sd">        (+ theta) and passive transformation (- theta)).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert euler angles to radians</span>
    <span class="n">euler_rad</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">euler_deg</span><span class="p">)</span>
    <span class="c1"># Compute convenient sins and cosines</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">euler_rad</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">euler_rad</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">s3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">euler_rad</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">euler_rad</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">euler_rad</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">c3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">euler_rad</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
    <span class="c1"># Initialize rotation tensor</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="c1"># Build rotation tensor</span>
    <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span><span class="o">*</span><span class="n">c3</span> <span class="o">-</span> <span class="n">c2</span><span class="o">*</span><span class="n">s1</span><span class="o">*</span><span class="n">s3</span>
    <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">c3</span><span class="o">*</span><span class="n">s1</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">c2</span><span class="o">*</span><span class="n">s3</span>
    <span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s2</span><span class="o">*</span><span class="n">s3</span>
    <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">c1</span><span class="o">*</span><span class="n">s3</span> <span class="o">-</span> <span class="n">c2</span><span class="o">*</span><span class="n">c3</span><span class="o">*</span><span class="n">s1</span>
    <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span><span class="o">*</span><span class="n">c2</span><span class="o">*</span><span class="n">c3</span> <span class="o">-</span> <span class="n">s1</span><span class="o">*</span><span class="n">s3</span>
    <span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">c3</span><span class="o">*</span><span class="n">s2</span>
    <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">s1</span><span class="o">*</span><span class="n">s2</span>
    <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">c1</span><span class="o">*</span><span class="n">s2</span>
    <span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">c2</span>
    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
    <span class="c1"># Return</span>
    <span class="k">return</span> <span class="n">r</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Bernardo Ferreira.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>