<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>material_model_finder.model.material_discovery &mdash; hookeai 1.0.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/readthedocs-custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            hookeai
          </a>
              <div class="version">
                1.0.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../rst_doc_files/getting_started/overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst_doc_files/getting_started/installation.html">Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Features</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../rst_doc_files/features/overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst_doc_files/features/data_generation.html">Data generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst_doc_files/features/material_models.html">Material model architectures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst_doc_files/features/local_model_updating.html">Local material model updating</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst_doc_files/features/global_model_updating.html">Global material model updating</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst_doc_files/features/data_analysis.html">Data analysis and visualization tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst_doc_files/features/tensor_matrix.html">Tensorial algebra and matrix operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst_doc_files/features/other.html">Other utilities</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/hookeai.html">Code</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">License</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">MIT License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">hookeai</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">material_model_finder.model.material_discovery</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for material_model_finder.model.material_discovery</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Material model finder forward model.</span>

<span class="sd">Classes</span>
<span class="sd">-------</span>
<span class="sd">MaterialModelFinder(torch.nn.Module)</span>
<span class="sd">    Material model finder forward model.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#                                                                       Modules</span>
<span class="c1"># =============================================================================</span>
<span class="c1"># Standard</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="c1"># Third-party</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="c1"># Local</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">model_architectures.hybrid_base_model.model.hybrid_model</span><span class="w"> </span><span class="kn">import</span> \
    <span class="n">HybridModel</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">simulators.fetorch.element.integrations.internal_forces</span><span class="w"> </span><span class="kn">import</span> \
    <span class="n">compute_element_internal_forces</span><span class="p">,</span> <span class="n">compute_infinitesimal_inc_strain</span><span class="p">,</span> \
    <span class="n">compute_infinitesimal_strain</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">simulators.fetorch.element.derivatives.gradients</span><span class="w"> </span><span class="kn">import</span> \
    <span class="n">eval_shapefun_deriv</span><span class="p">,</span> <span class="n">vbuild_discrete_sym_gradient</span><span class="p">,</span> \
    <span class="n">vbuild_discrete_gradient</span><span class="p">,</span> <span class="n">vexpand_grad_operator_sym_2d_to_3d</span><span class="p">,</span> \
    <span class="n">vreduce_grad_operator_sym_3d_to_2d</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">simulators.fetorch.material.material_su</span><span class="w"> </span><span class="kn">import</span> <span class="n">material_state_update</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">simulators.fetorch.math.matrixops</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_problem_type_parameters</span><span class="p">,</span> \
    <span class="n">vget_tensor_mf</span><span class="p">,</span> <span class="n">vget_tensor_from_mf</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">simulators.fetorch.math.voigt_notation</span><span class="w"> </span><span class="kn">import</span> <span class="n">vget_stress_vmf</span><span class="p">,</span> \
    <span class="n">vget_strain_from_vmf</span><span class="p">,</span> <span class="n">get_projection_tensors_vmf</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">utilities.data_scalers</span><span class="w"> </span><span class="kn">import</span> <span class="n">TorchMinMaxScaler</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">model_architectures.procedures.model_data_scaling</span><span class="w"> </span><span class="kn">import</span> \
    <span class="n">set_fitted_data_scalers</span><span class="p">,</span> <span class="n">data_scaler_transform</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">time_series_data.time_dataset</span><span class="w"> </span><span class="kn">import</span> <span class="n">TimeSeriesDatasetInMemory</span><span class="p">,</span> \
    <span class="n">save_dataset</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ioput.iostandard</span><span class="w"> </span><span class="kn">import</span> <span class="n">make_directory</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ioput.plots</span><span class="w"> </span><span class="kn">import</span> <span class="n">plot_xy_data</span><span class="p">,</span> <span class="n">save_figure</span>
<span class="c1">#</span>
<span class="c1">#                                                          Authorship &amp; Credits</span>
<span class="c1"># =============================================================================</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Bernardo Ferreira (bernardo_ferreira@brown.edu)&#39;</span>
<span class="n">__credits__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Bernardo Ferreira&#39;</span><span class="p">,</span> <span class="p">]</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s1">&#39;Stable&#39;</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<div class="viewcode-block" id="MaterialModelFinder"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">MaterialModelFinder</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Material model finder forward model.</span>
<span class="sd">    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    _specimen_data : SpecimenNumericalData</span>
<span class="sd">        Specimen numerical data translated from experimental results.</span>
<span class="sd">    _specimen_material_state : StructureMaterialState</span>
<span class="sd">        FETorch specimen material state.</span>
<span class="sd">    _force_equilibrium_loss_type : str</span>
<span class="sd">        Type of force equilibrium loss:</span>
<span class="sd">        </span>
<span class="sd">        &#39;pointwise&#39;      : Force equilibrium strictly based on pointwise</span>
<span class="sd">                           internal, external and reaction forces.</span>

<span class="sd">        &#39;dirichlet_sets&#39; : Force equilibrium (1) based on pointwise</span>
<span class="sd">                           internal and external forces (non-Dirichlet</span>
<span class="sd">                           degrees of freedom) and (2) based on pointwise</span>
<span class="sd">                           internal, external and set-based reaction forces</span>
<span class="sd">                           (Dirichlet constrained degrees of freedom).</span>
<span class="sd">    _is_force_normalization : bool, default=False</span>
<span class="sd">        If True, then normalize forces prior to the computation of the force</span>
<span class="sd">        equilibrium loss.</span>
<span class="sd">    _data_scalers : dict</span>
<span class="sd">        Data scaler (item, TorchStandardScaler) for each feature data</span>
<span class="sd">        (key, str).</span>
<span class="sd">    _loss_scaling_factor : torch.Tensor(0d)</span>
<span class="sd">        Loss scaling factor. If provided, then loss is pre-multiplied by</span>
<span class="sd">        loss scaling factor.</span>
<span class="sd">    _loss_time_weights : torch.Tensor(1d), default=None</span>
<span class="sd">        Loss time weights stored as torch.Tensor(1d) of shape (n_time).</span>
<span class="sd">        If provided, then each discrete time loss contribution is</span>
<span class="sd">        pre-multiplied by corresponding weight. If None, time weights are</span>
<span class="sd">        set to 1.0.</span>
<span class="sd">    _is_store_force_equilibrium_loss_hist : bool</span>
<span class="sd">        If True, then store force equilibrium loss components history.</span>
<span class="sd">    _is_store_local_paths : bool</span>
<span class="sd">        If True, then store data set of specimen local (Gauss integration</span>
<span class="sd">        points) strain-stress paths in dedicated model subdirectory.</span>
<span class="sd">        Overwrites existing data set.</span>
<span class="sd">    _local_paths_elements : list[int]</span>
<span class="sd">        Elements for which local (Gauss integration points) strain-stress</span>
<span class="sd">        paths are stored as part of the specimen local data set. Elements</span>
<span class="sd">        are labeled from 1 to n_elem. If None, then all elements are</span>
<span class="sd">        stored. Only effective if is_store_local_paths=True.</span>
<span class="sd">    _is_compute_sets_reaction_hist : bool</span>
<span class="sd">        If True, then compute reaction forces history of Dirichlet boundary</span>
<span class="sd">        sets. Only available for &#39;dirichlet_sets&#39; force equilibrium loss type.</span>
<span class="sd">    model_directory : str</span>
<span class="sd">        Directory where model is stored.</span>
<span class="sd">    model_name : str</span>
<span class="sd">        Name of model.</span>
<span class="sd">    _material_models_dir : str</span>
<span class="sd">        Model subdirectory where material models are stored.</span>
<span class="sd">    _internal_data_normalization_dir : str</span>
<span class="sd">        Model subdirectory where the internal data normalization parameters</span>
<span class="sd">        are stored.</span>
<span class="sd">    _temp_dir : str</span>
<span class="sd">        Model subdirectory where temporary data is stored.</span>
<span class="sd">    _device_type : {&#39;cpu&#39;, &#39;cuda&#39;}, default=&#39;cpu&#39;</span>
<span class="sd">        Type of device on which torch.Tensor is allocated.</span>
<span class="sd">    _device : torch.device</span>
<span class="sd">        Device on which torch.Tensor is allocated.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    _set_model_subdirs(self)</span>
<span class="sd">        Set model subdirectories.</span>
<span class="sd">    _set_material_models_dirs(self)</span>
<span class="sd">        Set material models directories.</span>
<span class="sd">    check_force_equilibrium_loss_type(cls, force_equilibrium_loss_type)</span>
<span class="sd">        Check if force equilibrium loss type is available.</span>
<span class="sd">    set_specimen_data(self, specimen_data, specimen_material_state,</span>
<span class="sd">                      force_minimum=None, force_maximum=None)</span>
<span class="sd">        Set specimen data and material state.</span>
<span class="sd">    get_detached_model_parameters(self)</span>
<span class="sd">        Get model parameters (material models) detached of gradients.</span>
<span class="sd">    get_model_parameters_bounds(self)</span>
<span class="sd">        Get model parameters (material models) bounds.</span>
<span class="sd">    enforce_parameters_bounds(self)</span>
<span class="sd">        Enforce bounds in model parameters (material models).</span>
<span class="sd">    enforce_parameters_constraints(self)</span>
<span class="sd">        Enforce material model-dependent parameters constraints.</span>
<span class="sd">    set_device(self, device_type)</span>
<span class="sd">        Set device on which torch.Tensor is allocated.</span>
<span class="sd">    get_device(self)</span>
<span class="sd">        Get device on which torch.Tensor is allocated.</span>
<span class="sd">    forward(self, sequential_mode=&#39;sequential_element&#39;)</span>
<span class="sd">        Forward propagation.</span>
<span class="sd">    forward_sequential_time(self)</span>
<span class="sd">        Forward propagation (sequential time).</span>
<span class="sd">    forward_sequential_element(self, is_store_local_paths=False)</span>
<span class="sd">        Forward propagation (sequential element).</span>
<span class="sd">    compute_element_internal_forces_hist(self, strain_formulation, \</span>
<span class="sd">                                         problem_type, element_type, \</span>
<span class="sd">                                         element_material, element_state_old, \</span>
<span class="sd">                                         nodes_coords_hist, nodes_disps_hist, \</span>
<span class="sd">                                         nodes_inc_disps_hist, time_hist, \</span>
<span class="sd">                                         is_recurrent_model)</span>
<span class="sd">        Compute history of finite element internal forces.</span>
<span class="sd">    recurrent_material_state_update(self, strain_formulation, problem_type, \</span>
<span class="sd">                                    constitutive_model, strain_hist, time_hist)</span>
<span class="sd">        Material state update for any given recurrent constitutive model.</span>
<span class="sd">    force_equilibrium_loss(self, internal_forces_mesh, external_forces_mesh, \</span>
<span class="sd">                           reaction_forces_mesh, dirichlet_bool_mesh)</span>
<span class="sd">        Compute force equilibrium loss for given discrete time.</span>
<span class="sd">    build_element_local_samples(self, strain_formulation, problem_type, \</span>
<span class="sd">                                element_type, time_hist, element_state_hist)</span>
<span class="sd">        Build element Gauss integration points local strain-stress paths.</span>
<span class="sd">    compute_dirichlet_sets_reaction_hist(self, dirichlet_bc_mesh_hist, \</span>
<span class="sd">                                          dirichlet_bool_mesh_hist)</span>
<span class="sd">        Compute Dirichlet boundary sets reaction forces history.</span>
<span class="sd">    compute_dirichlet_sets_reaction(self, internal_forces_mesh, \</span>
<span class="sd">                                    external_forces_mesh, dirichlet_bc_mesh)</span>
<span class="sd">        Compute reaction forces of Dirichlet boundary sets.</span>
<span class="sd">    store_dirichlet_sets_reaction_hist(self, dirichlet_sets_reaction_hist, \</span>
<span class="sd">                                       is_plot=True)</span>
<span class="sd">        Store reaction forces history of Dirichlet boundary sets.</span>
<span class="sd">    build_tensor_from_comps(cls, n_dim, comps, comps_array, \</span>
<span class="sd">                            is_symmetric=False, device=None)</span>
<span class="sd">        Build strain/stress tensor from given components.</span>
<span class="sd">    store_tensor_comps(cls, comps, tensor, device=None)</span>
<span class="sd">        Store strain/stress tensor components in array.</span>
<span class="sd">    vforward_sequential_element(self)</span>
<span class="sd">        Forward propagation (sequential element).</span>
<span class="sd">    vcompute_elements_internal_forces_hist(self, strain_formulation, \</span>
<span class="sd">                                           problem_type, element_type, \</span>
<span class="sd">                                           element_material, \</span>
<span class="sd">                                           elements_coords_hist, \</span>
<span class="sd">                                           elements_disps_hist, time_hist)</span>
<span class="sd">        Compute history of finite elements internal forces.</span>
<span class="sd">    vcompute_element_internal_forces_hist(self, nodes_coords_hist, \</span>
<span class="sd">                                          nodes_disps_hist, \</span>
<span class="sd">                                          strain_formulation, \</span>
<span class="sd">                                          problem_type, element_type, \</span>
<span class="sd">                                          element_material, time_hist)</span>
<span class="sd">        Compute history of finite element internal forces.</span>
<span class="sd">    vcompute_element_vol_grad_hist(self, nodes_coords_hist, nodes_disps_hist, \</span>
<span class="sd">                                   strain_formulation, problem_type, \</span>
<span class="sd">                                   element_type, time_hist)</span>
<span class="sd">        Compute history of finite element volumetric gradient operator.</span>
<span class="sd">    vcompute_local_vol_grad_operator_hist(self, local_coords, weight, \</span>
<span class="sd">                                          strain_formulation, problem_type, \</span>
<span class="sd">                                          element_type, nodes_coords_hist, \</span>
<span class="sd">                                          nodes_disps_hist, time_hist)</span>
<span class="sd">        Compute local integration point gradient contribution history.</span>
<span class="sd">    vcompute_local_gradient(self, nodes_coords, local_coords, comp_order, \</span>
<span class="sd">                            element_type, is_symmetric=True)</span>
<span class="sd">        Compute discrete gradient operator at given local point of element.</span>
<span class="sd">    vcompute_local_vol_sym_gradient(self, grad_operator_sym, n_dim)</span>
<span class="sd">        Compute discrete volumetric symmetric gradient operator.</span>
<span class="sd">    vcompute_local_internal_forces_hist(self, local_coords, weight, \</span>
<span class="sd">                                        strain_formulation, problem_type, \</span>
<span class="sd">                                        element_type, nodes_coords_hist, \</span>
<span class="sd">                                        nodes_disps_hist, time_hist, \</span>
<span class="sd">                                        element_material, \</span>
<span class="sd">                                        is_volumetric_bar=False, \</span>
<span class="sd">                                        avg_vol_grad_operator_hist=None)</span>
<span class="sd">        Compute local integration point internal force contribution history.</span>
<span class="sd">    vcompute_local_strain(self, nodes_coords, nodes_disps, local_coords, \</span>
<span class="sd">                          strain_formulation, n_dim, comp_order, element_type)</span>
<span class="sd">        Compute strain tensor at given local point of element.</span>
<span class="sd">    vcompute_local_strain_vbar(self, nodes_coords, nodes_disps, \</span>
<span class="sd">                               avg_vol_grad_operator, local_coords, \</span>
<span class="sd">                               strain_formulation, n_dim, comp_order, \</span>
<span class="sd">                               element_type)</span>
<span class="sd">        Compute strain tensor at given local point of element.</span>
<span class="sd">    vcompute_local_dev_sym_gradient(self, grad_operator_sym, n_dim)</span>
<span class="sd">        Compute discrete deviatoric symmetric gradient operator.</span>
<span class="sd">    vrecurrent_material_state_update(self, strain_formulation, problem_type, \</span>
<span class="sd">                                     constitutive_model, strain_hist, \</span>
<span class="sd">                                     time_hist)</span>
<span class="sd">        Material state update for recurrent constitutive model.</span>
<span class="sd">    vcompute_local_internal_forces(self, stress_vmf, grad_operator_sym, \</span>
<span class="sd">                                   jacobian_det, weight)</span>
<span class="sd">        Compute local integration point internal forces contribution.</span>
<span class="sd">    vbuild_internal_forces_mesh_hist(self, elements_internal_forces_hist, \</span>
<span class="sd">                                     elements_mesh_indexes, n_node_mesh, n_dim)</span>
<span class="sd">        Build internal forces history of finite element mesh.</span>
<span class="sd">    vassemble_internal_forces(self, elements_internal_forces, \</span>
<span class="sd">                              elements_mesh_indexes, n_node_mesh, n_dim)</span>
<span class="sd">        Assemble element internal forces into mesh counterpart.</span>
<span class="sd">    vforce_equilibrium_hist_loss(self, internal_forces_mesh_hist, \</span>
<span class="sd">                                 external_forces_mesh_hist, \</span>
<span class="sd">                                 reaction_forces_mesh_hist, \</span>
<span class="sd">                                 dirichlet_bc_mesh_hist)</span>
<span class="sd">        Compute force equilibrium history loss.</span>
<span class="sd">    vforce_equilibrium_loss(self, internal_forces_mesh, external_forces_mesh, \</span>
<span class="sd">                            reaction_forces_mesh, dirichlet_bc_mesh)</span>
<span class="sd">        Compute force equilibrium loss.</span>
<span class="sd">    force_equilibrium_loss_components_hist(self, internal_forces_mesh_hist, \</span>
<span class="sd">                                           external_forces_mesh_hist, \</span>
<span class="sd">                                           reaction_forces_mesh_hist, \</span>
<span class="sd">                                           dirichlet_bc_mesh_hist)</span>
<span class="sd">        Compute force equilibrium loss components history (output purposes).</span>
<span class="sd">    store_force_equilibrium_loss_components_hist( \</span>
<span class="sd">        self, force_equilibrium_loss_components_hist, is_plot=True)</span>
<span class="sd">        Store force equilibrium loss components history.</span>
<span class="sd">    build_elements_local_samples(self, strain_formulation, problem_type, \</span>
<span class="sd">                                 time_hist, elements_state_hist)</span>
<span class="sd">        Build elements local strain-stress paths.</span>
<span class="sd">    compute_dirichlet_sets_reaction_hist(self, internal_forces_mesh_hist, \</span>
<span class="sd">                                         external_forces_mesh_hist, \</span>
<span class="sd">                                         dirichlet_bc_mesh_hist)</span>
<span class="sd">        Compute reaction forces history of Dirichlet boundary sets.</span>
<span class="sd">    compute_dirichlet_sets_reaction(self, internal_forces_mesh, \</span>
<span class="sd">                                    external_forces_mesh, \</span>
<span class="sd">                                    dirichlet_bc_mesh)</span>
<span class="sd">        Compute reaction forces of Dirichlet boundary sets.</span>
<span class="sd">    store_dirichlet_sets_reaction_hist(self, dirichlet_sets_reaction_hist, \</span>
<span class="sd">                                       is_export_csv=True, is_plot=True)</span>
<span class="sd">        Store reaction forces history of Dirichlet boundary sets.</span>
<span class="sd">    vbuild_tensor_from_comps(cls, n_dim, comps, comps_array, device=None)</span>
<span class="sd">        Build strain/stress tensor from given components.</span>
<span class="sd">    vstore_tensor_comps(cls, comps, tensor, device=None)</span>
<span class="sd">        Store strain/stress tensor components in array.</span>
<span class="sd">    features_out_extractor(cls, model_output)</span>
<span class="sd">        Extract output features from generic model output.</span>
<span class="sd">    _init_data_scalers(self)</span>
<span class="sd">        Initialize model data scalers.</span>
<span class="sd">    set_fitted_force_data_scalers(self, force_minimum, force_maximum)</span>
<span class="sd">        Set fitted forces data scalers.</span>
<span class="sd">    set_material_models_fitted_data_scalers(self, models_scaling_type, \</span>
<span class="sd">                                            models_scaling_parameters)</span>
<span class="sd">    check_model_in_normalized(cls, model)</span>
<span class="sd">        Check if generic model expects normalized input features.</span>
<span class="sd">    check_model_out_normalized(cls, model)</span>
<span class="sd">        Check if generic model expects normalized output features.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="MaterialModelFinder.__init__"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.__init__">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_directory</span><span class="p">,</span> <span class="n">model_name</span><span class="o">=</span><span class="s1">&#39;material_model_finder&#39;</span><span class="p">,</span>
                 <span class="n">force_equilibrium_loss_type</span><span class="o">=</span><span class="s1">&#39;pointwise&#39;</span><span class="p">,</span>
                 <span class="n">is_force_normalization</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">is_store_force_equilibrium_loss_hist</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">is_store_local_paths</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">local_paths_elements</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">is_compute_sets_reaction_hist</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">is_detect_autograd_anomaly</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">device_type</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructor.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model_directory : str</span>
<span class="sd">            Directory where model is stored.</span>
<span class="sd">        model_name : str, default=&#39;material_model_finder&#39;</span>
<span class="sd">            Name of model.</span>
<span class="sd">        force_equilibrium_loss_type : str, default=&#39;pointwise&#39;</span>
<span class="sd">            Type of force equilibrium loss:</span>
<span class="sd">            </span>
<span class="sd">            &#39;pointwise&#39;      : Force equilibrium strictly based on pointwise</span>
<span class="sd">                               internal, external and reaction forces.</span>

<span class="sd">            &#39;dirichlet_sets&#39; : Force equilibrium (1) based on pointwise</span>
<span class="sd">                               internal and external forces (non-Dirichlet</span>
<span class="sd">                               degrees of freedom) and (2) based on pointwise</span>
<span class="sd">                               internal, external and set-based reaction forces</span>
<span class="sd">                               (Dirichlet constrained degrees of freedom).</span>
<span class="sd">            </span>
<span class="sd">        is_force_normalization : bool, default=False</span>
<span class="sd">            If True, then normalize forces prior to the computation of the</span>
<span class="sd">            force equilibrium loss.</span>
<span class="sd">        is_store_force_equilibrium_loss_hist : bool, default=False</span>
<span class="sd">            If True, then store force equilibrium loss components history.</span>
<span class="sd">        is_store_local_paths : bool, default=False</span>
<span class="sd">            If True, then store data set of specimen local (Gauss integration</span>
<span class="sd">            points) strain-stress paths in dedicated model subdirectory.</span>
<span class="sd">            Overwrites existing data set.</span>
<span class="sd">        local_paths_elements : list[int], default=None</span>
<span class="sd">            Elements for which local (Gauss integration points) strain-stress</span>
<span class="sd">            paths are stored as part of the specimen local data set. Elements</span>
<span class="sd">            are labeled from 1 to n_elem. If None, then all elements are</span>
<span class="sd">            stored. Only effective if is_store_local_paths=True.</span>
<span class="sd">        is_compute_sets_reaction_hist : bool, default=False</span>
<span class="sd">            If True, then compute reaction forces history of Dirichlet</span>
<span class="sd">            boundary sets. Only available for &#39;dirichlet_sets&#39; force</span>
<span class="sd">            equilibrium loss type.</span>
<span class="sd">        is_detect_autograd_anomaly : bool, default=False</span>
<span class="sd">            If True, then set context-manager that enables anomaly detection</span>
<span class="sd">            for the autograd engine. Should only be enabled for debugging</span>
<span class="sd">            purposes as it degrades performance.</span>
<span class="sd">        device_type : {&#39;cpu&#39;, &#39;cuda&#39;}, default=&#39;cpu&#39;</span>
<span class="sd">            Type of device on which torch.Tensor is allocated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize from base class</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MaterialModelFinder</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set autograd engine anomaly detection</span>
        <span class="k">if</span> <span class="n">is_detect_autograd_anomaly</span><span class="p">:</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">set_detect_anomaly</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set model directory and name</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">model_directory</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_directory</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">model_directory</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;The model directory has not been found.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;The model name must be a string.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span> <span class="o">=</span> <span class="n">model_name</span>
        <span class="c1"># Set model subdirectories</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_model_subdirs</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set force equilibrium loss type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_force_equilibrium_loss_type</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">check_force_equilibrium_loss_type</span><span class="p">(</span><span class="n">force_equilibrium_loss_type</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set storage of force equilibrium loss components history</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_store_force_equilibrium_loss_hist</span> <span class="o">=</span> \
            <span class="n">is_store_force_equilibrium_loss_hist</span>
        <span class="c1"># Set storage of specimen local strain-stress paths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_store_local_paths</span> <span class="o">=</span> <span class="n">is_store_local_paths</span>
        <span class="c1"># Set elements of specimen local strain-stress data set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_local_paths_elements</span> <span class="o">=</span> <span class="n">local_paths_elements</span>
        <span class="c1"># Set computation of Dirichlet boundary sets reaction forces</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_compute_sets_reaction_hist</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_equilibrium_loss_type</span> <span class="o">!=</span> <span class="s1">&#39;dirichlet_sets&#39;</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The computation of Dirichlet boundary sets &#39;</span>
                          <span class="s1">&#39;reaction forces is only available for the &#39;</span>
                          <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">dirichlet_sets</span><span class="se">\&#39;</span><span class="s1"> force equilibrium loss type.&#39;</span><span class="p">,</span>
                          <span class="n">category</span><span class="o">=</span><span class="ne">UserWarning</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_compute_sets_reaction_hist</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_compute_sets_reaction_hist</span> <span class="o">=</span> <span class="n">is_compute_sets_reaction_hist</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set force normalization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_force_normalization</span> <span class="o">=</span> <span class="n">is_force_normalization</span>
        <span class="c1"># Set device</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_device</span><span class="p">(</span><span class="n">device_type</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize specimen numerical data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_specimen_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Initialize specimen material state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_specimen_material_state</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model_parameters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize data scalers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_scalers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_force_normalization</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_data_scalers</span><span class="p">()</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder._set_model_subdirs"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder._set_model_subdirs">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_set_model_subdirs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set model subdirectories.&quot;&quot;&quot;</span>
        <span class="c1"># Set material models subdirectory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_material_models_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_directory</span><span class="p">),</span> <span class="s1">&#39;material_models&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Collect model subdirectories</span>
        <span class="n">subdirs</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_material_models_dir</span><span class="p">,)</span>
        <span class="c1"># Create model subdirectories</span>
        <span class="k">for</span> <span class="n">subdir</span> <span class="ow">in</span> <span class="n">subdirs</span><span class="p">:</span>
            <span class="n">make_directory</span><span class="p">(</span><span class="n">subdir</span><span class="p">,</span> <span class="n">is_overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder._set_material_models_dirs"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder._set_material_models_dirs">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_set_material_models_dirs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set material models directories.&quot;&quot;&quot;</span>
        <span class="c1"># Get material models</span>
        <span class="n">material_models</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_specimen_material_state</span><span class="o">.</span><span class="n">get_material_models</span><span class="p">()</span>
        <span class="c1"># Loop over material models</span>
        <span class="k">for</span> <span class="n">model_key</span><span class="p">,</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">material_models</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Set material model directory</span>
            <span class="n">model_dir</span> <span class="o">=</span> \
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_material_models_dir</span><span class="p">),</span>
                             <span class="sa">f</span><span class="s1">&#39;model_</span><span class="si">{</span><span class="n">model_key</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Create material model directory</span>
            <span class="n">make_directory</span><span class="p">(</span><span class="n">model_dir</span><span class="p">,</span> <span class="n">is_overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Update material model directory</span>
            <span class="n">model</span><span class="o">.</span><span class="n">model_directory</span> <span class="o">=</span> <span class="n">model_dir</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.check_force_equilibrium_loss_type"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.check_force_equilibrium_loss_type">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">check_force_equilibrium_loss_type</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">force_equilibrium_loss_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if force equilibrium loss type is available.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        force_equilibrium_loss_type : str</span>
<span class="sd">            Type of force equilibrium loss.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        force_equilibrium_loss_type : str</span>
<span class="sd">            Type of force equilibrium loss.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set available force equilibrium loss types</span>
        <span class="n">available_force_equilibrium_loss_types</span> <span class="o">=</span> \
            <span class="p">(</span><span class="s1">&#39;pointwise&#39;</span><span class="p">,</span> <span class="s1">&#39;dirichlet_sets&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Check force equilibrium loss type</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">force_equilibrium_loss_type</span> <span class="ow">not</span> <span class="ow">in</span>
                <span class="n">available_force_equilibrium_loss_types</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Invalid force equilibrium loss type: &#39;</span>
                               <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">force_equilibrium_loss_type</span><span class="si">}</span><span class="s1">. </span><span class="se">\n\n</span><span class="s1">&#39;</span>
                               <span class="sa">f</span><span class="s1">&#39;Available types are: &#39;</span>
                               <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">available_force_equilibrium_loss_types</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">force_equilibrium_loss_type</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.set_specimen_data"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.set_specimen_data">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">set_specimen_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">specimen_data</span><span class="p">,</span> <span class="n">specimen_material_state</span><span class="p">,</span>
                          <span class="n">force_minimum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">force_maximum</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">loss_scaling_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loss_time_weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set specimen data and material state.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        specimen_data : SpecimenNumericalData</span>
<span class="sd">            Specimen numerical data translated from experimental results.</span>
<span class="sd">        specimen_material_state : StructureMaterialState</span>
<span class="sd">            FETorch specimen material state.</span>
<span class="sd">        force_minimum : torch.Tensor(1d), default=None</span>
<span class="sd">            Forces normalization minimum tensor stored as a torch.Tensor with</span>
<span class="sd">            shape (n_dim,). Only required if force normalization is set to</span>
<span class="sd">            True, otherwise ignored.</span>
<span class="sd">        force_maximum : torch.Tensor(1d), default=None</span>
<span class="sd">            Forces normalization maximum tensor stored as a torch.Tensor with</span>
<span class="sd">            shape (n_dim,). Only required if force normalization is set to</span>
<span class="sd">            True, otherwise ignored.</span>
<span class="sd">        loss_scaling_factor : torch.Tensor(0d), default=None</span>
<span class="sd">            Loss scaling factor. If provided, then loss is pre-multiplied by</span>
<span class="sd">            loss scaling factor.</span>
<span class="sd">        loss_time_weights : torch.Tensor(1d), default=None</span>
<span class="sd">            Loss time weights stored as torch.Tensor(1d) of shape (n_time).</span>
<span class="sd">            If provided, then each discrete time loss contribution is</span>
<span class="sd">            pre-multiplied by corresponding weight. If None, time weights are</span>
<span class="sd">            set to 1.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check Dirichlet boundary constraints admissibility</span>
        <span class="n">specimen_data</span><span class="o">.</span><span class="n">check_dirichlet_bc_mesh_hist</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_force_equilibrium_loss_type</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set specimen numerical data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_specimen_data</span> <span class="o">=</span> <span class="n">specimen_data</span>
        <span class="c1"># Set specimen material state (material models parameters linkage)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_specimen_material_state</span> <span class="o">=</span> <span class="n">specimen_material_state</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set material models directories</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_material_models_dirs</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Fit force data scalers</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_force_normalization</span><span class="p">:</span>
            <span class="c1"># Check forces normalization minimum and maximum tensors</span>
            <span class="k">if</span> <span class="n">force_minimum</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">force_maximum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Forces normalization minimum and maximum &#39;</span>
                                   <span class="s1">&#39;tensors must be provided to perform &#39;</span>
                                   <span class="s1">&#39;force normalization.&#39;</span><span class="p">)</span>
            <span class="c1"># Set fitted force data scalers</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_fitted_force_data_scalers</span><span class="p">(</span><span class="n">force_minimum</span><span class="p">,</span> <span class="n">force_maximum</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set loss scaling factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_loss_scaling_factor</span> <span class="o">=</span> <span class="n">loss_scaling_factor</span>
        <span class="c1"># Check loss time weights</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loss_time_weights</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="c1"># Get number of time steps</span>
            <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_specimen_data</span><span class="o">.</span><span class="n">time_hist</span><span class="p">)</span>
            <span class="c1"># Check loss time weights</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">loss_time_weights</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Loss time weights must be provided as &#39;</span>
                                   <span class="s1">&#39;torch.Tensor(1d) of shape (n_time).&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">loss_time_weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                  <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_specimen_data</span><span class="o">.</span><span class="n">time_hist</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Loss time weights must be provided as &#39;</span>
                                   <span class="sa">f</span><span class="s1">&#39;torch.Tensor(1d) of shape (n_time), &#39;</span>
                                   <span class="sa">f</span><span class="s1">&#39;where n_time = </span><span class="si">{</span><span class="n">n_time</span><span class="si">}</span><span class="s1"> (got &#39;</span>
                                   <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">loss_time_weights</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">).&#39;</span><span class="p">)</span>
            <span class="c1"># Set loss time weights</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loss_time_weights</span> <span class="o">=</span> <span class="n">loss_time_weights</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get number of time steps</span>
            <span class="n">n_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_specimen_data</span><span class="o">.</span><span class="n">time_hist</span><span class="p">)</span>
            <span class="c1"># Set loss time weights</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loss_time_weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_time</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.get_material_models"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.get_material_models">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_material_models</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get material models.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        material_models : dict</span>
<span class="sd">            FETorch material constitutive models (key, str[int], item,</span>
<span class="sd">            ConstitutiveModel). Models are labeled from 1 to n_mat_model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_specimen_material_state</span><span class="o">.</span><span class="n">get_material_models</span><span class="p">()</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.get_detached_model_parameters"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.get_detached_model_parameters">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_detached_model_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get model parameters (material models) detached of gradients.</span>
<span class="sd">        </span>
<span class="sd">        Only collects parameters from material models with explicit learnable</span>
<span class="sd">        parameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters names are prefixed by corresponding model label.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        model_parameters : dict</span>
<span class="sd">            Model parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize model parameters</span>
        <span class="n">model_parameters</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get material models</span>
        <span class="n">material_models</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_specimen_material_state</span><span class="o">.</span><span class="n">get_material_models</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Loop over material models</span>
        <span class="k">for</span> <span class="n">model_key</span><span class="p">,</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">material_models</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Collect material models explicit learnable parameters</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">HybridModel</span><span class="p">):</span>
                <span class="c1"># Get hybridized material models names</span>
                <span class="n">submodels_names</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_hybridized_models_names</span><span class="p">()</span>
                <span class="c1"># Get hybridized material models</span>
                <span class="n">submodels</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_hybridized_models</span><span class="p">()</span>
                <span class="c1"># Loop over material submodels</span>
                <span class="k">for</span> <span class="n">submodel_name</span><span class="p">,</span> <span class="n">submodel</span> <span class="ow">in</span> \
                        <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">submodels_names</span><span class="p">,</span> <span class="n">submodels</span><span class="p">)):</span>
                    <span class="c1"># Check if submodel parameters are collected</span>
                    <span class="n">is_collect_params</span> <span class="o">=</span> \
                        <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">submodel</span><span class="p">,</span> <span class="s1">&#39;is_explicit_parameters&#39;</span><span class="p">)</span>
                         <span class="ow">and</span> <span class="n">submodel</span><span class="o">.</span><span class="n">is_explicit_parameters</span><span class="p">)</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Skip submodel parameters</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_collect_params</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Get detached submodel parameters</span>
                    <span class="n">detached_parameters</span> <span class="o">=</span> \
                        <span class="n">submodel</span><span class="o">.</span><span class="n">get_detached_model_parameters</span><span class="p">(</span>
                            <span class="n">is_normalized_out</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Collect parameters (prefix with model and submodel label)</span>
                    <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">detached_parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="c1"># Set parameter label</span>
                        <span class="n">param_label</span> <span class="o">=</span> \
                            <span class="sa">f</span><span class="s1">&#39;model_</span><span class="si">{</span><span class="n">model_key</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">submodel_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s1">&#39;</span>
                        <span class="c1"># Store parameter</span>
                        <span class="n">model_parameters</span><span class="p">[</span><span class="n">param_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>  
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Check if model parameters are collected</span>
                <span class="n">is_collect_params</span> <span class="o">=</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;is_explicit_parameters&#39;</span><span class="p">)</span>
                                     <span class="ow">and</span> <span class="n">model</span><span class="o">.</span><span class="n">is_explicit_parameters</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Skip model parameters</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_collect_params</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Get detached model parameters</span>
                <span class="n">detached_parameters</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_detached_model_parameters</span><span class="p">(</span>
                    <span class="n">is_normalized_out</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Collect parameters (prefix with model label)</span>
                <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">detached_parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="c1"># Set parameter label</span>
                    <span class="n">param_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;model_</span><span class="si">{</span><span class="n">model_key</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="c1"># Store parameter</span>
                    <span class="n">model_parameters</span><span class="p">[</span><span class="n">param_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">model_parameters</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.get_model_parameters_bounds"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.get_model_parameters_bounds">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_model_parameters_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get model parameters (material models) bounds.</span>
<span class="sd">        </span>
<span class="sd">        Only collects parameters bounds from material models with explicit</span>
<span class="sd">        learnable parameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters names are prefixed by corresponding model label.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        model_parameters_bounds : dict</span>
<span class="sd">            Model learnable parameters bounds. For each parameter (key, str),</span>
<span class="sd">            the corresponding bounds are stored as a</span>
<span class="sd">            tuple(lower_bound, upper_bound) (item, tuple).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize model parameters</span>
        <span class="n">model_parameters_bounds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get material models</span>
        <span class="n">material_models</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_specimen_material_state</span><span class="o">.</span><span class="n">get_material_models</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Loop over material models</span>
        <span class="k">for</span> <span class="n">model_key</span><span class="p">,</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">material_models</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Collect material models explicit learnable parameters</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">HybridModel</span><span class="p">):</span>
                <span class="c1"># Get hybridized material models names</span>
                <span class="n">submodels_names</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_hybridized_models_names</span><span class="p">()</span>
                <span class="c1"># Get hybridized material models</span>
                <span class="n">submodels</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_hybridized_models</span><span class="p">()</span>
                <span class="c1"># Loop over material submodels</span>
                <span class="k">for</span> <span class="n">submodel_name</span><span class="p">,</span> <span class="n">submodel</span> <span class="ow">in</span> \
                        <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">submodels_names</span><span class="p">,</span> <span class="n">submodels</span><span class="p">)):</span>
                    <span class="c1"># Check if submodel parameters are collected</span>
                    <span class="n">is_collect_params</span> <span class="o">=</span> \
                        <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">submodel</span><span class="p">,</span> <span class="s1">&#39;is_explicit_parameters&#39;</span><span class="p">)</span>
                         <span class="ow">and</span> <span class="n">submodel</span><span class="o">.</span><span class="n">is_explicit_parameters</span><span class="p">)</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Skip submodel parameters</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_collect_params</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Get model parameters bounds</span>
                    <span class="n">parameters_bounds</span> <span class="o">=</span> <span class="n">submodel</span><span class="o">.</span><span class="n">get_model_parameters_bounds</span><span class="p">()</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Collect parameters bounds (prefix with model and submodel</span>
                    <span class="c1"># label)</span>
                    <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">bounds</span> <span class="ow">in</span> <span class="n">parameters_bounds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="c1"># Set parameter label</span>
                        <span class="n">param_label</span> <span class="o">=</span> \
                            <span class="sa">f</span><span class="s1">&#39;model_</span><span class="si">{</span><span class="n">model_key</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">submodel_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s1">&#39;</span>
                        <span class="c1"># Store parameter</span>
                        <span class="n">model_parameters_bounds</span><span class="p">[</span><span class="n">param_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">bounds</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Check if model parameters are collected</span>
                <span class="n">is_collect_params</span> <span class="o">=</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;is_explicit_parameters&#39;</span><span class="p">)</span>
                                     <span class="ow">and</span> <span class="n">model</span><span class="o">.</span><span class="n">is_explicit_parameters</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Skip model parameters</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_collect_params</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Get model parameters bounds</span>
                <span class="n">parameters_bounds</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_model_parameters_bounds</span><span class="p">()</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Collect parameters bounds (prefix with model label)</span>
                <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">bounds</span> <span class="ow">in</span> <span class="n">parameters_bounds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="c1"># Set parameter label</span>
                    <span class="n">param_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;model_</span><span class="si">{</span><span class="n">model_key</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="c1"># Store parameter</span>
                    <span class="n">model_parameters_bounds</span><span class="p">[</span><span class="n">param_label</span><span class="p">]</span> <span class="o">=</span> <span class="n">bounds</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">model_parameters_bounds</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.enforce_parameters_bounds"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.enforce_parameters_bounds">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">enforce_parameters_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Enforce bounds in model parameters (material models).</span>
<span class="sd">        </span>
<span class="sd">        Only enforces bounds in parameters from material models with explicit</span>
<span class="sd">        learnable parameters.</span>
<span class="sd">        </span>
<span class="sd">        Bounds are enforced by means of in-place parameters updates.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get material models</span>
        <span class="n">material_models</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_specimen_material_state</span><span class="o">.</span><span class="n">get_material_models</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Loop over material models</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">material_models</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Enforce bounds in models explicit learnable parameters</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">HybridModel</span><span class="p">):</span>
                <span class="c1"># Get hybridized material models</span>
                <span class="n">submodels</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_hybridized_models</span><span class="p">()</span>
                <span class="c1"># Loop over material submodels</span>
                <span class="k">for</span> <span class="n">submodel</span> <span class="ow">in</span> <span class="n">submodels</span><span class="p">:</span>
                    <span class="c1"># Check if submodel parameters are collected</span>
                    <span class="n">is_collect_params</span> <span class="o">=</span> \
                        <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">submodel</span><span class="p">,</span> <span class="s1">&#39;is_explicit_parameters&#39;</span><span class="p">)</span>
                         <span class="ow">and</span> <span class="n">submodel</span><span class="o">.</span><span class="n">is_explicit_parameters</span><span class="p">)</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Skip submodel parameters</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_collect_params</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Get submodel parameters</span>
                    <span class="n">param_dict</span> <span class="o">=</span> <span class="n">submodel</span><span class="o">.</span><span class="n">get_model_parameters</span><span class="p">()</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Loop over submodel parameters</span>
                    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">param_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="c1"># Get parameter bounds</span>
                        <span class="k">if</span> <span class="n">submodel</span><span class="o">.</span><span class="n">is_normalized_parameters</span><span class="p">:</span>
                            <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span> <span class="o">=</span> \
                                <span class="n">submodel</span><span class="o">.</span><span class="n">get_model_parameters_norm_bounds</span><span class="p">(</span>
                                    <span class="p">)[</span><span class="n">param</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span> <span class="o">=</span> \
                                <span class="n">submodel</span><span class="o">.</span><span class="n">get_model_parameters_bounds</span><span class="p">()[</span><span class="n">param</span><span class="p">]</span>
                        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                        <span class="c1"># Get learnable parameter</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">param_dict</span><span class="p">[</span><span class="n">param</span><span class="p">]</span>
                        <span class="c1"># Enforce bounds</span>
                        <span class="n">value</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">clamp_</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Check if model parameters are collected</span>
                <span class="n">is_collect_params</span> <span class="o">=</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;is_explicit_parameters&#39;</span><span class="p">)</span>
                                     <span class="ow">and</span> <span class="n">model</span><span class="o">.</span><span class="n">is_explicit_parameters</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Skip model parameters</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_collect_params</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Get material model parameters</span>
                <span class="n">param_dict</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_model_parameters</span><span class="p">()</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Loop over material model parameters</span>
                <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">param_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="c1"># Get parameter bounds</span>
                    <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">is_normalized_parameters</span><span class="p">:</span>
                        <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span> <span class="o">=</span> \
                            <span class="n">model</span><span class="o">.</span><span class="n">get_model_parameters_norm_bounds</span><span class="p">()[</span><span class="n">param</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span> <span class="o">=</span> \
                            <span class="n">model</span><span class="o">.</span><span class="n">get_model_parameters_bounds</span><span class="p">()[</span><span class="n">param</span><span class="p">]</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Get learnable parameter</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">param_dict</span><span class="p">[</span><span class="n">param</span><span class="p">]</span>
                    <span class="c1"># Enforce bounds</span>
                    <span class="n">value</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">clamp_</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.enforce_parameters_constraints"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.enforce_parameters_constraints">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">enforce_parameters_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Enforce material model-dependent parameters constraints.</span>
<span class="sd">        </span>
<span class="sd">        Only enforces constraints in parameters from material models with</span>
<span class="sd">        explicit learnable parameters.</span>
<span class="sd">        </span>
<span class="sd">        Constraints are enforced by means of in-place parameters updates.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get material models</span>
        <span class="n">material_models</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_specimen_material_state</span><span class="o">.</span><span class="n">get_material_models</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Loop over material models</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">material_models</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Enforce bounds in models explicit learnable parameters</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">HybridModel</span><span class="p">):</span>
                <span class="c1"># Get hybridized material models</span>
                <span class="n">submodels</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_hybridized_models</span><span class="p">()</span>
                <span class="c1"># Loop over material submodels</span>
                <span class="k">for</span> <span class="n">submodel</span> <span class="ow">in</span> <span class="n">submodels</span><span class="p">:</span>
                    <span class="c1"># Check if submodel parameters are collected</span>
                    <span class="n">is_collect_params</span> <span class="o">=</span> \
                        <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">submodel</span><span class="p">,</span> <span class="s1">&#39;is_explicit_parameters&#39;</span><span class="p">)</span>
                         <span class="ow">and</span> <span class="n">submodel</span><span class="o">.</span><span class="n">is_explicit_parameters</span><span class="p">)</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Skip submodel parameters</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_collect_params</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Enforce material model-dependent parameters constraints</span>
                    <span class="n">submodel</span><span class="o">.</span><span class="n">enforce_parameters_constraints</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Check if model parameters are collected</span>
                <span class="n">is_collect_params</span> <span class="o">=</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;is_explicit_parameters&#39;</span><span class="p">)</span>
                                     <span class="ow">and</span> <span class="n">model</span><span class="o">.</span><span class="n">is_explicit_parameters</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Skip model parameters</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_collect_params</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Enforce material model-dependent parameters constraints</span>
                <span class="n">model</span><span class="o">.</span><span class="n">enforce_parameters_constraints</span><span class="p">()</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.set_device"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.set_device">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">set_device</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set device on which torch.Tensor is allocated.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        device_type : {&#39;cpu&#39;, &#39;cuda&#39;}</span>
<span class="sd">            Type of device on which torch.Tensor is allocated.</span>
<span class="sd">        device : torch.device</span>
<span class="sd">            Device on which torch.Tensor is allocated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">device_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;cpu&#39;</span><span class="p">,</span> <span class="s1">&#39;cuda&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">device_type</span> <span class="o">==</span> <span class="s1">&#39;cuda&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;PyTorch with CUDA is not available. &#39;</span>
                                   <span class="s1">&#39;Please set the model device type as CPU &#39;</span>
                                   <span class="s1">&#39;as:</span><span class="se">\n\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;model.set_device(</span><span class="se">\&#39;</span><span class="s1">cpu</span><span class="se">\&#39;</span><span class="s1">).&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_device_type</span> <span class="o">=</span> <span class="n">device_type</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="n">device_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Invalid device type.&#39;</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.get_device"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.get_device">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_device</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get device on which torch.Tensor is allocated.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        device_type : {&#39;cpu&#39;, &#39;cuda&#39;}</span>
<span class="sd">            Type of device on which torch.Tensor is allocated.</span>
<span class="sd">        device : torch.device</span>
<span class="sd">            Device on which torch.Tensor is allocated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">device_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">device</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.forward"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.forward">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequential_mode</span><span class="o">=</span><span class="s1">&#39;sequential_element&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Forward propagation.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        specimen_data : SpecimenNumericalData</span>
<span class="sd">            Specimen numerical data translated from experimental results.</span>
<span class="sd">        specimen_material_state : StructureMaterialState</span>
<span class="sd">            FETorch structure material state.</span>
<span class="sd">        sequential_mode : {&#39;sequential_time&#39;, &#39;sequential_element&#39;, \</span>
<span class="sd">                           &#39;sequential_element_vmap}, \</span>
<span class="sd">                          default=&#39;sequential_element&#39;</span>
<span class="sd">                          </span>
<span class="sd">            &#39;sequential_time&#39; : Internal forces are computed in the standard</span>
<span class="sd">            way, processing each time step sequentially. Currently only</span>
<span class="sd">            available for inference.</span>
<span class="sd">            </span>
<span class="sd">            &#39;sequential_element&#39; : Internal forces are computed such that each</span>
<span class="sd">            element is processed sequentially (taking into account the</span>
<span class="sd">            corresponding deformation history). Available for both training</span>
<span class="sd">            and inference. Significantly limited with respect to memory costs.</span>
<span class="sd">            </span>
<span class="sd">            &#39;sequential_element_vmap&#39; : Similar to &#39;sequential_element&#39; but</span>
<span class="sd">            leveraging vectorizing maps (significant improvement of processing</span>
<span class="sd">            time and memory efficiency). Available for both training and</span>
<span class="sd">            inference.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        force_equilibrium_hist_loss : torch.Tensor(0d)</span>
<span class="sd">            Force equilibrium history loss.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute force equilibrium history loss</span>
        <span class="k">if</span> <span class="n">sequential_mode</span> <span class="o">==</span> <span class="s1">&#39;sequential_time&#39;</span><span class="p">:</span>
            <span class="c1"># Check device support</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_device_type</span> <span class="o">==</span> <span class="s1">&#39;cuda&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s1">&#39;FETorch standard sequential time computation does not &#39;</span>
                    <span class="s1">&#39;currently support CUDA. Please set torch device as CPU &#39;</span>
                    <span class="s1">&#39;to use </span><span class="se">\&#39;</span><span class="s1">sequential_time</span><span class="se">\&#39;</span><span class="s1"> mode.&#39;</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="n">force_equilibrium_hist_loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_sequential_time</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">sequential_mode</span> <span class="o">==</span> <span class="s1">&#39;sequential_element&#39;</span><span class="p">:</span>
            <span class="n">force_equilibrium_hist_loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_sequential_element</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">sequential_mode</span> <span class="o">==</span> <span class="s1">&#39;sequential_element_vmap&#39;</span><span class="p">:</span>
            <span class="n">force_equilibrium_hist_loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vforward_sequential_element</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unknown sequential mode.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Apply loss scaling factor</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loss_scaling_factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">force_equilibrium_hist_loss</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_loss_scaling_factor</span><span class="o">*</span><span class="n">force_equilibrium_hist_loss</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">force_equilibrium_hist_loss</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.forward_sequential_time"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.forward_sequential_time">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">forward_sequential_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Forward propagation (sequential time).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        force_equilibrium_hist_loss : torch.Tensor(0d)</span>
<span class="sd">            Force equilibrium history loss.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get specimen numerical data</span>
        <span class="n">specimen_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_specimen_data</span>
        <span class="c1"># Get specimen material state</span>
        <span class="n">specimen_material_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_specimen_material_state</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get specimen finite element mesh</span>
        <span class="n">specimen_mesh</span> <span class="o">=</span> <span class="n">specimen_data</span><span class="o">.</span><span class="n">specimen_mesh</span>
        <span class="c1"># Get number of elements of finite element mesh</span>
        <span class="n">n_elem</span> <span class="o">=</span> <span class="n">specimen_mesh</span><span class="o">.</span><span class="n">get_n_elem</span><span class="p">()</span>
        <span class="c1"># Get elements type</span>
        <span class="n">elements_type</span> <span class="o">=</span> <span class="n">specimen_mesh</span><span class="o">.</span><span class="n">get_elements_type</span><span class="p">()</span>
        <span class="c1"># Get degrees of freedom subject to Dirichlet boundary conditions</span>
        <span class="n">dirichlet_bool_mesh</span> <span class="o">=</span> <span class="n">specimen_mesh</span><span class="o">.</span><span class="n">get_dirichlet_bool_mesh</span><span class="p">()</span>
        <span class="c1"># Get time history length</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">specimen_data</span><span class="o">.</span><span class="n">time_hist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get strain formulation and problem type</span>
        <span class="n">strain_formulation</span> <span class="o">=</span> <span class="n">specimen_material_state</span><span class="o">.</span><span class="n">get_strain_formulation</span><span class="p">()</span>
        <span class="n">problem_type</span> <span class="o">=</span> <span class="n">specimen_material_state</span><span class="o">.</span><span class="n">get_problem_type</span><span class="p">()</span>
        <span class="c1"># Get problem type parameters</span>
        <span class="n">n_dim</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_problem_type_parameters</span><span class="p">(</span><span class="n">problem_type</span><span class="p">)</span>
        <span class="c1"># Get elements material</span>
        <span class="n">elements_material</span> <span class="o">=</span> <span class="n">specimen_material_state</span><span class="o">.</span><span class="n">get_elements_material</span><span class="p">()</span>
        <span class="c1"># Set finite element mesh nodes coordinates update flag</span>
        <span class="k">if</span> <span class="n">strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="n">is_update_coords</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_update_coords</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize force equilibrium history loss</span>
        <span class="n">force_equilibrium_hist_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Loop over discrete time</span>
        <span class="k">for</span> <span class="n">time_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="c1"># Update mesh configuration with known displacement history</span>
            <span class="n">specimen_data</span><span class="o">.</span><span class="n">update_specimen_mesh_configuration</span><span class="p">(</span>
                <span class="n">time_idx</span><span class="p">,</span> <span class="n">is_update_coords</span><span class="o">=</span><span class="n">is_update_coords</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Initialize elements internal forces</span>
            <span class="n">elements_internal_forces</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># Loop over elements</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_elem</span><span class="p">):</span>
                <span class="c1"># Get element label</span>
                <span class="n">elem_id</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Get element type</span>
                <span class="n">element_type</span> <span class="o">=</span> <span class="n">elements_type</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">elem_id</span><span class="p">)]</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Get element nodes coordinates and displacements</span>
                <span class="n">nodes_coords</span><span class="p">,</span> <span class="n">nodes_disps</span> <span class="o">=</span> \
                    <span class="n">specimen_mesh</span><span class="o">.</span><span class="n">get_element_configuration</span><span class="p">(</span><span class="n">elem_id</span><span class="p">,</span>
                                                            <span class="n">time</span><span class="o">=</span><span class="s1">&#39;current&#39;</span><span class="p">)</span>
                <span class="c1"># Get element nodes last converged displacements</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">nodes_disps_old</span> <span class="o">=</span> \
                    <span class="n">specimen_mesh</span><span class="o">.</span><span class="n">get_element_configuration</span><span class="p">(</span><span class="n">elem_id</span><span class="p">,</span>
                                                            <span class="n">time</span><span class="o">=</span><span class="s1">&#39;last&#39;</span><span class="p">)</span>
                <span class="c1"># Compute element nodes incremental displacements</span>
                <span class="n">nodes_inc_disps</span> <span class="o">=</span> <span class="n">nodes_disps</span> <span class="o">-</span> <span class="n">nodes_disps_old</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Get element material model</span>
                <span class="n">element_material</span> <span class="o">=</span> <span class="n">elements_material</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">elem_id</span><span class="p">)]</span>
                <span class="c1"># Get element last converged material constitutive state</span>
                <span class="c1"># variables</span>
                <span class="n">element_state_old</span> <span class="o">=</span> \
                    <span class="n">specimen_material_state</span><span class="o">.</span><span class="n">get_element_state</span><span class="p">(</span><span class="n">elem_id</span><span class="p">,</span>
                                                              <span class="n">time</span><span class="o">=</span><span class="s1">&#39;last&#39;</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Compute element internal forces</span>
                <span class="n">internal_forces</span><span class="p">,</span> <span class="n">element_state</span> <span class="o">=</span> \
                    <span class="n">compute_element_internal_forces</span><span class="p">(</span>
                        <span class="n">strain_formulation</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">,</span> <span class="n">element_type</span><span class="p">,</span>
                        <span class="n">element_material</span><span class="p">,</span> <span class="n">element_state_old</span><span class="p">,</span> <span class="n">nodes_coords</span><span class="p">,</span>
                        <span class="n">nodes_disps</span><span class="p">,</span> <span class="n">nodes_inc_disps</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Store element internal forces</span>
                <span class="n">elements_internal_forces</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">elem_id</span><span class="p">)]</span> <span class="o">=</span> <span class="n">internal_forces</span>
                <span class="c1"># Update element material constitutive state variables</span>
                <span class="n">specimen_material_state</span><span class="o">.</span><span class="n">update_element_state</span><span class="p">(</span>
                    <span class="n">elem_id</span><span class="p">,</span> <span class="n">element_state</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="s1">&#39;current&#39;</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Assemble element internal forces of finite element mesh nodes</span>
            <span class="n">internal_forces_mesh</span> <span class="o">=</span> \
                <span class="n">specimen_mesh</span><span class="o">.</span><span class="n">element_assembler</span><span class="p">(</span><span class="n">elements_internal_forces</span><span class="p">)</span>
            <span class="n">internal_forces_mesh</span> <span class="o">=</span> <span class="n">internal_forces_mesh</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Update elements last converged material constitutive state</span>
            <span class="c1"># variables</span>
            <span class="n">specimen_material_state</span><span class="o">.</span><span class="n">update_converged_elements_state</span><span class="p">()</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Set null external forces of finite element mesh nodes</span>
            <span class="n">external_forces_mesh</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">internal_forces_mesh</span><span class="p">)</span>
            <span class="c1"># Get reaction forces (Dirichlet boundary conditions) of finite</span>
            <span class="c1"># element mesh nodes</span>
            <span class="n">reaction_forces_mesh</span> <span class="o">=</span> \
                <span class="n">specimen_data</span><span class="o">.</span><span class="n">reaction_forces_mesh_hist</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">time_idx</span><span class="p">]</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Get discrete time loss weight</span>
            <span class="n">time_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loss_time_weights</span><span class="p">[</span><span class="n">time_idx</span><span class="p">]</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Add contribution to force equilibrium history loss</span>
            <span class="n">force_equilibrium_hist_loss</span> <span class="o">+=</span> \
                <span class="n">time_weight</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">force_equilibrium_loss</span><span class="p">(</span>
                    <span class="n">internal_forces_mesh</span><span class="p">,</span> <span class="n">external_forces_mesh</span><span class="p">,</span>
                    <span class="n">reaction_forces_mesh</span><span class="p">,</span> <span class="n">dirichlet_bool_mesh</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">force_equilibrium_hist_loss</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.forward_sequential_element"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.forward_sequential_element">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">forward_sequential_element</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Forward propagation (sequential element).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        force_equilibrium_hist_loss : torch.Tensor(0d)</span>
<span class="sd">            Force equilibrium history loss.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get specimen numerical data</span>
        <span class="n">specimen_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_specimen_data</span>
        <span class="c1"># Get specimen material state</span>
        <span class="n">specimen_material_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_specimen_material_state</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get specimen finite element mesh</span>
        <span class="n">specimen_mesh</span> <span class="o">=</span> <span class="n">specimen_data</span><span class="o">.</span><span class="n">specimen_mesh</span>
        <span class="c1"># Get number of nodes of finite element mesh</span>
        <span class="n">n_node_mesh</span> <span class="o">=</span> <span class="n">specimen_mesh</span><span class="o">.</span><span class="n">get_n_node_mesh</span><span class="p">()</span>
        <span class="c1"># Get number of elements of finite element mesh</span>
        <span class="n">n_elem</span> <span class="o">=</span> <span class="n">specimen_mesh</span><span class="o">.</span><span class="n">get_n_elem</span><span class="p">()</span>
        <span class="c1"># Get elements type</span>
        <span class="n">elements_type</span> <span class="o">=</span> <span class="n">specimen_mesh</span><span class="o">.</span><span class="n">get_elements_type</span><span class="p">()</span>
        <span class="c1"># Get degrees of freedom subject to Dirichlet boundary conditions</span>
        <span class="n">dirichlet_bool_mesh</span> <span class="o">=</span> <span class="n">specimen_mesh</span><span class="o">.</span><span class="n">get_dirichlet_bool_mesh</span><span class="p">()</span>
        <span class="c1"># Get time history</span>
        <span class="n">time_hist</span> <span class="o">=</span> <span class="n">specimen_data</span><span class="o">.</span><span class="n">time_hist</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">time_hist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get strain formulation and problem type</span>
        <span class="n">strain_formulation</span> <span class="o">=</span> <span class="n">specimen_material_state</span><span class="o">.</span><span class="n">get_strain_formulation</span><span class="p">()</span>
        <span class="n">problem_type</span> <span class="o">=</span> <span class="n">specimen_material_state</span><span class="o">.</span><span class="n">get_problem_type</span><span class="p">()</span>
        <span class="c1"># Get problem type parameters</span>
        <span class="n">n_dim</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_problem_type_parameters</span><span class="p">(</span><span class="n">problem_type</span><span class="p">)</span>
        <span class="c1"># Get elements material</span>
        <span class="n">elements_material</span> <span class="o">=</span> <span class="n">specimen_material_state</span><span class="o">.</span><span class="n">get_elements_material</span><span class="p">()</span>
        <span class="c1"># Set finite element mesh nodes coordinates update flag</span>
        <span class="k">if</span> <span class="n">strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="n">is_update_coords</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_update_coords</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize specimen local strain-stress paths data set samples</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_store_local_paths</span><span class="p">:</span>
            <span class="c1"># Initialize data set samples</span>
            <span class="n">specimen_local_samples</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Set elements of specimen local strain-stress data set</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_local_paths_elements</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">local_paths_elements</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_paths_elements</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">local_paths_elements</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_elem</span><span class="p">)]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize element internal forces of finite element mesh nodes</span>
        <span class="n">internal_forces_mesh_hist</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_node_mesh</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span>
                                                <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Loop over elements</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_elem</span><span class="p">):</span>
            <span class="c1"># Get element label</span>
            <span class="n">elem_id</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Get element type</span>
            <span class="n">element_type</span> <span class="o">=</span> <span class="n">elements_type</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">elem_id</span><span class="p">)]</span>
            <span class="c1"># Get element type number of nodes</span>
            <span class="n">n_node</span> <span class="o">=</span> <span class="n">element_type</span><span class="o">.</span><span class="n">get_n_node</span><span class="p">()</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Get element material model</span>
            <span class="n">element_material</span> <span class="o">=</span> <span class="n">elements_material</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">elem_id</span><span class="p">)]</span>
            <span class="c1"># Get element material model recurrent structure</span>
            <span class="n">is_recurrent_model</span> <span class="o">=</span> \
                <span class="n">specimen_material_state</span><span class="o">.</span><span class="n">get_element_model_recurrency</span><span class="p">(</span><span class="n">elem_id</span><span class="p">)</span>
            <span class="c1"># Get element initial material constitutive state variables</span>
            <span class="n">element_state_old</span> <span class="o">=</span> \
                <span class="n">specimen_material_state</span><span class="o">.</span><span class="n">get_element_state</span><span class="p">(</span><span class="n">elem_id</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="s1">&#39;last&#39;</span><span class="p">,</span>
                                                          <span class="n">is_copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Initialize element nodes coordinates, displacements and</span>
            <span class="c1"># incremental displacements histories</span>
            <span class="n">nodes_coords_hist</span> <span class="o">=</span> \
                <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_node</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
            <span class="n">nodes_disps_hist</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">nodes_coords_hist</span><span class="p">)</span>
            <span class="n">nodes_inc_disps_hist</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">nodes_coords_hist</span><span class="p">)</span>
            <span class="c1"># Loop over discrete time</span>
            <span class="k">for</span> <span class="n">time_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
                <span class="c1"># Update mesh configuration with known displacement history</span>
                <span class="n">specimen_data</span><span class="o">.</span><span class="n">update_specimen_mesh_configuration</span><span class="p">(</span>
                    <span class="n">time_idx</span><span class="p">,</span> <span class="n">is_update_coords</span><span class="o">=</span><span class="n">is_update_coords</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Get element nodes coordinates and displacements</span>
                <span class="n">nodes_coords</span><span class="p">,</span> <span class="n">nodes_disps</span> <span class="o">=</span> \
                    <span class="n">specimen_mesh</span><span class="o">.</span><span class="n">get_element_configuration</span><span class="p">(</span><span class="n">elem_id</span><span class="p">,</span>
                                                            <span class="n">time</span><span class="o">=</span><span class="s1">&#39;current&#39;</span><span class="p">)</span>
                <span class="c1"># Get element nodes last converged displacements</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">nodes_disps_old</span> <span class="o">=</span> \
                    <span class="n">specimen_mesh</span><span class="o">.</span><span class="n">get_element_configuration</span><span class="p">(</span><span class="n">elem_id</span><span class="p">,</span>
                                                            <span class="n">time</span><span class="o">=</span><span class="s1">&#39;last&#39;</span><span class="p">)</span>
                <span class="c1"># Compute element nodes incremental displacements</span>
                <span class="n">nodes_inc_disps</span> <span class="o">=</span> <span class="n">nodes_disps</span> <span class="o">-</span> <span class="n">nodes_disps_old</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Assemble element nodes history</span>
                <span class="n">nodes_coords_hist</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">time_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes_coords</span>
                <span class="n">nodes_disps_hist</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">time_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes_disps</span>
                <span class="n">nodes_inc_disps_hist</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">time_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">nodes_inc_disps</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Compute history of finite element internal forces</span>
            <span class="n">element_internal_forces_hist</span><span class="p">,</span> <span class="n">element_state_hist</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">compute_element_internal_forces_hist</span><span class="p">(</span>
                    <span class="n">strain_formulation</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">,</span> <span class="n">element_type</span><span class="p">,</span>
                    <span class="n">element_material</span><span class="p">,</span> <span class="n">element_state_old</span><span class="p">,</span> <span class="n">nodes_coords_hist</span><span class="p">,</span>
                    <span class="n">nodes_disps_hist</span><span class="p">,</span> <span class="n">nodes_inc_disps_hist</span><span class="p">,</span> <span class="n">time_hist</span><span class="p">,</span>
                    <span class="n">is_recurrent_model</span><span class="p">)</span>
            <span class="c1"># Update element material constitutive state variables</span>
            <span class="n">specimen_material_state</span><span class="o">.</span><span class="n">update_element_state</span><span class="p">(</span>
                <span class="n">elem_id</span><span class="p">,</span> <span class="n">element_state_hist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">time</span><span class="o">=</span><span class="s1">&#39;current&#39;</span><span class="p">,</span> <span class="n">is_copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Loop over discrete time</span>
            <span class="k">for</span> <span class="n">time_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
                <span class="c1"># Reshape element internal forces into mesh format</span>
                <span class="n">internal_forces_mesh</span> <span class="o">=</span> <span class="n">specimen_mesh</span><span class="o">.</span><span class="n">element_assembler</span><span class="p">(</span>
                    <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">elem_id</span><span class="p">):</span> <span class="n">element_internal_forces_hist</span><span class="p">[:,</span> <span class="n">time_idx</span><span class="p">]})</span>
                <span class="c1"># Assemble element internal forces of finite element mesh nodes</span>
                <span class="n">internal_forces_mesh_hist</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">time_idx</span><span class="p">]</span> <span class="o">+=</span> \
                    <span class="n">internal_forces_mesh</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Assemble element local strain-stress paths</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_store_local_paths</span> <span class="ow">and</span> <span class="n">elem_id</span> <span class="ow">in</span> <span class="n">local_paths_elements</span><span class="p">:</span>
                <span class="c1"># Build element local strain-stress paths</span>
                <span class="n">element_local_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_element_local_samples</span><span class="p">(</span>
                    <span class="n">strain_formulation</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">,</span> <span class="n">element_type</span><span class="p">,</span> <span class="n">time_hist</span><span class="p">,</span>
                    <span class="n">element_state_hist</span><span class="p">)</span>
                <span class="c1"># Assemble element local strain-stress paths</span>
                <span class="n">specimen_local_samples</span> <span class="o">+=</span> <span class="n">element_local_samples</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Update elements last converged material constitutive state variables</span>
        <span class="n">specimen_material_state</span><span class="o">.</span><span class="n">update_converged_elements_state</span><span class="p">(</span><span class="n">is_copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize force equilibrium history loss</span>
        <span class="n">force_equilibrium_hist_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Loop over discrete time</span>
        <span class="k">for</span> <span class="n">time_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="c1"># Get internal forces of finite element mesh nodes</span>
            <span class="n">internal_forces_mesh</span> <span class="o">=</span> <span class="n">internal_forces_mesh_hist</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">time_idx</span><span class="p">]</span>
            <span class="c1"># Set null external forces of finite element mesh nodes</span>
            <span class="n">external_forces_mesh</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">internal_forces_mesh</span><span class="p">)</span>
            <span class="c1"># Get reaction forces (Dirichlet boundary conditions) of finite</span>
            <span class="c1"># element mesh nodes</span>
            <span class="n">reaction_forces_mesh</span> <span class="o">=</span> \
                <span class="n">specimen_data</span><span class="o">.</span><span class="n">reaction_forces_mesh_hist</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">time_idx</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>    
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Get discrete time loss weight</span>
            <span class="n">time_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loss_time_weights</span><span class="p">[</span><span class="n">time_idx</span><span class="p">]</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Add contribution to force equilibrium history loss</span>
            <span class="n">force_equilibrium_hist_loss</span> <span class="o">+=</span> \
                <span class="n">time_weight</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">force_equilibrium_loss</span><span class="p">(</span>
                    <span class="n">internal_forces_mesh</span><span class="p">,</span> <span class="n">external_forces_mesh</span><span class="p">,</span>
                    <span class="n">reaction_forces_mesh</span><span class="p">,</span> <span class="n">dirichlet_bool_mesh</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Store specimen local strain-stress paths data set</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_store_local_paths</span><span class="p">:</span>
            <span class="c1"># Create strain-stress material response path data set</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">TimeSeriesDatasetInMemory</span><span class="p">(</span><span class="n">specimen_local_samples</span><span class="p">)</span>
            <span class="c1"># Set data set file basename</span>
            <span class="n">dataset_basename</span> <span class="o">=</span> <span class="s1">&#39;ss_paths_dataset&#39;</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Set data set directory</span>
            <span class="n">dataset_directory</span> <span class="o">=</span> \
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_directory</span><span class="p">),</span>
                             <span class="s1">&#39;local_response_dataset&#39;</span><span class="p">)</span>
            <span class="c1"># Create model directory</span>
            <span class="n">make_directory</span><span class="p">(</span><span class="n">dataset_directory</span><span class="p">,</span> <span class="n">is_overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Save data set</span>
            <span class="n">save_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">dataset_basename</span><span class="p">,</span> <span class="n">dataset_directory</span><span class="p">,</span>
                         <span class="n">is_append_n_sample</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">force_equilibrium_hist_loss</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.compute_element_internal_forces_hist"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.compute_element_internal_forces_hist">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">compute_element_internal_forces_hist</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">strain_formulation</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">,</span> <span class="n">element_type</span><span class="p">,</span> <span class="n">element_material</span><span class="p">,</span>
        <span class="n">element_state_old</span><span class="p">,</span> <span class="n">nodes_coords_hist</span><span class="p">,</span> <span class="n">nodes_disps_hist</span><span class="p">,</span>
        <span class="n">nodes_inc_disps_hist</span><span class="p">,</span> <span class="n">time_hist</span><span class="p">,</span> <span class="n">is_recurrent_model</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute history of finite element internal forces.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strain_formulation: {&#39;infinitesimal&#39;, &#39;finite&#39;}</span>
<span class="sd">            Strain formulation.</span>
<span class="sd">        problem_type : int</span>
<span class="sd">            Problem type: 2D plane strain (1), 2D plane stress (2),</span>
<span class="sd">            2D axisymmetric (3) and 3D (4).</span>
<span class="sd">        element_type : Element</span>
<span class="sd">            FETorch finite element.</span>
<span class="sd">        element_material : ConstitutiveModel</span>
<span class="sd">            FETorch material constitutive model.</span>
<span class="sd">        element_state_old : dict</span>
<span class="sd">            Last converged material constitutive model state variables</span>
<span class="sd">            (item, dict) for each Gauss integration point (key, str[int]).</span>
<span class="sd">        nodes_coords_hist : torch.Tensor(3d)</span>
<span class="sd">            Coordinates history of finite element nodes stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_node, n_dim, n_time).</span>
<span class="sd">        nodes_disps_hist : torch.Tensor(3d)</span>
<span class="sd">            Displacements history of finite element nodes stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_node, n_dim, n_time).</span>
<span class="sd">        nodes_inc_disps_hist : torch.Tensor(3d)</span>
<span class="sd">            Incremental displacements history of finite element nodes stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_node, n_dim, n_time).</span>
<span class="sd">        time_hist : torch.Tensor(1d)</span>
<span class="sd">            Discrete time history.</span>
<span class="sd">        is_recurrent_model : bool</span>
<span class="sd">            True if the material constitutive model has a recurrent structure</span>
<span class="sd">            (processes full deformation path when called), False otherwise.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        element_internal_forces_hist : torch.Tensor(2d)</span>
<span class="sd">            Element internal forces history stored as torch.Tensor(2d) of shape</span>
<span class="sd">            (n_node*n_dof_node, n_time).</span>
<span class="sd">        element_state_hist : list[dict]</span>
<span class="sd">            Material constitutive model state variables history (item, dict)</span>
<span class="sd">            for each Gauss integration point (key, str[int]).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get problem type parameters</span>
        <span class="n">n_dim</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> \
            <span class="n">get_problem_type_parameters</span><span class="p">(</span><span class="n">problem_type</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get element number of nodes</span>
        <span class="n">n_node</span> <span class="o">=</span> <span class="n">element_type</span><span class="o">.</span><span class="n">get_n_node</span><span class="p">()</span>
        <span class="c1"># Get element number of degrees of freedom per node</span>
        <span class="n">n_dof_node</span> <span class="o">=</span> <span class="n">element_type</span><span class="o">.</span><span class="n">get_n_dof_node</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get element number of Gauss quadrature integration points</span>
        <span class="n">n_gauss</span> <span class="o">=</span> <span class="n">element_type</span><span class="o">.</span><span class="n">get_n_gauss</span><span class="p">()</span>
        <span class="c1"># Get element Gauss quadrature integration points local coordinates</span>
        <span class="c1"># and weights</span>
        <span class="n">gp_coords</span><span class="p">,</span> <span class="n">gp_weights</span> <span class="o">=</span> <span class="n">element_type</span><span class="o">.</span><span class="n">get_gauss_integration_points</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get time history length</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">time_hist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize element internal forces history</span>
        <span class="n">element_internal_forces_hist</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_node</span><span class="o">*</span><span class="n">n_dof_node</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span>
                                                   <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
        <span class="c1"># Initialize element material constitutive model state variables</span>
        <span class="c1"># history</span>
        <span class="n">element_state_hist</span> <span class="o">=</span> \
            <span class="p">[{</span><span class="n">key</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">gp_coords</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">)]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Loop over Gauss integration points</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_gauss</span><span class="p">):</span>
            <span class="c1"># Get Gauss integration point local coordinates and weight</span>
            <span class="n">local_coords</span> <span class="o">=</span> <span class="n">gp_coords</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">gp_weights</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Initialize Gauss integration point last converged material</span>
            <span class="c1"># constitutive model state variables</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_recurrent_model</span><span class="p">:</span>
                <span class="n">state_variables_old</span> <span class="o">=</span> \
                    <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">element_state_old</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Initialize Gauss integration point strain tensor history</span>
            <span class="k">if</span> <span class="n">strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_recurrent_model</span><span class="p">:</span>
                    <span class="n">strain_hist</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_dim</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span>
                                              <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">inc_strain_hist</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_dim</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">,</span> <span class="n">n_time</span><span class="p">),</span>
                                                  <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not implemented.&#39;</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Loop over discrete time</span>
            <span class="k">for</span> <span class="n">time_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
                <span class="c1"># Evaluate shape functions derivates and Jacobian</span>
                <span class="n">shape_fun_deriv</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">jacobian_det</span> <span class="o">=</span> <span class="n">eval_shapefun_deriv</span><span class="p">(</span>
                    <span class="n">element_type</span><span class="p">,</span> <span class="n">nodes_coords_hist</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">time_idx</span><span class="p">],</span>
                    <span class="n">local_coords</span><span class="p">)</span>
                <span class="c1"># Build discrete symmetric gradient operator</span>
                <span class="n">grad_operator_sym</span> <span class="o">=</span> <span class="n">vbuild_discrete_sym_gradient</span><span class="p">(</span>
                    <span class="n">shape_fun_deriv</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Compute strain tensor</span>
                <span class="k">if</span> <span class="n">strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_recurrent_model</span><span class="p">:</span>
                        <span class="c1"># Compute infinitesimal strain tensor (Voigt matricial</span>
                        <span class="c1"># form)</span>
                        <span class="n">strain_vmf</span> <span class="o">=</span> <span class="n">compute_infinitesimal_strain</span><span class="p">(</span>
                            <span class="n">grad_operator_sym</span><span class="p">,</span>
                            <span class="n">nodes_disps_hist</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">time_idx</span><span class="p">])</span>
                        <span class="c1"># Get strain tensor</span>
                        <span class="n">strain_hist</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">time_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">vget_strain_from_vmf</span><span class="p">(</span>
                            <span class="n">strain_vmf</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Compute incremental infinitesimal strain tensor</span>
                        <span class="c1"># (Voigt matricial form)</span>
                        <span class="n">inc_strain_vmf</span> <span class="o">=</span> <span class="n">compute_infinitesimal_inc_strain</span><span class="p">(</span>
                            <span class="n">grad_operator_sym</span><span class="p">,</span>
                            <span class="n">nodes_inc_disps_hist</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">time_idx</span><span class="p">])</span>
                        <span class="c1"># Get incremental strain tensor</span>
                        <span class="n">inc_strain_hist</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">time_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">vget_strain_from_vmf</span><span class="p">(</span>
                            <span class="n">inc_strain_vmf</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not implemented.&#39;</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Compute Gauss integration point stress history</span>
            <span class="k">if</span> <span class="n">is_recurrent_model</span><span class="p">:</span>
                <span class="c1"># Material state update</span>
                <span class="n">state_variables_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">recurrent_material_state_update</span><span class="p">(</span>
                    <span class="n">strain_formulation</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">,</span> <span class="n">element_material</span><span class="p">,</span>
                    <span class="n">strain_hist</span><span class="p">,</span> <span class="n">time_hist</span><span class="p">)</span>
                <span class="c1"># Loop over discrete time</span>
                <span class="k">for</span> <span class="n">time_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
                    <span class="c1"># Store Gaussian integration point material constitutive</span>
                    <span class="c1"># model state variables</span>
                    <span class="n">element_state_hist</span><span class="p">[</span><span class="n">time_idx</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> \
                        <span class="n">state_variables_hist</span><span class="p">[</span><span class="n">time_idx</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Loop over discrete time</span>
                <span class="k">for</span> <span class="n">time_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
                    <span class="c1"># Material state update</span>
                    <span class="n">state_variables</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">material_state_update</span><span class="p">(</span>
                        <span class="n">strain_formulation</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">,</span> <span class="n">element_material</span><span class="p">,</span>
                        <span class="n">inc_strain_hist</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">time_idx</span><span class="p">],</span> <span class="n">state_variables_old</span><span class="p">,</span>
                        <span class="n">def_gradient_old</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                    <span class="c1"># Store Gauss integration point material constitutive model</span>
                    <span class="c1"># state variables</span>
                    <span class="n">element_state_hist</span><span class="p">[</span><span class="n">time_idx</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">state_variables</span> 
                    <span class="c1"># Update Gauss integration point last converged material</span>
                    <span class="c1"># constitutive model state variables</span>
                    <span class="n">state_variables_old</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">state_variables</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Loop over discrete time</span>
            <span class="k">for</span> <span class="n">time_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
                <span class="c1"># Get stress tensor</span>
                <span class="k">if</span> <span class="n">strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
                    <span class="c1"># Get Cauchy stress tensor</span>
                    <span class="n">stress</span> <span class="o">=</span> <span class="n">vget_tensor_from_mf</span><span class="p">(</span>
                        <span class="n">element_state_hist</span><span class="p">[</span><span class="n">time_idx</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)][</span><span class="s1">&#39;stress_mf&#39;</span><span class="p">],</span>
                        <span class="n">n_dim</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">)</span>
                    <span class="c1"># Get Cauchy stress tensor (Voigt matricial form)</span>
                    <span class="n">stress_vmf</span> <span class="o">=</span> <span class="n">vget_stress_vmf</span><span class="p">(</span><span class="n">stress</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not implemented.&#39;</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Evaluate shape functions derivates and Jacobian</span>
                <span class="n">shape_fun_deriv</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">jacobian_det</span> <span class="o">=</span> <span class="n">eval_shapefun_deriv</span><span class="p">(</span>
                    <span class="n">element_type</span><span class="p">,</span> <span class="n">nodes_coords_hist</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">time_idx</span><span class="p">],</span>
                    <span class="n">local_coords</span><span class="p">)</span>
                <span class="c1"># Build discrete symmetric gradient operator</span>
                <span class="n">grad_operator_sym</span> <span class="o">=</span> <span class="n">vbuild_discrete_sym_gradient</span><span class="p">(</span>
                    <span class="n">shape_fun_deriv</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Add Gauss integration point contribution to element internal</span>
                <span class="c1"># forces</span>
                <span class="n">element_internal_forces_hist</span><span class="p">[:,</span> <span class="n">time_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="n">weight</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">grad_operator_sym</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">stress_vmf</span><span class="p">)</span><span class="o">*</span>
                    <span class="n">jacobian_det</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">element_internal_forces_hist</span><span class="p">,</span> <span class="n">element_state_hist</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.recurrent_material_state_update"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.recurrent_material_state_update">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">recurrent_material_state_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strain_formulation</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">,</span>
                                        <span class="n">constitutive_model</span><span class="p">,</span> <span class="n">strain_hist</span><span class="p">,</span>
                                        <span class="n">time_hist</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Material state update for any given recurrent constitutive model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strain_formulation: {&#39;infinitesimal&#39;, &#39;finite&#39;}</span>
<span class="sd">            Problem strain formulation.</span>
<span class="sd">        problem_type : int</span>
<span class="sd">            Problem type: 2D plane strain (1), 2D plane stress (2),</span>
<span class="sd">            2D axisymmetric (3) and 3D (4).</span>
<span class="sd">        constitutive_model : ConstitutiveModel</span>
<span class="sd">            Recurrent material constitutive model.</span>
<span class="sd">        strain_hist : torch.Tensor(3d)</span>
<span class="sd">            Strain tensor history stored as torch.Tensor(3d) of shape</span>
<span class="sd">            (n_dim, n_dim, n_time).</span>
<span class="sd">        time_hist : torch.Tensor(1d)</span>
<span class="sd">            Discrete time history.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        state_variables_hist : list[dict]</span>
<span class="sd">            Material constitutive model state variables history.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get problem type parameters</span>
        <span class="n">n_dim</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> \
            <span class="n">get_problem_type_parameters</span><span class="p">(</span><span class="n">problem_type</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get time history length</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">time_hist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize material constitutive model state variables history</span>
        <span class="n">state_variables_hist</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">)]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize tensor of input features</span>
        <span class="k">if</span> <span class="n">strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="n">features_in</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order_sym</span><span class="p">)),</span>
                                      <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not implemented.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Build tensor of input features</span>
        <span class="k">for</span> <span class="n">time_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="c1"># Store strain tensor</span>
            <span class="k">if</span> <span class="n">strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
                <span class="n">features_in</span><span class="p">[</span><span class="n">time_idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">store_tensor_comps</span><span class="p">(</span>
                    <span class="n">comp_order_sym</span><span class="p">,</span> <span class="n">strain_hist</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">time_idx</span><span class="p">],</span>
                    <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not implemented.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute output features</span>
        <span class="n">features_out</span> <span class="o">=</span> <span class="n">constitutive_model</span><span class="p">(</span><span class="n">features_in</span><span class="p">)</span>
        <span class="c1"># Extract output features</span>
        <span class="n">features_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">features_out_extractor</span><span class="p">(</span><span class="n">features_out</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Loop over discrete time</span>
        <span class="k">for</span> <span class="n">time_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="c1"># Build and store strain and stress tensors</span>
            <span class="k">if</span> <span class="n">strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
                <span class="c1"># Build strain tensor</span>
                <span class="n">strain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vbuild_tensor_from_comps</span><span class="p">(</span>
                    <span class="n">n_dim</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">,</span>
                    <span class="n">features_in</span><span class="p">[</span><span class="n">time_idx</span><span class="p">,</span> <span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order_sym</span><span class="p">)],</span>
                    <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
                <span class="c1"># Store strain tensor</span>
                <span class="n">state_variables_hist</span><span class="p">[</span><span class="n">time_idx</span><span class="p">][</span><span class="s1">&#39;strain_mf&#39;</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">vget_tensor_mf</span><span class="p">(</span><span class="n">strain</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">,</span>
                                   <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Build stress tensor</span>
                <span class="n">stress</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vbuild_tensor_from_comps</span><span class="p">(</span>
                    <span class="n">n_dim</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">,</span>
                    <span class="n">features_out</span><span class="p">[</span><span class="n">time_idx</span><span class="p">,</span> <span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order_sym</span><span class="p">)],</span>
                    <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
                <span class="c1"># Store stress tensor</span>
                <span class="n">state_variables_hist</span><span class="p">[</span><span class="n">time_idx</span><span class="p">][</span><span class="s1">&#39;stress_mf&#39;</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">vget_tensor_mf</span><span class="p">(</span><span class="n">stress</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">,</span>
                                   <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not implemented.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">state_variables_hist</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.force_equilibrium_loss"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.force_equilibrium_loss">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">force_equilibrium_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">internal_forces_mesh</span><span class="p">,</span>
                               <span class="n">external_forces_mesh</span><span class="p">,</span> <span class="n">reaction_forces_mesh</span><span class="p">,</span>
                               <span class="n">dirichlet_bool_mesh</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute force equilibrium loss.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        internal_forces_mesh : torch.Tensor(2d)</span>
<span class="sd">            Internal forces of finite element mesh nodes stored as</span>
<span class="sd">            torch.Tensor(2d) of shape (n_node_mesh, n_dim).</span>
<span class="sd">        external_forces_mesh : torch.Tensor(2d)</span>
<span class="sd">            External forces of finite element mesh nodes stored as</span>
<span class="sd">            torch.Tensor(2d) of shape (n_node_mesh, n_dim).</span>
<span class="sd">        reaction_forces_mesh : torch.Tensor(2d)</span>
<span class="sd">            Reaction forces (Dirichlet boundary conditions) of finite element</span>
<span class="sd">            mesh nodes stored as torch.Tensor(2d) of shape</span>
<span class="sd">            (n_node_mesh, n_dim).</span>
<span class="sd">        dirichlet_bool_mesh : torch.Tensor(2d)</span>
<span class="sd">            Degrees of freedom of finite element mesh subject to Dirichlet</span>
<span class="sd">            boundary conditions. Stored as torch.Tensor(2d) of shape</span>
<span class="sd">            (n_node_mesh, n_dim) where constrained degrees of freedom are</span>
<span class="sd">            labeled 1, otherwise 0.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        force_equilibrium_loss : float</span>
<span class="sd">            Force equilibrium loss.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize force equilibrium loss</span>
        <span class="n">force_equilibrium_loss</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Normalize forces</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_force_normalization</span><span class="p">:</span>
            <span class="c1"># Normalize internal forces</span>
            <span class="n">internal_forces_mesh</span> <span class="o">=</span> <span class="n">data_scaler_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">internal_forces_mesh</span><span class="p">,</span> <span class="n">features_type</span><span class="o">=</span><span class="s1">&#39;forces&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;normalize&#39;</span><span class="p">)</span>
            <span class="c1"># Normalize external forces</span>
            <span class="n">external_forces_mesh</span> <span class="o">=</span> <span class="n">data_scaler_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">external_forces_mesh</span><span class="p">,</span> <span class="n">features_type</span><span class="o">=</span><span class="s1">&#39;forces&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;normalize&#39;</span><span class="p">)</span>
            <span class="c1"># Normalize reaction forces</span>
            <span class="n">reaction_forces_mesh</span> <span class="o">=</span> <span class="n">data_scaler_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">reaction_forces_mesh</span><span class="p">,</span> <span class="n">features_type</span><span class="o">=</span><span class="s1">&#39;forces&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;normalize&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get number of nodes of finite element mesh</span>
        <span class="n">n_node_mesh</span> <span class="o">=</span> <span class="n">internal_forces_mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Get number of spatial dimensions</span>
        <span class="n">n_dim</span> <span class="o">=</span> <span class="n">internal_forces_mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Loop over nodes</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_node_mesh</span><span class="p">):</span>
            <span class="c1"># Loop over dimensions</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dim</span><span class="p">):</span>
                <span class="c1"># Add contribution of degree of freedom</span>
                <span class="k">if</span> <span class="n">dirichlet_bool_mesh</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># Constrained degree of freedom (Dirichlet boundary</span>
                    <span class="c1"># condition)</span>
                    <span class="n">force_equilibrium_loss</span> <span class="o">+=</span> <span class="p">(</span><span class="n">internal_forces_mesh</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                                               <span class="o">-</span> <span class="n">external_forces_mesh</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                                               <span class="o">-</span> <span class="n">reaction_forces_mesh</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Free degree of freedom</span>
                    <span class="n">force_equilibrium_loss</span> <span class="o">+=</span> <span class="p">(</span><span class="n">internal_forces_mesh</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                                               <span class="o">-</span> <span class="n">external_forces_mesh</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">force_equilibrium_loss</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.build_element_local_samples"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.build_element_local_samples">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">build_element_local_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strain_formulation</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">,</span>
                                    <span class="n">element_type</span><span class="p">,</span> <span class="n">time_hist</span><span class="p">,</span>
                                    <span class="n">element_state_hist</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build element Gauss integration points local strain-stress paths.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strain_formulation: {&#39;infinitesimal&#39;, &#39;finite&#39;}</span>
<span class="sd">            Strain formulation.</span>
<span class="sd">        problem_type : int</span>
<span class="sd">            Problem type: 2D plane strain (1), 2D plane stress (2),</span>
<span class="sd">            2D axisymmetric (3) and 3D (4).</span>
<span class="sd">        element_type : Element</span>
<span class="sd">            FETorch finite element.</span>
<span class="sd">        time_hist : torch.Tensor(1d)</span>
<span class="sd">            Discrete time history.</span>
<span class="sd">        element_state_hist : list[dict]</span>
<span class="sd">            Material constitutive model state variables history (item, dict)</span>
<span class="sd">            for each Gauss integration point (key, str[int]).</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        element_local_samples : list[dict]</span>
<span class="sd">            Element local strain-stress paths, each corresponding to a given</span>
<span class="sd">            element Gauss integration point. Each path is stored as a</span>
<span class="sd">            dictionary where each feature (key, str) data is a torch.Tensor(2d)</span>
<span class="sd">            of shape (sequence_length, n_features).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get problem type parameters</span>
        <span class="n">n_dim</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_problem_type_parameters</span><span class="p">(</span><span class="n">problem_type</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set strain and stress components</span>
        <span class="k">if</span> <span class="n">strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="n">strain_comps_order</span> <span class="o">=</span> <span class="n">comp_order_sym</span>
            <span class="n">stress_comps_order</span> <span class="o">=</span> <span class="n">comp_order_sym</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not implemented.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get element number of Gauss quadrature integration points</span>
        <span class="n">n_gauss</span> <span class="o">=</span> <span class="n">element_type</span><span class="o">.</span><span class="n">get_n_gauss</span><span class="p">()</span>
        <span class="c1"># Get time history length</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">time_hist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize element local strain-stress paths</span>
        <span class="n">element_local_samples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Loop over Gauss integration points</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_gauss</span><span class="p">):</span>
            <span class="c1"># Initialize strain path</span>
            <span class="n">strain_path</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">strain_comps_order</span><span class="p">)),</span>
                                      <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
            <span class="c1"># Initialize stress path</span>
            <span class="n">stress_path</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stress_comps_order</span><span class="p">)),</span>
                                      <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Loop over discrete time</span>
            <span class="k">for</span> <span class="n">time_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
                <span class="c1"># Get strain tensor (matricial form)</span>
                <span class="n">strain_mf</span> <span class="o">=</span> \
                    <span class="n">element_state_hist</span><span class="p">[</span><span class="n">time_idx</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)][</span><span class="s1">&#39;strain_mf&#39;</span><span class="p">]</span>
                <span class="c1"># Get strain tensor</span>
                <span class="n">strain</span> <span class="o">=</span> <span class="n">vget_tensor_from_mf</span><span class="p">(</span><span class="n">strain_mf</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">,</span>
                                             <span class="n">strain_comps_order</span><span class="p">)</span>
                <span class="c1"># Store strain components</span>
                <span class="n">strain_path</span><span class="p">[</span><span class="n">time_idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">vstore_tensor_comps</span><span class="p">(</span><span class="n">comp_order_sym</span><span class="p">,</span> <span class="n">strain</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Get stress tensor (matricial form)</span>
                <span class="n">stress_mf</span> <span class="o">=</span> \
                    <span class="n">element_state_hist</span><span class="p">[</span><span class="n">time_idx</span><span class="p">][</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)][</span><span class="s1">&#39;stress_mf&#39;</span><span class="p">]</span>
                <span class="c1"># Get stress tensor</span>
                <span class="n">stress</span> <span class="o">=</span> <span class="n">vget_tensor_from_mf</span><span class="p">(</span><span class="n">stress_mf</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">,</span>
                                             <span class="n">stress_comps_order</span><span class="p">)</span>
                <span class="c1"># Store stress components</span>
                <span class="n">stress_path</span><span class="p">[</span><span class="n">time_idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">vstore_tensor_comps</span><span class="p">(</span><span class="n">comp_order_sym</span><span class="p">,</span> <span class="n">stress</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Initialize material response path data</span>
            <span class="n">response_path</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># Assemble strain-stress material response path</span>
            <span class="n">response_path</span><span class="p">[</span><span class="s1">&#39;strain_comps_order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">strain_comps_order</span>
            <span class="n">response_path</span><span class="p">[</span><span class="s1">&#39;strain_path&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">strain_path</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="n">response_path</span><span class="p">[</span><span class="s1">&#39;stress_comps_order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stress_comps_order</span>
            <span class="n">response_path</span><span class="p">[</span><span class="s1">&#39;stress_path&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stress_path</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="c1"># Assemble time path</span>
            <span class="n">response_path</span><span class="p">[</span><span class="s1">&#39;time_hist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_hist</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Assemble material response path</span>
            <span class="n">element_local_samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">response_path</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">element_local_samples</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.build_tensor_from_comps"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.build_tensor_from_comps">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_tensor_from_comps</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">comps_array</span><span class="p">,</span>
                                <span class="n">is_symmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build strain/stress tensor from given components.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_dim : int</span>
<span class="sd">            Problem number of spatial dimensions.</span>
<span class="sd">        comps : tuple[str]</span>
<span class="sd">            Strain/Stress components order.</span>
<span class="sd">        comps_array : torch.Tensor(1d)</span>
<span class="sd">            Strain/Stress components array.</span>
<span class="sd">        is_symmetric : bool, default=False</span>
<span class="sd">            If True, then assembles off-diagonal strain components from</span>
<span class="sd">            symmetric component.</span>
<span class="sd">        device : torch.device, default=None</span>
<span class="sd">            Device on which torch.Tensor is allocated.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tensor : torch.Tensor(2d)</span>
<span class="sd">            Strain/Stress tensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize tensor</span>
        <span class="n">tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_dim</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Loop over components</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">comps</span><span class="p">):</span>
            <span class="c1"># Get component indexes</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">]</span>
            <span class="c1"># Assemble tensor component</span>
            <span class="n">tensor</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">comps_array</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="c1"># Assemble symmetric tensor component</span>
            <span class="k">if</span> <span class="n">is_symmetric</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">tensor</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">comps_array</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">tensor</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.store_tensor_comps"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.store_tensor_comps">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">store_tensor_comps</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Store strain/stress tensor components in array.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        comps : tuple[str]</span>
<span class="sd">            Strain/Stress components order.</span>
<span class="sd">        tensor : torch.Tensor(2d)</span>
<span class="sd">            Strain/Stress tensor.</span>
<span class="sd">        device : torch.device, default=None</span>
<span class="sd">            Device on which torch.Tensor is allocated.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        comps_array : torch.Tensor(1d)</span>
<span class="sd">            Strain/Stress components array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize tensor components array</span>
        <span class="n">comps_array</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">comps</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Loop over components</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">comps</span><span class="p">):</span>
            <span class="c1"># Get component indexes</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">]</span>
            <span class="c1"># Assemble tensor component</span>
            <span class="n">comps_array</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">comps_array</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.vforward_sequential_element"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.vforward_sequential_element">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">vforward_sequential_element</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Forward propagation (sequential element).</span>
<span class="sd">        </span>
<span class="sd">        Compatible with vectorized mapping.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        force_equilibrium_hist_loss : torch.Tensor(0d)</span>
<span class="sd">            Force equilibrium history loss.</span>
<span class="sd">        &quot;&quot;&quot;</span>
         <span class="c1"># Get specimen numerical data</span>
        <span class="n">specimen_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_specimen_data</span>
         <span class="c1"># Get specimen material state</span>
        <span class="n">specimen_material_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_specimen_material_state</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get strain formulation and problem type</span>
        <span class="n">strain_formulation</span> <span class="o">=</span> <span class="n">specimen_material_state</span><span class="o">.</span><span class="n">get_strain_formulation</span><span class="p">()</span>
        <span class="n">problem_type</span> <span class="o">=</span> <span class="n">specimen_material_state</span><span class="o">.</span><span class="n">get_problem_type</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get specimen finite element mesh</span>
        <span class="n">specimen_mesh</span> <span class="o">=</span> <span class="n">specimen_data</span><span class="o">.</span><span class="n">specimen_mesh</span>
        <span class="c1"># Get elements type</span>
        <span class="n">elements_type</span> <span class="o">=</span> <span class="n">specimen_mesh</span><span class="o">.</span><span class="n">get_elements_type</span><span class="p">()</span>
        <span class="c1"># Get element type</span>
        <span class="k">if</span> <span class="n">specimen_mesh</span><span class="o">.</span><span class="n">get_n_element_type</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Vectorized forward propagation requires that &#39;</span>
                               <span class="s1">&#39;all the elements share the same element type.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get unique element type</span>
            <span class="n">element_type</span> <span class="o">=</span> <span class="n">elements_type</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">]</span>
            <span class="c1"># Get number of degrees of freedom per node</span>
            <span class="n">n_dof_node</span> <span class="o">=</span> <span class="n">element_type</span><span class="o">.</span><span class="n">get_n_dof_node</span><span class="p">()</span>
        <span class="c1"># Get number of spatial dimensions</span>
        <span class="n">n_dim</span> <span class="o">=</span> <span class="n">specimen_mesh</span><span class="o">.</span><span class="n">get_n_dim</span><span class="p">()</span>
        <span class="c1"># Get number of nodes of finite element mesh</span>
        <span class="n">n_node_mesh</span> <span class="o">=</span> <span class="n">specimen_mesh</span><span class="o">.</span><span class="n">get_n_node_mesh</span><span class="p">()</span>
        <span class="c1"># Build elements nodes degrees of freedom mesh indexes</span>
        <span class="n">elements_mesh_indexes</span> <span class="o">=</span> \
            <span class="n">specimen_mesh</span><span class="o">.</span><span class="n">build_elements_mesh_indexing</span><span class="p">(</span><span class="n">n_dof_node</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get elements material</span>
        <span class="n">elements_material</span> <span class="o">=</span> <span class="n">specimen_material_state</span><span class="o">.</span><span class="n">get_elements_material</span><span class="p">()</span>
        <span class="c1"># Get element constitutive material model</span>
        <span class="k">if</span> <span class="n">specimen_material_state</span><span class="o">.</span><span class="n">get_n_element_material_type</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Vectorized forward propagation requires that &#39;</span>
                               <span class="s1">&#39;all the elements share the same material.&#39;</span><span class="p">)</span>  
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get unique constitutive material model</span>
            <span class="n">element_material</span> <span class="o">=</span> <span class="n">elements_material</span><span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Synchronize material model parameters with learnable parameters</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element_material</span><span class="p">,</span> <span class="s1">&#39;sync_material_model_parameters&#39;</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="nb">callable</span><span class="p">(</span><span class="n">element_material</span><span class="o">.</span><span class="n">sync_material_model_parameters</span><span class="p">):</span>
            <span class="n">element_material</span><span class="o">.</span><span class="n">sync_material_model_parameters</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get batched finite element mesh configuration history</span>
        <span class="n">elements_coords_hist</span><span class="p">,</span> <span class="n">elements_disps_hist</span> <span class="o">=</span> \
            <span class="n">specimen_data</span><span class="o">.</span><span class="n">get_batched_mesh_configuration_hist</span><span class="p">(</span>
                <span class="n">is_update_coords</span><span class="o">=</span><span class="n">strain_formulation</span> <span class="o">!=</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">,</span>
                <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
        <span class="c1"># Get time history</span>
        <span class="n">time_hist</span> <span class="o">=</span> <span class="n">specimen_data</span><span class="o">.</span><span class="n">time_hist</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute history of finite element mesh internal forces</span>
        <span class="n">elements_internal_forces_hist</span><span class="p">,</span> <span class="n">elements_state_hist</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">vcompute_elements_internal_forces_hist</span><span class="p">(</span>
                <span class="n">strain_formulation</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">,</span> <span class="n">element_type</span><span class="p">,</span>
                <span class="n">element_material</span><span class="p">,</span> <span class="n">elements_coords_hist</span><span class="p">,</span> <span class="n">elements_disps_hist</span><span class="p">,</span>
                <span class="n">time_hist</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Build internal forces history of finite element mesh nodes</span>
        <span class="n">internal_forces_mesh_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vbuild_internal_forces_mesh_hist</span><span class="p">(</span>
            <span class="n">elements_internal_forces_hist</span><span class="p">,</span> <span class="n">elements_mesh_indexes</span><span class="p">,</span> <span class="n">n_node_mesh</span><span class="p">,</span>
            <span class="n">n_dim</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set null external forces of finite element mesh nodes</span>
        <span class="n">external_forces_mesh_hist</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">internal_forces_mesh_hist</span><span class="p">)</span>
        <span class="c1"># Get reaction forces (Dirichlet boundary conditions) history of finite</span>
        <span class="c1"># element mesh nodes</span>
        <span class="n">reaction_forces_mesh_hist</span> <span class="o">=</span> \
            <span class="n">specimen_data</span><span class="o">.</span><span class="n">reaction_forces_mesh_hist</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
        <span class="c1"># Get Dirichlet boundary constraints history</span>
        <span class="n">dirichlet_bc_mesh_hist</span> <span class="o">=</span> \
            <span class="n">specimen_data</span><span class="o">.</span><span class="n">dirichlet_bc_mesh_hist</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute force equilibrium history loss</span>
        <span class="n">force_equilibrium_hist_loss</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">vforce_equilibrium_hist_loss</span><span class="p">(</span><span class="n">internal_forces_mesh_hist</span><span class="p">,</span>
                                              <span class="n">external_forces_mesh_hist</span><span class="p">,</span>
                                              <span class="n">reaction_forces_mesh_hist</span><span class="p">,</span>
                                              <span class="n">dirichlet_bc_mesh_hist</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute force equilibrium loss components history</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_store_force_equilibrium_loss_hist</span><span class="p">:</span>
            <span class="c1"># Compute force equilibrium loss components history</span>
            <span class="n">force_equilibrium_loss_hist</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">force_equilibrium_loss_components_hist</span><span class="p">(</span>
                    <span class="n">internal_forces_mesh_hist</span><span class="p">,</span> <span class="n">external_forces_mesh_hist</span><span class="p">,</span>
                    <span class="n">reaction_forces_mesh_hist</span><span class="p">,</span> <span class="n">dirichlet_bc_mesh_hist</span><span class="p">)</span>  
            <span class="c1"># Store force equilibrium loss components history</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">store_force_equilibrium_loss_components_hist</span><span class="p">(</span>
                <span class="n">force_equilibrium_loss_hist</span><span class="p">,</span> <span class="n">is_plot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Store specimen local strain-stress paths data set</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_store_local_paths</span><span class="p">:</span>
            <span class="c1"># Build elements local strain-stress paths</span>
            <span class="n">specimen_local_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_elements_local_samples</span><span class="p">(</span>
                <span class="n">strain_formulation</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">,</span> <span class="n">time_hist</span><span class="p">,</span>
                <span class="n">elements_state_hist</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Create strain-stress material response path data set</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">TimeSeriesDatasetInMemory</span><span class="p">(</span><span class="n">specimen_local_samples</span><span class="p">)</span>
            <span class="c1"># Set data set file basename</span>
            <span class="n">dataset_basename</span> <span class="o">=</span> <span class="s1">&#39;ss_paths_dataset&#39;</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Set data set directory</span>
            <span class="n">dataset_directory</span> <span class="o">=</span> \
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_directory</span><span class="p">),</span>
                             <span class="s1">&#39;local_response_dataset&#39;</span><span class="p">)</span>
            <span class="c1"># Create model directory</span>
            <span class="n">make_directory</span><span class="p">(</span><span class="n">dataset_directory</span><span class="p">,</span> <span class="n">is_overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Save data set</span>
            <span class="n">save_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">dataset_basename</span><span class="p">,</span> <span class="n">dataset_directory</span><span class="p">,</span>
                         <span class="n">is_append_n_sample</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute Dirichlet boundary constrained sets reaction forces</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_force_equilibrium_loss_type</span> <span class="o">==</span> <span class="s1">&#39;dirichlet_sets&#39;</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_compute_sets_reaction_hist</span><span class="p">):</span>
            <span class="c1"># Compute Dirichlet boundary constrained sets reaction forces</span>
            <span class="n">dirichlet_sets_reaction_hist</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">compute_dirichlet_sets_reaction_hist</span><span class="p">(</span>
                    <span class="n">internal_forces_mesh_hist</span><span class="p">,</span> <span class="n">external_forces_mesh_hist</span><span class="p">,</span>
                    <span class="n">dirichlet_bc_mesh_hist</span><span class="p">)</span>
            <span class="c1"># Store Dirichlet boundary constrained sets reaction forces</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">store_dirichlet_sets_reaction_hist</span><span class="p">(</span>
                <span class="n">dirichlet_sets_reaction_hist</span><span class="p">,</span> <span class="n">is_plot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">force_equilibrium_hist_loss</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.vcompute_elements_internal_forces_hist"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.vcompute_elements_internal_forces_hist">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">vcompute_elements_internal_forces_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strain_formulation</span><span class="p">,</span>
        <span class="n">problem_type</span><span class="p">,</span> <span class="n">element_type</span><span class="p">,</span> <span class="n">element_material</span><span class="p">,</span> <span class="n">elements_coords_hist</span><span class="p">,</span>
        <span class="n">elements_disps_hist</span><span class="p">,</span> <span class="n">time_hist</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute history of finite elements internal forces.</span>
<span class="sd">        </span>
<span class="sd">        Compatible with vectorized mapping.</span>
<span class="sd">        </span>
<span class="sd">        Vectorization constraints require that all the elements share the same</span>
<span class="sd">        element type (FETorch finite element) and share the same material</span>
<span class="sd">        constitutive model (FETorch material constitutive model).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strain_formulation: {&#39;infinitesimal&#39;, &#39;finite&#39;}</span>
<span class="sd">            Strain formulation.</span>
<span class="sd">        problem_type : int</span>
<span class="sd">            Problem type: 2D plane strain (1), 2D plane stress (2),</span>
<span class="sd">            2D axisymmetric (3) and 3D (4).</span>
<span class="sd">        element_type : Element</span>
<span class="sd">            FETorch finite element.</span>
<span class="sd">        element_material : ConstitutiveModel</span>
<span class="sd">            FETorch material constitutive model.</span>
<span class="sd">        elements_coords_hist : torch.Tensor(4d)</span>
<span class="sd">            Coordinates history of finite elements nodes stored as</span>
<span class="sd">            torch.Tensor(4d) of shape (n_elem, n_node, n_dim, n_time).</span>
<span class="sd">        elements_disps_hist : torch.Tensor(4d)</span>
<span class="sd">            Displacements history of finite elements nodes stored as</span>
<span class="sd">            torch.Tensor(4d) of shape (n_elem, n_node, n_dim, n_time).</span>
<span class="sd">        time_hist : torch.Tensor(1d)</span>
<span class="sd">            Discrete time history.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        elements_internal_forces_hist : torch.Tensor(3d)</span>
<span class="sd">            Internal forces history of finite elements nodes stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_elem, n_node*n_dim, n_time).</span>
<span class="sd">        elements_state_hist : torch.Tensor(4d)</span>
<span class="sd">            Gauss integration points strain and stress path history of finite</span>
<span class="sd">            elements stored as torch.Tensor(4d) of shape</span>
<span class="sd">            (n_elem, n_gauss, n_time, n_strain_comps + n_stress_comps).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set vectorized element internal forces history computation (batch</span>
        <span class="c1"># along element)</span>
        <span class="n">vmap_compute_element_internal_forces_hist</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vcompute_element_internal_forces_hist</span><span class="p">,</span>
            <span class="n">in_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">out_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="c1"># Compute elements internal forces history</span>
        <span class="n">elements_internal_forces_hist</span><span class="p">,</span> <span class="n">elements_state_hist</span> <span class="o">=</span> \
            <span class="n">vmap_compute_element_internal_forces_hist</span><span class="p">(</span>
                <span class="n">elements_coords_hist</span><span class="p">,</span> <span class="n">elements_disps_hist</span><span class="p">,</span> <span class="n">strain_formulation</span><span class="p">,</span>
                <span class="n">problem_type</span><span class="p">,</span> <span class="n">element_type</span><span class="p">,</span> <span class="n">element_material</span><span class="p">,</span> <span class="n">time_hist</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Check elements internal forces history</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">elements_internal_forces_hist</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;NaNs were detected in the tensor storing the &#39;</span>
                               <span class="s1">&#39;elements internal forces history. This may &#39;</span>
                               <span class="s1">&#39;have resulted from a state update convergence &#39;</span>
                               <span class="s1">&#39;failure.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">elements_internal_forces_hist</span><span class="p">,</span> <span class="n">elements_state_hist</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.vcompute_element_internal_forces_hist"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.vcompute_element_internal_forces_hist">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">vcompute_element_internal_forces_hist</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">nodes_coords_hist</span><span class="p">,</span> <span class="n">nodes_disps_hist</span><span class="p">,</span> <span class="n">strain_formulation</span><span class="p">,</span>
        <span class="n">problem_type</span><span class="p">,</span> <span class="n">element_type</span><span class="p">,</span> <span class="n">element_material</span><span class="p">,</span> <span class="n">time_hist</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute history of finite element internal forces.</span>
<span class="sd">        </span>
<span class="sd">        Compatible with vectorized mapping.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes_coords_hist : torch.Tensor(3d)</span>
<span class="sd">            Coordinates history of finite element nodes stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_node, n_dim, n_time).</span>
<span class="sd">        nodes_disps_hist : torch.Tensor(3d)</span>
<span class="sd">            Displacements history of finite element nodes stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_node, n_dim, n_time).</span>
<span class="sd">        strain_formulation: {&#39;infinitesimal&#39;, &#39;finite&#39;}</span>
<span class="sd">            Strain formulation.</span>
<span class="sd">        problem_type : int</span>
<span class="sd">            Problem type: 2D plane strain (1), 2D plane stress (2),</span>
<span class="sd">            2D axisymmetric (3) and 3D (4).</span>
<span class="sd">        element_type : Element</span>
<span class="sd">            FETorch finite element.</span>
<span class="sd">        element_material : ConstitutiveModel</span>
<span class="sd">            FETorch material constitutive model.</span>
<span class="sd">        time_hist : torch.Tensor(1d)</span>
<span class="sd">            Discrete time history.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        element_internal_forces_hist : torch.Tensor(2d)</span>
<span class="sd">            Element internal forces history stored as torch.Tensor(2d) of shape</span>
<span class="sd">            (n_node*n_dim, n_time).</span>
<span class="sd">        element_state_hist : torch.Tensor(3d)</span>
<span class="sd">            Element Gauss integration points strain and stress path history</span>
<span class="sd">            stored as torch.Tensor(3d) of shape</span>
<span class="sd">            (n_gauss, n_time, n_strain_comps + n_stress_comps).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get element Gauss quadrature integration points local coordinates</span>
        <span class="c1"># and weights</span>
        <span class="n">gp_coords_tensor</span><span class="p">,</span> <span class="n">gp_weights_tensor</span> <span class="o">=</span> \
            <span class="n">element_type</span><span class="o">.</span><span class="n">get_batched_gauss_integration_points</span><span class="p">(</span>
                <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set average volumetric strain formulation flag</span>
        <span class="c1"># (must be refactored as StructureMesh attribute)</span>
        <span class="n">is_volumetric_bar</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Compute element average volumetric gradient operator history</span>
        <span class="k">if</span> <span class="n">strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span> <span class="ow">and</span> <span class="n">is_volumetric_bar</span><span class="p">:</span>
            <span class="n">avg_vol_grad_operator_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vcompute_element_vol_grad_hist</span><span class="p">(</span>
                <span class="n">nodes_coords_hist</span><span class="p">,</span> <span class="n">nodes_disps_hist</span><span class="p">,</span> <span class="n">strain_formulation</span><span class="p">,</span>
                <span class="n">problem_type</span><span class="p">,</span> <span class="n">element_type</span><span class="p">,</span> <span class="n">time_hist</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">avg_vol_grad_operator_hist</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set vectorized strain computation (batch along Gauss integration</span>
        <span class="c1"># points)</span>
        <span class="n">vmap_compute_local_internal_forces_hist</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vcompute_local_internal_forces_hist</span><span class="p">,</span>
            <span class="n">in_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="kc">None</span><span class="p">),</span>
            <span class="n">out_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="c1"># Compute Gauss integration points contribution history to element</span>
        <span class="c1"># internal forces</span>
        <span class="n">gps_local_internal_forces_hist</span><span class="p">,</span> <span class="n">element_state_hist</span> <span class="o">=</span> \
            <span class="n">vmap_compute_local_internal_forces_hist</span><span class="p">(</span>
                <span class="n">gp_coords_tensor</span><span class="p">,</span> <span class="n">gp_weights_tensor</span><span class="p">,</span> <span class="n">strain_formulation</span><span class="p">,</span>
                <span class="n">problem_type</span><span class="p">,</span> <span class="n">element_type</span><span class="p">,</span> <span class="n">nodes_coords_hist</span><span class="p">,</span>
                <span class="n">nodes_disps_hist</span><span class="p">,</span> <span class="n">time_hist</span><span class="p">,</span> <span class="n">element_material</span><span class="p">,</span>
                <span class="n">is_volumetric_bar</span><span class="p">,</span> <span class="n">avg_vol_grad_operator_hist</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute element internal forces history</span>
        <span class="n">element_internal_forces_hist</span> <span class="o">=</span> \
            <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gps_local_internal_forces_hist</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">element_internal_forces_hist</span><span class="p">,</span> <span class="n">element_state_hist</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.vcompute_element_vol_grad_hist"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.vcompute_element_vol_grad_hist">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">vcompute_element_vol_grad_hist</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">nodes_coords_hist</span><span class="p">,</span> <span class="n">nodes_disps_hist</span><span class="p">,</span> <span class="n">strain_formulation</span><span class="p">,</span>
        <span class="n">problem_type</span><span class="p">,</span> <span class="n">element_type</span><span class="p">,</span> <span class="n">time_hist</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute history of finite element volumetric gradient operator.</span>
<span class="sd">        </span>
<span class="sd">        Compatible with vectorized mapping.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes_coords_hist : torch.Tensor(3d)</span>
<span class="sd">            Coordinates history of finite element nodes stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_node, n_dim, n_time).</span>
<span class="sd">        nodes_disps_hist : torch.Tensor(3d)</span>
<span class="sd">            Displacements history of finite element nodes stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_node, n_dim, n_time).</span>
<span class="sd">        strain_formulation: {&#39;infinitesimal&#39;, &#39;finite&#39;}</span>
<span class="sd">            Strain formulation.</span>
<span class="sd">        problem_type : int</span>
<span class="sd">            Problem type: 2D plane strain (1), 2D plane stress (2),</span>
<span class="sd">            2D axisymmetric (3) and 3D (4).</span>
<span class="sd">        element_type : Element</span>
<span class="sd">            FETorch finite element.</span>
<span class="sd">        time_hist : torch.Tensor(1d)</span>
<span class="sd">            Discrete time history.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        avg_vol_grad_operator_hist : torch.Tensor(3d)</span>
<span class="sd">            Element average volumetric gradient operator history stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_time, n_strain_comp, n_node*n_dim).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get element Gauss quadrature integration points local coordinates</span>
        <span class="c1"># and weights</span>
        <span class="n">gp_coords_tensor</span><span class="p">,</span> <span class="n">gp_weights_tensor</span> <span class="o">=</span> \
            <span class="n">element_type</span><span class="o">.</span><span class="n">get_batched_gauss_integration_points</span><span class="p">(</span>
                <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set vectorized gradient computation (batch along Gauss integration</span>
        <span class="c1"># points)</span>
        <span class="n">vmap_compute_local_vol_grad_operator_hist</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vcompute_local_vol_grad_operator_hist</span><span class="p">,</span>
            <span class="n">in_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">out_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="c1"># Compute Gauss integration points contribution history to element</span>
        <span class="c1"># average volumetric gradient operator and volume history</span>
        <span class="n">gps_local_vol_grad_operator_hist</span><span class="p">,</span> <span class="n">gps_local_vol_hist</span> <span class="o">=</span> \
            <span class="n">vmap_compute_local_vol_grad_operator_hist</span><span class="p">(</span>
                <span class="n">gp_coords_tensor</span><span class="p">,</span> <span class="n">gp_weights_tensor</span><span class="p">,</span> <span class="n">strain_formulation</span><span class="p">,</span>
                <span class="n">problem_type</span><span class="p">,</span> <span class="n">element_type</span><span class="p">,</span> <span class="n">nodes_coords_hist</span><span class="p">,</span>
                <span class="n">nodes_disps_hist</span><span class="p">,</span> <span class="n">time_hist</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute element volumetric gradient operator history</span>
        <span class="n">vol_grad_operator_hist</span> <span class="o">=</span> \
            <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gps_local_vol_grad_operator_hist</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Compute element volume history</span>
        <span class="n">vol_hist</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gps_local_vol_hist</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute element average volumetric gradient operator history</span>
        <span class="n">avg_vol_grad_operator_hist</span> <span class="o">=</span> \
            <span class="n">torch</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">vol_hist</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">vol_grad_operator_hist</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">avg_vol_grad_operator_hist</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.vcompute_local_vol_grad_operator_hist"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.vcompute_local_vol_grad_operator_hist">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">vcompute_local_vol_grad_operator_hist</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">local_coords</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">strain_formulation</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">,</span>
        <span class="n">element_type</span><span class="p">,</span> <span class="n">nodes_coords_hist</span><span class="p">,</span> <span class="n">nodes_disps_hist</span><span class="p">,</span> <span class="n">time_hist</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute local integration point gradient contribution history.</span>
<span class="sd">        </span>
<span class="sd">        Compatible with vectorized mapping.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        local_coords : torch.Tensor(1d)</span>
<span class="sd">            Local integration point coordinates.</span>
<span class="sd">        weight : torch.Tensor(0d)</span>
<span class="sd">            Local integration point weight.</span>
<span class="sd">        strain_formulation: {&#39;infinitesimal&#39;, &#39;finite&#39;}</span>
<span class="sd">            Strain formulation.</span>
<span class="sd">        problem_type : int</span>
<span class="sd">            Problem type: 2D plane strain (1), 2D plane stress (2),</span>
<span class="sd">            2D axisymmetric (3) and 3D (4).</span>
<span class="sd">        element_type : Element</span>
<span class="sd">            FETorch finite element.</span>
<span class="sd">        nodes_coords_hist : torch.Tensor(3d)</span>
<span class="sd">            Coordinates history of finite element nodes stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_node, n_dim, n_time).</span>
<span class="sd">        nodes_disps_hist : torch.Tensor(3d)</span>
<span class="sd">            Displacements history of finite element nodes stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_node, n_dim, n_time).</span>
<span class="sd">        time_hist : torch.Tensor(1d)</span>
<span class="sd">            Discrete time history.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vol_grad_operator_hist : torch.Tensor(3d)</span>
<span class="sd">            Local integration point contribution history to finite element</span>
<span class="sd">            average volumetric gradient operator history stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_time, n_strain_comp, n_node*n_dim).</span>
<span class="sd">        vol_hist : torch.Tensor(1d)</span>
<span class="sd">            Local integration point contribution history to finite element</span>
<span class="sd">            volume history stored as torch.Tensor(1d) of shape (n_time,).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get problem type parameters</span>
        <span class="n">n_dim</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> \
            <span class="n">get_problem_type_parameters</span><span class="p">(</span><span class="n">problem_type</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set vectorized discrete gradient computation (batch along time)</span>
        <span class="n">vmap_compute_local_gradient</span> <span class="o">=</span> \
            <span class="n">torch</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcompute_local_gradient</span><span class="p">,</span>
                       <span class="n">in_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                       <span class="n">out_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="c1"># Compute Gauss integration point discrete gradient history</span>
        <span class="k">if</span> <span class="n">strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="c1"># Set symmetric gradient flag</span>
            <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># Compute discrete symmetric gradient operator history</span>
            <span class="n">jacobian_det_hist</span><span class="p">,</span> <span class="n">grad_operator_hist</span> <span class="o">=</span> \
                <span class="n">vmap_compute_local_gradient</span><span class="p">(</span><span class="n">nodes_coords_hist</span><span class="p">,</span> <span class="n">local_coords</span><span class="p">,</span>
                                            <span class="n">comp_order_sym</span><span class="p">,</span> <span class="n">element_type</span><span class="p">,</span>
                                            <span class="n">is_symmetric</span><span class="p">)</span>
            <span class="c1"># Set vectorized volumetric gradient operator computation (batch</span>
            <span class="c1"># along time)</span>
            <span class="n">vmap_compute_local_vol_sym_gradient</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vcompute_local_vol_sym_gradient</span><span class="p">,</span>
                <span class="n">in_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">out_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
            <span class="c1"># Compute volumetric gradient operator history</span>
            <span class="n">vol_grad_operator_hist</span> <span class="o">=</span> <span class="n">vmap_compute_local_vol_sym_gradient</span><span class="p">(</span>
                <span class="n">grad_operator_hist</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not implemented.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute local integration point contribution to element average</span>
        <span class="c1"># volumetric gradient operator history</span>
        <span class="n">vol_grad_operator_hist</span> <span class="o">=</span> <span class="n">weight</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span>
            <span class="n">vol_grad_operator_hist</span><span class="p">,</span> <span class="n">jacobian_det_hist</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
        <span class="c1"># Compute local integration point contribution to element volume</span>
        <span class="n">vol_hist</span> <span class="o">=</span> <span class="n">weight</span><span class="o">*</span><span class="n">jacobian_det_hist</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">vol_grad_operator_hist</span><span class="p">,</span> <span class="n">vol_hist</span>   </div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.vcompute_local_gradient"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.vcompute_local_gradient">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">vcompute_local_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes_coords</span><span class="p">,</span> <span class="n">local_coords</span><span class="p">,</span> <span class="n">comp_order</span><span class="p">,</span>
                                <span class="n">element_type</span><span class="p">,</span> <span class="n">is_symmetric</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute discrete gradient operator at given local point of element.</span>

<span class="sd">        Compatible with vectorized mapping.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes_coords : torch.Tensor(2d)</span>
<span class="sd">            Nodes coordinates stored as torch.Tensor(2d) of shape</span>
<span class="sd">            (n_node, n_dof_node).</span>
<span class="sd">        local_coords : torch.Tensor(1d)</span>
<span class="sd">            Local coordinates of point where strain is computed.</span>
<span class="sd">        comp_order : tuple</span>
<span class="sd">            Strain/Stress components order associated to matricial form.</span>
<span class="sd">        element_type : Element</span>
<span class="sd">            FETorch finite element.</span>
<span class="sd">        is_symmetric : bool, default=True</span>
<span class="sd">            If True, then compute discrete symmetric gradient operator.</span>
<span class="sd">            Otherwise, compute non-symmetric discrete gradient operator.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        jacobian_det : torch.Tensor(0d)</span>
<span class="sd">            Determinant of element Jacobian at given local coordinates.</span>
<span class="sd">        grad_operator : torch.Tensor(2d)</span>
<span class="sd">            Discrete gradient operator evaluated at given local coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Evaluate shape functions derivates and Jacobian</span>
        <span class="n">shape_fun_deriv</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">jacobian_det</span> <span class="o">=</span> \
            <span class="n">eval_shapefun_deriv</span><span class="p">(</span><span class="n">element_type</span><span class="p">,</span> <span class="n">nodes_coords</span><span class="p">,</span> <span class="n">local_coords</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Build discrete gradient operator</span>
        <span class="k">if</span> <span class="n">is_symmetric</span><span class="p">:</span>
            <span class="c1"># Build discrete symmetric gradient operator</span>
            <span class="n">grad_operator</span> <span class="o">=</span> \
                <span class="n">vbuild_discrete_sym_gradient</span><span class="p">(</span><span class="n">shape_fun_deriv</span><span class="p">,</span> <span class="n">comp_order</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Build discrete non-symmetric gradient operator</span>
            <span class="n">grad_operator</span> <span class="o">=</span> \
                <span class="n">vbuild_discrete_gradient</span><span class="p">(</span><span class="n">shape_fun_deriv</span><span class="p">,</span> <span class="n">comp_order</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">jacobian_det</span><span class="p">,</span> <span class="n">grad_operator</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.vcompute_local_vol_sym_gradient"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.vcompute_local_vol_sym_gradient">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">vcompute_local_vol_sym_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grad_operator_sym</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute discrete volumetric symmetric gradient operator.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grad_operator_sym : torch.Tensor(2d)</span>
<span class="sd">            Discrete symmetric gradient operator.</span>
<span class="sd">        n_dim : int</span>
<span class="sd">            Number of spatial dimensions.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vol_grad_operator_sym : torch.Tensor(2d)</span>
<span class="sd">            Discrete volumetric symmetric gradient operator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get device</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">grad_operator_sym</span><span class="o">.</span><span class="n">device</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># 2D &gt; 3D conversion</span>
        <span class="k">if</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Expand 2D symmetric gradient operator to 3D</span>
            <span class="n">grad_operator_sym</span> <span class="o">=</span> \
                <span class="n">vexpand_grad_operator_sym_2d_to_3d</span><span class="p">(</span><span class="n">grad_operator_sym</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get 3D problem type parameters</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_problem_type_parameters</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="c1"># Get volumetric and deviatoric projection tensors</span>
        <span class="n">vol_proj_vmf</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_projection_tensors_vmf</span><span class="p">(</span>
            <span class="n">n_dim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="o">=</span><span class="n">comp_order_sym</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute discrete volumetric symmetric gradient operator</span>
        <span class="n">vol_grad_operator_sym</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">vol_proj_vmf</span><span class="p">,</span> <span class="n">grad_operator_sym</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># 3D &gt; 2D conversion</span>
        <span class="k">if</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Reduce 3D volumetric symmetric gradient operator to 2D</span>
            <span class="n">vol_grad_operator_sym</span> <span class="o">=</span> \
                <span class="n">vreduce_grad_operator_sym_3d_to_2d</span><span class="p">(</span><span class="n">vol_grad_operator_sym</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">vol_grad_operator_sym</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.vcompute_local_internal_forces_hist"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.vcompute_local_internal_forces_hist">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">vcompute_local_internal_forces_hist</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">local_coords</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">strain_formulation</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">,</span>
        <span class="n">element_type</span><span class="p">,</span> <span class="n">nodes_coords_hist</span><span class="p">,</span> <span class="n">nodes_disps_hist</span><span class="p">,</span> <span class="n">time_hist</span><span class="p">,</span>
        <span class="n">element_material</span><span class="p">,</span> <span class="n">is_volumetric_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">avg_vol_grad_operator_hist</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute local integration point internal force contribution history.</span>
<span class="sd">        </span>
<span class="sd">        Compatible with vectorized mapping.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        local_coords : torch.Tensor(1d)</span>
<span class="sd">            Local integration point coordinates.</span>
<span class="sd">        weight : torch.Tensor(0d)</span>
<span class="sd">            Local integration point weight.</span>
<span class="sd">        strain_formulation: {&#39;infinitesimal&#39;, &#39;finite&#39;}</span>
<span class="sd">            Strain formulation.</span>
<span class="sd">        problem_type : int</span>
<span class="sd">            Problem type: 2D plane strain (1), 2D plane stress (2),</span>
<span class="sd">            2D axisymmetric (3) and 3D (4).</span>
<span class="sd">        element_type : Element</span>
<span class="sd">            FETorch finite element.</span>
<span class="sd">        nodes_coords_hist : torch.Tensor(3d)</span>
<span class="sd">            Coordinates history of finite element nodes stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_node, n_dim, n_time).</span>
<span class="sd">        nodes_disps_hist : torch.Tensor(3d)</span>
<span class="sd">            Displacements history of finite element nodes stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_node, n_dim, n_time).</span>
<span class="sd">        time_hist : torch.Tensor(1d)</span>
<span class="sd">            Discrete time history.</span>
<span class="sd">        element_material : ConstitutiveModel</span>
<span class="sd">            FETorch material constitutive model.</span>
<span class="sd">        is_volumetric_bar : bool, default=False</span>
<span class="sd">            If True, then use volumetric strain averaging formulation (e.g.,</span>
<span class="sd">            B-bar formulation under infinitesimal strains).</span>
<span class="sd">        avg_vol_grad_operator_hist : torch.Tensor(3d), default=None</span>
<span class="sd">            Element average volumetric gradient operator history stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_time, n_strain_comp, n_node*n_dim).</span>
<span class="sd">            Required only if volumetric strain averaging formulation is used.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        local_internal_forces_hist : torch.Tensor(2d)</span>
<span class="sd">            Local integration point contribution history to finite element</span>
<span class="sd">            internal forces stored as torch.Tensor(2d) of</span>
<span class="sd">            shape (n_node*n_dim, n_time).</span>
<span class="sd">        local_state_variables_hist : torch.Tensor(2d)</span>
<span class="sd">            Local integration point strain and stress path history stored as</span>
<span class="sd">            torch.Tensor(2d) of</span>
<span class="sd">            shape (n_time, n_strain_comps + n_stress_comps).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get problem type parameters</span>
        <span class="n">n_dim</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_problem_type_parameters</span><span class="p">(</span><span class="n">problem_type</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set vectorized strain computation (batch along time)</span>
        <span class="n">vmap_compute_local_strain</span> <span class="o">=</span> \
            <span class="n">torch</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcompute_local_strain</span><span class="p">,</span>
                       <span class="n">in_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                       <span class="n">out_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="c1"># Compute Gauss integration point strain history</span>
        <span class="k">if</span> <span class="n">strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="c1"># Compute infinitesimal strain tensor history</span>
            <span class="n">strain_hist</span><span class="p">,</span> <span class="n">jacobian_det_hist</span><span class="p">,</span> <span class="n">grad_operator_sym_hist</span> <span class="o">=</span> \
                <span class="n">vmap_compute_local_strain</span><span class="p">(</span><span class="n">nodes_coords_hist</span><span class="p">,</span> <span class="n">nodes_disps_hist</span><span class="p">,</span>
                                          <span class="n">local_coords</span><span class="p">,</span> <span class="n">strain_formulation</span><span class="p">,</span>
                                          <span class="n">n_dim</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">,</span> <span class="n">element_type</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Apply volumetric strain averaging formulation</span>
            <span class="k">if</span> <span class="n">is_volumetric_bar</span><span class="p">:</span>
                <span class="c1"># Check average volumetric gradient operator history</span>
                <span class="k">if</span> <span class="n">avg_vol_grad_operator_hist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;The average volumetric gradient &#39;</span>
                                       <span class="s1">&#39;operator history must be provided &#39;</span>
                                       <span class="s1">&#39;when using a volumetric strain &#39;</span>
                                       <span class="s1">&#39;averaging formulation.&#39;</span><span class="p">)</span>
                <span class="c1"># Set vectorized strain computation with volumetric strain</span>
                <span class="c1"># averaging formulation (batch along time)</span>
                <span class="n">vmap_compute_local_strain_vbar</span> <span class="o">=</span> \
                    <span class="n">torch</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcompute_local_strain_vbar</span><span class="p">,</span>
                               <span class="n">in_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                               <span class="n">out_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="c1"># Compute infinitesimal strain tensor history with volumetric</span>
                <span class="c1"># strain averaging formulation</span>
                <span class="n">strain_hist</span><span class="p">,</span> <span class="n">grad_operator_sym_hist</span> <span class="o">=</span> \
                    <span class="n">vmap_compute_local_strain_vbar</span><span class="p">(</span>
                        <span class="n">nodes_coords_hist</span><span class="p">,</span> <span class="n">nodes_disps_hist</span><span class="p">,</span>
                        <span class="n">avg_vol_grad_operator_hist</span><span class="p">,</span> <span class="n">local_coords</span><span class="p">,</span>
                        <span class="n">strain_formulation</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">,</span>
                        <span class="n">element_type</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not implemented.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Material state update</span>
        <span class="n">state_variables_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vrecurrent_material_state_update</span><span class="p">(</span>
            <span class="n">strain_formulation</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">,</span> <span class="n">element_material</span><span class="p">,</span>
            <span class="n">strain_hist</span><span class="p">,</span> <span class="n">time_hist</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set stress components index range</span>
        <span class="k">if</span> <span class="n">strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="n">stress_indexes</span> <span class="o">=</span> \
                <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order_sym</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order_sym</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not implemented.&#39;</span><span class="p">)</span>
        <span class="c1"># Extract stress tensor history</span>
        <span class="n">stress_vmf_hist</span> <span class="o">=</span> <span class="n">state_variables_hist</span><span class="p">[:,</span> <span class="n">stress_indexes</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set vectorized internal force computation (batch along time)</span>
        <span class="n">vmap_compute_local_internal_forces</span> <span class="o">=</span> \
            <span class="n">torch</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vcompute_local_internal_forces</span><span class="p">,</span>
                       <span class="n">in_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">out_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
        <span class="c1"># Compute Gauss integration point contribution history to element</span>
        <span class="c1"># internal forces</span>
        <span class="n">local_internal_forces_hist</span> <span class="o">=</span> <span class="n">vmap_compute_local_internal_forces</span><span class="p">(</span>
            <span class="n">stress_vmf_hist</span><span class="p">,</span> <span class="n">grad_operator_sym_hist</span><span class="p">,</span> <span class="n">jacobian_det_hist</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Detach computation graph (minimize memory costs)</span>
        <span class="n">state_variables_hist</span> <span class="o">=</span> <span class="n">state_variables_hist</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">local_internal_forces_hist</span><span class="p">,</span> <span class="n">state_variables_hist</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.vcompute_local_strain"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.vcompute_local_strain">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">vcompute_local_strain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes_coords</span><span class="p">,</span> <span class="n">nodes_disps</span><span class="p">,</span> <span class="n">local_coords</span><span class="p">,</span>
                              <span class="n">strain_formulation</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">,</span> <span class="n">comp_order</span><span class="p">,</span>
                              <span class="n">element_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute strain tensor at given local point of element.</span>
<span class="sd">        </span>
<span class="sd">        Compatible with vectorized mapping.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes_coords : torch.Tensor(2d)</span>
<span class="sd">            Nodes coordinates stored as torch.Tensor(2d) of shape</span>
<span class="sd">            (n_node, n_dof_node).</span>
<span class="sd">        nodes_disps : torch.Tensor(2d)</span>
<span class="sd">            Nodes displacements stored as torch.Tensor(2d) of shape</span>
<span class="sd">            (n_node, n_dof_node).</span>
<span class="sd">        local_coords : torch.Tensor(1d)</span>
<span class="sd">            Local coordinates of point where strain is computed.</span>
<span class="sd">        strain_formulation: {&#39;infinitesimal&#39;, &#39;finite&#39;}</span>
<span class="sd">            Strain formulation.</span>
<span class="sd">        n_dim : int</span>
<span class="sd">            Number of spatial dimensions.</span>
<span class="sd">        comp_order : tuple</span>
<span class="sd">            Strain/Stress components order associated to matricial form.</span>
<span class="sd">        element_type : Element</span>
<span class="sd">            FETorch finite element.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        strain : torch.Tensor(2d)</span>
<span class="sd">            Strain tensor at given local coordinates.</span>
<span class="sd">        jacobian_det : torch.Tensor(0d)</span>
<span class="sd">            Determinant of element Jacobian at given local coordinates.</span>
<span class="sd">        grad_operator_sym : torch.Tensor(2d)</span>
<span class="sd">            Discrete symmetric gradient operator evaluated at given local</span>
<span class="sd">            coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Evaluate shape functions derivates and Jacobian</span>
        <span class="n">shape_fun_deriv</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">jacobian_det</span> <span class="o">=</span> \
            <span class="n">eval_shapefun_deriv</span><span class="p">(</span><span class="n">element_type</span><span class="p">,</span> <span class="n">nodes_coords</span><span class="p">,</span> <span class="n">local_coords</span><span class="p">)</span>
        <span class="c1"># Build discrete symmetric gradient operator</span>
        <span class="n">grad_operator_sym</span> <span class="o">=</span> <span class="n">vbuild_discrete_sym_gradient</span><span class="p">(</span><span class="n">shape_fun_deriv</span><span class="p">,</span>
                                                         <span class="n">comp_order</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute strain tensor</span>
        <span class="k">if</span> <span class="n">strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="c1"># Compute infinitesimal strain tensor (Voigt matricial form)</span>
            <span class="n">strain_vmf</span> <span class="o">=</span> \
                <span class="n">compute_infinitesimal_strain</span><span class="p">(</span><span class="n">grad_operator_sym</span><span class="p">,</span> <span class="n">nodes_disps</span><span class="p">)</span>
            <span class="c1"># Get strain tensor</span>
            <span class="n">strain</span> <span class="o">=</span> <span class="n">vget_strain_from_vmf</span><span class="p">(</span><span class="n">strain_vmf</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">,</span> <span class="n">comp_order</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not implemented.&#39;</span><span class="p">)</span>      
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">strain</span><span class="p">,</span> <span class="n">jacobian_det</span><span class="p">,</span> <span class="n">grad_operator_sym</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.vcompute_local_strain_vbar"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.vcompute_local_strain_vbar">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">vcompute_local_strain_vbar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes_coords</span><span class="p">,</span> <span class="n">nodes_disps</span><span class="p">,</span>
                                   <span class="n">avg_vol_grad_operator</span><span class="p">,</span> <span class="n">local_coords</span><span class="p">,</span>
                                   <span class="n">strain_formulation</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">,</span> <span class="n">comp_order</span><span class="p">,</span>
                                   <span class="n">element_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute strain tensor at given local point of element.</span>
<span class="sd">        </span>
<span class="sd">        The strain tensor is computed using a volumetric strain averaging</span>
<span class="sd">        formulation (e.g., B-bar formulation under infinitesimal strains).</span>
<span class="sd">        </span>
<span class="sd">        Compatible with vectorized mapping.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes_coords : torch.Tensor(2d)</span>
<span class="sd">            Nodes coordinates stored as torch.Tensor(2d) of shape</span>
<span class="sd">            (n_node, n_dof_node).</span>
<span class="sd">        nodes_disps : torch.Tensor(2d)</span>
<span class="sd">            Nodes displacements stored as torch.Tensor(2d) of shape</span>
<span class="sd">            (n_node, n_dof_node).</span>
<span class="sd">        avg_vol_grad_operator : torch.Tensor(2d)</span>
<span class="sd">            Element average volumetric gradient operator.</span>
<span class="sd">        local_coords : torch.Tensor(1d)</span>
<span class="sd">            Local coordinates of point where strain is computed.</span>
<span class="sd">        strain_formulation: {&#39;infinitesimal&#39;, &#39;finite&#39;}</span>
<span class="sd">            Strain formulation.</span>
<span class="sd">        n_dim : int</span>
<span class="sd">            Number of spatial dimensions.</span>
<span class="sd">        comp_order : tuple</span>
<span class="sd">            Strain/Stress components order associated to matricial form.</span>
<span class="sd">        element_type : Element</span>
<span class="sd">            FETorch finite element.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        strain : torch.Tensor(2d)</span>
<span class="sd">            Strain tensor at given local coordinates.</span>
<span class="sd">        vbar_grad_operator_sym : torch.Tensor(2d)</span>
<span class="sd">            Modified discrete symmetric gradient operator evaluated at given</span>
<span class="sd">            local coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Evaluate shape functions derivates and Jacobian</span>
        <span class="n">shape_fun_deriv</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> \
            <span class="n">eval_shapefun_deriv</span><span class="p">(</span><span class="n">element_type</span><span class="p">,</span> <span class="n">nodes_coords</span><span class="p">,</span> <span class="n">local_coords</span><span class="p">)</span>
        <span class="c1"># Build discrete symmetric gradient operator</span>
        <span class="n">grad_operator_sym</span> <span class="o">=</span> <span class="n">vbuild_discrete_sym_gradient</span><span class="p">(</span><span class="n">shape_fun_deriv</span><span class="p">,</span>
                                                         <span class="n">comp_order</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
       <span class="c1"># Compute discrete deviatoric symmetric gradient operator</span>
        <span class="n">dev_grad_operator_sym</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vcompute_local_dev_sym_gradient</span><span class="p">(</span>
            <span class="n">grad_operator_sym</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute modified discrete symmetric gradient operator</span>
        <span class="n">vbar_grad_operator_sym</span> <span class="o">=</span> <span class="n">avg_vol_grad_operator</span> <span class="o">+</span> <span class="n">dev_grad_operator_sym</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute strain tensor</span>
        <span class="k">if</span> <span class="n">strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="c1"># Compute infinitesimal strain tensor (Voigt matricial form)</span>
            <span class="n">strain_vmf</span> <span class="o">=</span> <span class="n">compute_infinitesimal_strain</span><span class="p">(</span>
                <span class="n">vbar_grad_operator_sym</span><span class="p">,</span> <span class="n">nodes_disps</span><span class="p">)</span>
            <span class="c1"># Get strain tensor</span>
            <span class="n">strain</span> <span class="o">=</span> <span class="n">vget_strain_from_vmf</span><span class="p">(</span><span class="n">strain_vmf</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">,</span> <span class="n">comp_order</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not implemented.&#39;</span><span class="p">)</span>      
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">strain</span><span class="p">,</span> <span class="n">vbar_grad_operator_sym</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.vcompute_local_dev_sym_gradient"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.vcompute_local_dev_sym_gradient">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">vcompute_local_dev_sym_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grad_operator_sym</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute discrete deviatoric symmetric gradient operator.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grad_operator_sym : torch.Tensor(2d)</span>
<span class="sd">            Discrete symmetric gradient operator.</span>
<span class="sd">        n_dim : int</span>
<span class="sd">            Number of spatial dimensions.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dev_grad_operator_sym : torch.Tensor(2d)</span>
<span class="sd">            Discrete deviatoric symmetric gradient operator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get device</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">grad_operator_sym</span><span class="o">.</span><span class="n">device</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># 2D &gt; 3D conversion</span>
        <span class="k">if</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Expand 2D symmetric gradient operator to 3D</span>
            <span class="n">grad_operator_sym</span> <span class="o">=</span> \
                <span class="n">vexpand_grad_operator_sym_2d_to_3d</span><span class="p">(</span><span class="n">grad_operator_sym</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get 3D problem type parameters</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_problem_type_parameters</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="c1"># Get volumetric and deviatoric projection tensors</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">dev_proj_vmf</span> <span class="o">=</span> \
            <span class="n">get_projection_tensors_vmf</span><span class="p">(</span><span class="n">n_dim</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute discrete deviatoric symmetric gradient operator</span>
        <span class="n">dev_grad_operator_sym</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">dev_proj_vmf</span><span class="p">,</span> <span class="n">grad_operator_sym</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># 3D &gt; 2D conversion</span>
        <span class="k">if</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Reduce 3D volumetric symmetric gradient operator to 2D</span>
            <span class="n">dev_grad_operator_sym</span> <span class="o">=</span> \
                <span class="n">vreduce_grad_operator_sym_3d_to_2d</span><span class="p">(</span><span class="n">dev_grad_operator_sym</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">dev_grad_operator_sym</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.vrecurrent_material_state_update"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.vrecurrent_material_state_update">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">vrecurrent_material_state_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strain_formulation</span><span class="p">,</span>
                                         <span class="n">problem_type</span><span class="p">,</span> <span class="n">constitutive_model</span><span class="p">,</span>
                                         <span class="n">strain_hist</span><span class="p">,</span> <span class="n">time_hist</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Material state update for recurrent constitutive model.</span>

<span class="sd">        Compatible with vectorized mapping.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strain_formulation: {&#39;infinitesimal&#39;, &#39;finite&#39;}</span>
<span class="sd">            Problem strain formulation.</span>
<span class="sd">        problem_type : int</span>
<span class="sd">            Problem type: 2D plane strain (1), 2D plane stress (2),</span>
<span class="sd">            2D axisymmetric (3) and 3D (4).</span>
<span class="sd">        constitutive_model : ConstitutiveModel</span>
<span class="sd">            Recurrent material constitutive model.</span>
<span class="sd">        strain_hist : torch.Tensor(3d)</span>
<span class="sd">            Strain tensor history stored as torch.Tensor(3d) of shape</span>
<span class="sd">            (n_time, n_dim, n_dim).</span>
<span class="sd">        time_hist : torch.Tensor(1d)</span>
<span class="sd">            Discrete time history.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        state_variables_hist : torch.Tensor(2d)</span>
<span class="sd">            Strain and stress path history stored as torch.Tensor(2d) of shape</span>
<span class="sd">            (n_time, n_strain_comps + n_stress_comps).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get problem type parameters</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> \
            <span class="n">get_problem_type_parameters</span><span class="p">(</span><span class="n">problem_type</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get time history length</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">time_hist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get input features data</span>
        <span class="n">features_in_data</span> <span class="o">=</span> \
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">vstore_tensor_comps</span><span class="p">(</span><span class="n">comp_order_sym</span><span class="p">,</span> <span class="n">strain_hist</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>
                                      <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">)]</span>
        <span class="c1"># Build input features tensor</span>
        <span class="n">features_in</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">features_in_data</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Normalize input features tensor</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_model_in_normalized</span><span class="p">(</span><span class="n">constitutive_model</span><span class="p">):</span>
            <span class="c1"># Normalize input features</span>
            <span class="n">features_in</span> <span class="o">=</span> <span class="n">data_scaler_transform</span><span class="p">(</span><span class="n">constitutive_model</span><span class="p">,</span>
                <span class="n">features_in</span><span class="p">,</span> <span class="s1">&#39;features_in&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;normalize&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute output features</span>
        <span class="n">features_out</span> <span class="o">=</span> <span class="n">constitutive_model</span><span class="p">(</span><span class="n">features_in</span><span class="p">)</span>
        <span class="c1"># Extract output features</span>
        <span class="n">features_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">features_out_extractor</span><span class="p">(</span><span class="n">features_out</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Denormalize output features tensor</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_model_out_normalized</span><span class="p">(</span><span class="n">constitutive_model</span><span class="p">):</span>
            <span class="c1"># Denormalize output features</span>
            <span class="n">features_out</span> <span class="o">=</span> <span class="n">data_scaler_transform</span><span class="p">(</span><span class="n">constitutive_model</span><span class="p">,</span>
                <span class="n">features_out</span><span class="p">,</span> <span class="s1">&#39;features_out&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;denormalize&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Build state path history</span>
        <span class="k">if</span> <span class="n">strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="n">state_variables_hist</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span>
                <span class="p">(</span><span class="n">features_in</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order_sym</span><span class="p">)],</span>
                 <span class="n">features_out</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order_sym</span><span class="p">)]),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not implemented.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">state_variables_hist</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.vcompute_local_internal_forces"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.vcompute_local_internal_forces">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">vcompute_local_internal_forces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stress_vmf</span><span class="p">,</span> <span class="n">grad_operator_sym</span><span class="p">,</span>
                                       <span class="n">jacobian_det</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute local integration point internal forces contribution.</span>
<span class="sd">        </span>
<span class="sd">        Compatible with vectorized mapping.</span>
<span class="sd">        </span>
<span class="sd">        Internal forces are computed in the spatial configuration, i.e., based</span>
<span class="sd">        on the discrete symmetric gradient operator and the Cauchy stress</span>
<span class="sd">        tensor.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stress_vmf : torch.Tensor(1d)</span>
<span class="sd">            Cauchy stress tensor stored in Voigt matricial form.</span>
<span class="sd">        grad_operator_sym : torch.Tensor(2d)</span>
<span class="sd">            Discrete symmetric gradient operator evaluated at given local</span>
<span class="sd">            coordinates.</span>
<span class="sd">        jacobian_det : torch.Tensor(0d)</span>
<span class="sd">            Determinant of element jacobian evaluated at given local</span>
<span class="sd">            coordinates.</span>
<span class="sd">        weight : torch.Tensor(0d)</span>
<span class="sd">            Local integration point weight.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        internal_forces : torch.Tensor(1d)</span>
<span class="sd">            Integration point contribution to element internal forces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute local integration point contribution to element internal</span>
        <span class="c1"># forces</span>
        <span class="n">internal_forces</span> <span class="o">=</span> <span class="n">weight</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">grad_operator_sym</span><span class="o">.</span><span class="n">t</span><span class="p">(),</span>
                                              <span class="n">stress_vmf</span><span class="p">)</span><span class="o">*</span><span class="n">jacobian_det</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">internal_forces</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.vbuild_internal_forces_mesh_hist"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.vbuild_internal_forces_mesh_hist">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">vbuild_internal_forces_mesh_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elements_internal_forces_hist</span><span class="p">,</span>
                                         <span class="n">elements_mesh_indexes</span><span class="p">,</span> <span class="n">n_node_mesh</span><span class="p">,</span>
                                         <span class="n">n_dim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build internal forces history of finite element mesh.</span>
<span class="sd">        </span>
<span class="sd">        Compatible with vectorized mapping.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elements_internal_forces_hist : torch.Tensor(3d)</span>
<span class="sd">            Internal forces history of finite elements nodes stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_elem, n_node*n_dim, n_time).</span>
<span class="sd">        elements_mesh_indexes : torch.Tensor(2d)</span>
<span class="sd">            Elements nodes degrees of freedom mesh indexes stored as</span>
<span class="sd">            torch.Tensor(2d) of shape (n_elem, n_node*n_dof_node).</span>
<span class="sd">        n_node_mesh : int</span>
<span class="sd">            Number of nodes of finite element mesh.</span>
<span class="sd">        n_dim : int</span>
<span class="sd">            Number of spatial dimensions.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        internal_forces_mesh_hist : torch.Tensor(3d)</span>
<span class="sd">            Internal forces history of finite element mesh nodes stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_node_mesh, n_dim, n_time).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set vectorized internal forces assembly (batch along time)</span>
        <span class="n">vmap_assemble_internal_forces</span> <span class="o">=</span> \
            <span class="n">torch</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vassemble_internal_forces</span><span class="p">,</span>
                       <span class="n">in_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">out_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
        <span class="c1"># Compute internal forces history</span>
        <span class="n">internal_forces_mesh_hist</span> <span class="o">=</span> <span class="n">vmap_assemble_internal_forces</span><span class="p">(</span>
            <span class="n">elements_internal_forces_hist</span><span class="p">,</span> <span class="n">elements_mesh_indexes</span><span class="p">,</span> <span class="n">n_node_mesh</span><span class="p">,</span>
            <span class="n">n_dim</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">internal_forces_mesh_hist</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.vassemble_internal_forces"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.vassemble_internal_forces">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">vassemble_internal_forces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elements_internal_forces</span><span class="p">,</span>
                                  <span class="n">elements_mesh_indexes</span><span class="p">,</span> <span class="n">n_node_mesh</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assemble element internal forces into mesh counterpart.</span>
<span class="sd">        </span>
<span class="sd">        Compatible with vectorized mapping.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elements_internal_forces : torch.Tensor(2d)</span>
<span class="sd">            Internal forces of finite elements nodes stored as</span>
<span class="sd">            torch.Tensor(2d) of shape (n_elem, n_node*n_dim).</span>
<span class="sd">        elements_mesh_indexes : torch.Tensor(2d)</span>
<span class="sd">            Elements nodes degrees of freedom mesh indexes stored as</span>
<span class="sd">            torch.Tensor(2d) of shape (n_elem, n_node*n_dof_node).</span>
<span class="sd">        n_node_mesh : int</span>
<span class="sd">            Number of nodes of finite element mesh.</span>
<span class="sd">        n_dim : int</span>
<span class="sd">            Number of spatial dimensions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        internal_forces_mesh : torch.Tensor(2d)</span>
<span class="sd">            Internal forces of finite element mesh nodes stored as</span>
<span class="sd">            torch.Tensor(2d) of shape (n_node_mesh, n_dim).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Assemble internal forces of finite element mesh</span>
        <span class="n">internal_forces_mesh</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
            <span class="p">[</span><span class="n">elements_internal_forces</span><span class="p">[</span><span class="n">elements_mesh_indexes</span> <span class="o">==</span> <span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
             <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_node_mesh</span><span class="o">*</span><span class="n">n_dim</span><span class="p">)])</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">n_node_mesh</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">internal_forces_mesh</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.vforce_equilibrium_hist_loss"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.vforce_equilibrium_hist_loss">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">vforce_equilibrium_hist_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">internal_forces_mesh_hist</span><span class="p">,</span>
                                     <span class="n">external_forces_mesh_hist</span><span class="p">,</span>
                                     <span class="n">reaction_forces_mesh_hist</span><span class="p">,</span>
                                     <span class="n">dirichlet_bc_mesh_hist</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute force equilibrium history loss.</span>
<span class="sd">        </span>
<span class="sd">        Compatible with vectorized mapping.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        internal_forces_mesh_hist : torch.Tensor(3d)</span>
<span class="sd">            Internal forces history of finite element mesh nodes stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_node_mesh, n_dim, n_time).</span>
<span class="sd">        external_forces_mesh_hist : torch.Tensor(3d)</span>
<span class="sd">            External forces history of finite element mesh nodes stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_node_mesh, n_dim, n_time).</span>
<span class="sd">        reaction_forces_mesh_hist : torch.Tensor(3d)</span>
<span class="sd">            Reaction forces (Dirichlet boundary conditions) history of finite</span>
<span class="sd">            element mesh nodes stored as torch.Tensor(3d) of shape</span>
<span class="sd">            (n_node_mesh, n_dim, n_time).</span>
<span class="sd">        dirichlet_bc_mesh_hist : torch.Tensor(3d)</span>
<span class="sd">            Dirichlet boundary constraints history of finite element mesh nodes</span>
<span class="sd">            stored as torch.Tensor(3d) of shape (n_node_mesh, n_dim, n_time).</span>
<span class="sd">            Encodes if each degree of freedom is free (assigned 0) or</span>
<span class="sd">            constrained (greater than 0) under Dirichlet boundary conditions.</span>
<span class="sd">            The encoding depends on the selected force equilibrium loss type.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        force_equilibrium_hist_loss : torch.Tensor(0d)</span>
<span class="sd">            Force equilibrium history loss.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get initial Dirichlet boundary constraints</span>
        <span class="c1"># (vectorized mapping does not support dynamic shaping due to potential</span>
        <span class="c1"># dynamic Dirichlet boundary constrains throughout time)</span>
        <span class="n">dirichlet_bc_mesh_init</span> <span class="o">=</span> <span class="n">dirichlet_bc_mesh_hist</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set vectorized force equilibrium history loss computation (batch</span>
        <span class="c1"># along time)</span>
        <span class="n">vmap_force_equilibrium_loss</span> <span class="o">=</span> \
            <span class="n">torch</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vforce_equilibrium_loss</span><span class="p">,</span>
                       <span class="n">in_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">out_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
        <span class="c1"># Compute force equilibrium history loss</span>
        <span class="n">force_equilibrium_hist_loss</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loss_time_weights</span>
            <span class="o">*</span><span class="n">vmap_force_equilibrium_loss</span><span class="p">(</span><span class="n">internal_forces_mesh_hist</span><span class="p">,</span>
                                         <span class="n">external_forces_mesh_hist</span><span class="p">,</span>
                                         <span class="n">reaction_forces_mesh_hist</span><span class="p">,</span>
                                         <span class="n">dirichlet_bc_mesh_init</span><span class="p">))</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">force_equilibrium_hist_loss</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.vforce_equilibrium_loss"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.vforce_equilibrium_loss">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">vforce_equilibrium_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">internal_forces_mesh</span><span class="p">,</span>
                                <span class="n">external_forces_mesh</span><span class="p">,</span> <span class="n">reaction_forces_mesh</span><span class="p">,</span>
                                <span class="n">dirichlet_bc_mesh</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute force equilibrium loss.</span>
<span class="sd">        </span>
<span class="sd">        Compatible with vectorized mapping.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        internal_forces_mesh : torch.Tensor(2d)</span>
<span class="sd">            Internal forces of finite element mesh nodes stored as</span>
<span class="sd">            torch.Tensor(2d) of shape (n_node_mesh, n_dim).</span>
<span class="sd">        external_forces_mesh : torch.Tensor(2d)</span>
<span class="sd">            External forces of finite element mesh nodes stored as</span>
<span class="sd">            torch.Tensor(2d) of shape (n_node_mesh, n_dim).</span>
<span class="sd">        reaction_forces_mesh : torch.Tensor(2d)</span>
<span class="sd">            Reaction forces (Dirichlet boundary conditions) of finite element</span>
<span class="sd">            mesh nodes stored as torch.Tensor(2d) of shape</span>
<span class="sd">            (n_node_mesh, n_dim).</span>
<span class="sd">        dirichlet_bc_mesh : torch.Tensor(2d)</span>
<span class="sd">            Dirichlet boundary constraints of finite element mesh nodes</span>
<span class="sd">            stored as torch.Tensor(2d) of shape (n_node_mesh, n_dim).</span>
<span class="sd">            Encodes if each degree of freedom is free (assigned 0) or</span>
<span class="sd">            constrained (greater than 0) under Dirichlet boundary conditions.</span>
<span class="sd">            The encoding depends on the selected force equilibrium loss type.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        force_equilibrium_loss : torch.Tensor(0d)</span>
<span class="sd">            Force equilibrium loss.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Normalize forces</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_force_normalization</span><span class="p">:</span>
            <span class="c1"># Normalize internal forces</span>
            <span class="n">internal_forces_mesh</span> <span class="o">=</span> <span class="n">data_scaler_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">internal_forces_mesh</span><span class="p">,</span> <span class="n">features_type</span><span class="o">=</span><span class="s1">&#39;forces&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;normalize&#39;</span><span class="p">)</span>
            <span class="c1"># Normalize external forces</span>
            <span class="n">external_forces_mesh</span> <span class="o">=</span> <span class="n">data_scaler_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">external_forces_mesh</span><span class="p">,</span> <span class="n">features_type</span><span class="o">=</span><span class="s1">&#39;forces&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;normalize&#39;</span><span class="p">)</span>
            <span class="c1"># Normalize reaction forces</span>
            <span class="n">reaction_forces_mesh</span> <span class="o">=</span> <span class="n">data_scaler_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">reaction_forces_mesh</span><span class="p">,</span> <span class="n">features_type</span><span class="o">=</span><span class="s1">&#39;forces&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;normalize&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute force equilibrium loss</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_equilibrium_loss_type</span> <span class="o">==</span> <span class="s1">&#39;pointwise&#39;</span><span class="p">:</span>
            <span class="c1"># Force equilibrium strictly based on pointwise internal, external</span>
            <span class="c1"># and reaction forces</span>
            <span class="n">force_equilibrium_loss</span> <span class="o">=</span> \
                <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">internal_forces_mesh</span> <span class="o">-</span> <span class="n">external_forces_mesh</span>
                           <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dirichlet_bc_mesh</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
                                         <span class="n">reaction_forces_mesh</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_equilibrium_loss_type</span> <span class="o">==</span> <span class="s1">&#39;dirichlet_sets&#39;</span><span class="p">:</span>
            <span class="c1"># Flatten mesh data</span>
            <span class="n">internal_forces_mesh_flat</span> <span class="o">=</span> <span class="n">internal_forces_mesh</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">external_forces_mesh_flat</span> <span class="o">=</span> <span class="n">external_forces_mesh</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">reaction_forces_mesh_flat</span> <span class="o">=</span> <span class="n">reaction_forces_mesh</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Flatten mesh sets</span>
            <span class="n">dirichlet_bc_mesh_flat</span> <span class="o">=</span> <span class="n">dirichlet_bc_mesh</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>
            <span class="c1"># Get unique set labels</span>
            <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dirichlet_bc_mesh_flat</span><span class="p">)</span>
            <span class="c1"># Set contiguous set labels</span>
            <span class="n">dense_indices</span> <span class="o">=</span> \
                <span class="n">torch</span><span class="o">.</span><span class="n">bucketize</span><span class="p">(</span><span class="n">dirichlet_bc_mesh_flat</span><span class="p">,</span> <span class="n">unique_labels</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Get total number of degrees of freedom</span>
            <span class="n">n_total</span> <span class="o">=</span> <span class="n">dirichlet_bc_mesh_flat</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span>
            <span class="c1"># Get number of sets</span>
            <span class="n">n_sets</span> <span class="o">=</span> <span class="n">unique_labels</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span>
            <span class="c1"># Initialize one-hot encoding of mesh degrees of freedom</span>
            <span class="n">one_hot</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_total</span><span class="p">,</span> <span class="n">n_sets</span><span class="p">,</span>
                                  <span class="n">device</span><span class="o">=</span><span class="n">dirichlet_bc_mesh</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
            <span class="c1"># Scatter one-hot encoding based on contiguous set labels</span>
            <span class="n">one_hot</span><span class="o">.</span><span class="n">scatter_</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">dense_indices</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                             <span class="n">value</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Get one-hot enconding for non-Dirichlet and Dirichlet constrained</span>
            <span class="c1"># sets</span>
            <span class="n">one_hot_ndbc</span> <span class="o">=</span> <span class="n">one_hot</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">one_hot_dbc</span> <span class="o">=</span> <span class="n">one_hot</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Set mask for reaction forces (0 for non-Dirichlet degrees of</span>
            <span class="c1"># freedom, 1 for Dirichlet constrained degrees of freedom)</span>
            <span class="n">reaction_forces_mask</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">one_hot_ndbc</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Compute force equilibrium (all degrees of freedom)</span>
            <span class="n">force_equilibrium</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">internal_forces_mesh_flat</span> <span class="o">-</span> <span class="n">external_forces_mesh_flat</span>
                <span class="o">-</span> <span class="n">reaction_forces_mesh_flat</span><span class="o">*</span><span class="n">reaction_forces_mask</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Output total reaction forces per Dirichlet constrained set</span>
            <span class="c1">#torch.set_printoptions(linewidth=1000)</span>
            <span class="c1">#reaction_dbc = \</span>
            <span class="c1">#    reaction_forces_mesh_flat*reaction_forces_mask.squeeze(1)</span>
            <span class="c1">#print((reaction_dbc.unsqueeze(1)*one_hot_dbc).sum(dim=0))</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Set force equilibrium loss multi-objective weights flag</span>
            <span class="n">is_multi_objective_weights</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Compute force equilibrium loss terms</span>
            <span class="k">if</span> <span class="n">is_multi_objective_weights</span><span class="p">:</span>
                <span class="c1"># Compute sets number of degrees of freedom</span>
                <span class="n">sets_n_dof</span> <span class="o">=</span> <span class="n">one_hot</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># Compute sets weights</span>
                <span class="n">sets_weights</span> <span class="o">=</span> <span class="n">sets_n_dof</span><span class="o">/</span><span class="n">n_total</span>
                <span class="c1"># Set weights for non-Dirichlet and Dirichlet constrained sets</span>
                <span class="n">weight_ndbc</span> <span class="o">=</span> <span class="n">sets_weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">weight_dbc</span> <span class="o">=</span> <span class="n">sets_weights</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Compute force equilibrium loss term</span>
                <span class="c1"># (non-Dirichlet constrained set)</span>
                <span class="n">force_equilibrium_loss_ndbc</span> <span class="o">=</span> <span class="n">weight_ndbc</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">force_equilibrium</span><span class="o">*</span><span class="n">one_hot_ndbc</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="c1"># Compute force equilibrium loss term</span>
                <span class="c1"># (Dirichlet constrained sets)</span>
                <span class="n">force_equilibrium_loss_dbc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight_dbc</span><span class="o">*</span><span class="p">((</span>
                    <span class="n">force_equilibrium</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">one_hot_dbc</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Compute force equilibrium loss term</span>
                <span class="c1"># (non-Dirichlet constrained set)</span>
                <span class="n">force_equilibrium_loss_ndbc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">force_equilibrium</span><span class="o">*</span><span class="n">one_hot_ndbc</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="c1"># Compute force equilibrium loss term</span>
                <span class="c1"># (Dirichlet constrained sets)</span>
                <span class="n">force_equilibrium_loss_dbc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(((</span>
                    <span class="n">force_equilibrium</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">one_hot_dbc</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Compute force equilibrium loss</span>
            <span class="n">force_equilibrium_loss</span> <span class="o">=</span> \
                <span class="n">force_equilibrium_loss_ndbc</span> <span class="o">+</span> <span class="n">force_equilibrium_loss_dbc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unknown force equilibrium loss type: &#39;</span>
                               <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_force_equilibrium_loss_type</span><span class="si">}</span><span class="se">\&#39;</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">force_equilibrium_loss</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.force_equilibrium_loss_components_hist"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.force_equilibrium_loss_components_hist">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">force_equilibrium_loss_components_hist</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">internal_forces_mesh_hist</span><span class="p">,</span> <span class="n">external_forces_mesh_hist</span><span class="p">,</span>
        <span class="n">reaction_forces_mesh_hist</span><span class="p">,</span> <span class="n">dirichlet_bc_mesh_hist</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute force equilibrium loss components history (output purposes).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        internal_forces_mesh_hist : torch.Tensor(3d)</span>
<span class="sd">            Internal forces history of finite element mesh nodes stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_node_mesh, n_dim, n_time).</span>
<span class="sd">        external_forces_mesh_hist : torch.Tensor(3d)</span>
<span class="sd">            External forces history of finite element mesh nodes stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_node_mesh, n_dim, n_time).</span>
<span class="sd">        reaction_forces_mesh_hist : torch.Tensor(3d)</span>
<span class="sd">            Reaction forces (Dirichlet boundary conditions) history of finite</span>
<span class="sd">            element mesh nodes stored as torch.Tensor(3d) of shape</span>
<span class="sd">            (n_node_mesh, n_dim, n_time).</span>
<span class="sd">        dirichlet_bc_mesh_hist : torch.Tensor(3d)</span>
<span class="sd">            Dirichlet boundary constraints history of finite element mesh nodes</span>
<span class="sd">            stored as torch.Tensor(3d) of shape (n_node_mesh, n_dim, n_time).</span>
<span class="sd">            Encodes if each degree of freedom is free (assigned 0) or</span>
<span class="sd">            constrained (greater than 0) under Dirichlet boundary conditions.</span>
<span class="sd">            The encoding depends on the selected force equilibrium loss type.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        force_equilibrium_loss_components_hist : torch.Tensor(2d)</span>
<span class="sd">            Force equilibrium loss components history stored as</span>
<span class="sd">            torch.Tensor(2d) of shape (1 + n_loss_comp, n_time).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set number of force equilibrium loss components</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_equilibrium_loss_type</span> <span class="o">==</span> <span class="s1">&#39;pointwise&#39;</span><span class="p">:</span>
            <span class="n">n_loss_comp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_equilibrium_loss_type</span> <span class="o">==</span> <span class="s1">&#39;dirichlet_sets&#39;</span><span class="p">:</span>
            <span class="n">n_loss_comp</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unknown force equilibrium loss type: &#39;</span>
                               <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_force_equilibrium_loss_type</span><span class="si">}</span><span class="se">\&#39;</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="c1"># Get history length</span>
        <span class="n">n_time</span> <span class="o">=</span> <span class="n">internal_forces_mesh_hist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Normalize forces</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_force_normalization</span><span class="p">:</span>
            <span class="c1"># Normalize internal forces</span>
            <span class="n">internal_forces_mesh</span> <span class="o">=</span> <span class="n">data_scaler_transform</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">internal_forces_mesh_hist</span><span class="p">,</span> <span class="n">features_type</span><span class="o">=</span><span class="s1">&#39;forces&#39;</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;normalize&#39;</span><span class="p">)</span>
            <span class="c1"># Normalize external forces</span>
            <span class="n">external_forces_mesh</span> <span class="o">=</span> <span class="n">data_scaler_transform</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">external_forces_mesh_hist</span><span class="p">,</span> <span class="n">features_type</span><span class="o">=</span><span class="s1">&#39;forces&#39;</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;normalize&#39;</span><span class="p">)</span>
            <span class="c1"># Normalize reaction forces</span>
            <span class="n">reaction_forces_mesh</span> <span class="o">=</span> <span class="n">data_scaler_transform</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">reaction_forces_mesh_hist</span><span class="p">,</span> <span class="n">features_type</span><span class="o">=</span><span class="s1">&#39;forces&#39;</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;normalize&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize force equilibrium loss components history</span>
        <span class="n">force_equilibrium_loss_components_hist</span> <span class="o">=</span> \
            <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">n_loss_comp</span><span class="p">,</span> <span class="n">n_time</span><span class="p">,</span>
                        <span class="n">device</span><span class="o">=</span><span class="n">internal_forces_mesh_hist</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Loop over time</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_time</span><span class="p">):</span>
            <span class="c1"># Get internal forces at time step</span>
            <span class="n">internal_forces_mesh</span> <span class="o">=</span> <span class="n">internal_forces_mesh_hist</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span>
            <span class="c1"># Get external forces at time step</span>
            <span class="n">external_forces_mesh</span> <span class="o">=</span> <span class="n">external_forces_mesh_hist</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span>
            <span class="c1"># Get reaction forces at time step</span>
            <span class="n">reaction_forces_mesh</span> <span class="o">=</span> <span class="n">reaction_forces_mesh_hist</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span>
            <span class="c1"># Get Dirichlet boundary constraints at time step</span>
            <span class="n">dirichlet_bc_mesh</span> <span class="o">=</span> <span class="n">dirichlet_bc_mesh_hist</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Compute force equilibrium loss components</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_equilibrium_loss_type</span> <span class="o">==</span> <span class="s1">&#39;pointwise&#39;</span><span class="p">:</span>
                <span class="c1"># Force equilibrium strictly based on pointwise internal,</span>
                <span class="c1"># external and reaction forces</span>
                <span class="n">force_equilibrium_loss</span> <span class="o">=</span> \
                    <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">internal_forces_mesh</span> <span class="o">-</span> <span class="n">external_forces_mesh</span>
                               <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dirichlet_bc_mesh</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
                                             <span class="n">reaction_forces_mesh</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Store force equilibrium loss and components</span>
                <span class="n">force_equilibrium_loss_components_hist</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">force_equilibrium_loss</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_equilibrium_loss_type</span> <span class="o">==</span> <span class="s1">&#39;dirichlet_sets&#39;</span><span class="p">:</span>
                <span class="c1"># Flatten mesh data</span>
                <span class="n">internal_forces_mesh_flat</span> <span class="o">=</span> <span class="n">internal_forces_mesh</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">external_forces_mesh_flat</span> <span class="o">=</span> <span class="n">external_forces_mesh</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">reaction_forces_mesh_flat</span> <span class="o">=</span> <span class="n">reaction_forces_mesh</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Flatten mesh sets</span>
                <span class="n">dirichlet_bc_mesh_flat</span> <span class="o">=</span> <span class="n">dirichlet_bc_mesh</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>
                <span class="c1"># Get unique set labels</span>
                <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dirichlet_bc_mesh_flat</span><span class="p">)</span>
                <span class="c1"># Set contiguous set labels</span>
                <span class="n">dense_indices</span> <span class="o">=</span> \
                    <span class="n">torch</span><span class="o">.</span><span class="n">bucketize</span><span class="p">(</span><span class="n">dirichlet_bc_mesh_flat</span><span class="p">,</span> <span class="n">unique_labels</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Get total number of degrees of freedom</span>
                <span class="n">n_total</span> <span class="o">=</span> <span class="n">dirichlet_bc_mesh_flat</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span>
                <span class="c1"># Get number of sets</span>
                <span class="n">n_sets</span> <span class="o">=</span> <span class="n">unique_labels</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span>
                <span class="c1"># Initialize one-hot encoding of mesh degrees of freedom</span>
                <span class="n">one_hot</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_total</span><span class="p">,</span> <span class="n">n_sets</span><span class="p">,</span>
                                      <span class="n">device</span><span class="o">=</span><span class="n">dirichlet_bc_mesh</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
                <span class="c1"># Scatter one-hot encoding based on contiguous set labels</span>
                <span class="n">one_hot</span><span class="o">.</span><span class="n">scatter_</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">dense_indices</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                                 <span class="n">value</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Get one-hot enconding for non-Dirichlet and Dirichlet</span>
                <span class="c1"># constrained sets</span>
                <span class="n">one_hot_ndbc</span> <span class="o">=</span> <span class="n">one_hot</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">one_hot_dbc</span> <span class="o">=</span> <span class="n">one_hot</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Set mask for reaction forces (0 for non-Dirichlet degrees of</span>
                <span class="c1"># freedom, 1 for Dirichlet constrained degrees of freedom)</span>
                <span class="n">reaction_forces_mask</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">one_hot_ndbc</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Compute force equilibrium (all degrees of freedom)</span>
                <span class="n">force_equilibrium</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">internal_forces_mesh_flat</span> <span class="o">-</span> <span class="n">external_forces_mesh_flat</span>
                    <span class="o">-</span> <span class="n">reaction_forces_mesh_flat</span>
                    <span class="o">*</span><span class="n">reaction_forces_mask</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Set force equilibrium loss multi-objective weights flag</span>
                <span class="n">is_multi_objective_weights</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Compute force equilibrium loss terms</span>
                <span class="k">if</span> <span class="n">is_multi_objective_weights</span><span class="p">:</span>
                    <span class="c1"># Compute sets number of degrees of freedom</span>
                    <span class="n">sets_n_dof</span> <span class="o">=</span> <span class="n">one_hot</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="c1"># Compute sets weights</span>
                    <span class="n">sets_weights</span> <span class="o">=</span> <span class="n">sets_n_dof</span><span class="o">/</span><span class="n">n_total</span>
                    <span class="c1"># Set weights for non-Dirichlet and Dirichlet constrained</span>
                    <span class="c1"># sets</span>
                    <span class="n">weight_ndbc</span> <span class="o">=</span> <span class="n">sets_weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">weight_dbc</span> <span class="o">=</span> <span class="n">sets_weights</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Compute force equilibrium loss term</span>
                    <span class="c1"># (non-Dirichlet constrained set)</span>
                    <span class="n">force_equilibrium_loss_ndbc</span> <span class="o">=</span> <span class="n">weight_ndbc</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">force_equilibrium</span><span class="o">*</span><span class="n">one_hot_ndbc</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="c1"># Compute force equilibrium loss term</span>
                    <span class="c1"># (Dirichlet constrained sets)</span>
                    <span class="n">force_equilibrium_loss_dbc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weight_dbc</span><span class="o">*</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">force_equilibrium</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">one_hot_dbc</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                            <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Compute force equilibrium loss term</span>
                    <span class="c1"># (non-Dirichlet constrained set)</span>
                    <span class="n">force_equilibrium_loss_ndbc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">force_equilibrium</span><span class="o">*</span><span class="n">one_hot_ndbc</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="c1"># Compute force equilibrium loss term</span>
                    <span class="c1"># (Dirichlet constrained sets)</span>
                    <span class="n">force_equilibrium_loss_dbc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span>
                        <span class="p">(</span><span class="n">force_equilibrium</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">one_hot_dbc</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                            <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Compute force equilibrium loss</span>
                <span class="n">force_equilibrium_loss</span> <span class="o">=</span> \
                    <span class="n">force_equilibrium_loss_ndbc</span> <span class="o">+</span> <span class="n">force_equilibrium_loss_dbc</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Store force equilibrium loss and components</span>
                <span class="n">force_equilibrium_loss_components_hist</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">force_equilibrium_loss</span>
                <span class="n">force_equilibrium_loss_components_hist</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">force_equilibrium_loss_ndbc</span>
                <span class="n">force_equilibrium_loss_components_hist</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">force_equilibrium_loss_dbc</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Apply loss time weights</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loss_time_weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">force_equilibrium_loss_components_hist</span> <span class="o">=</span> \
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_loss_time_weights</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> \
                 <span class="o">*</span><span class="n">force_equilibrium_loss_components_hist</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Apply loss scaling factor</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loss_scaling_factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">force_equilibrium_loss_components_hist</span> <span class="o">=</span> \
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_loss_scaling_factor</span>
                 <span class="o">*</span><span class="n">force_equilibrium_loss_components_hist</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">force_equilibrium_loss_components_hist</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.store_force_equilibrium_loss_components_hist"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.store_force_equilibrium_loss_components_hist">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">store_force_equilibrium_loss_components_hist</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">force_equilibrium_loss_components_hist</span><span class="p">,</span> <span class="n">is_plot</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Store force equilibrium loss components history.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        force_equilibrium_loss_components_hist : torch.Tensor(2d)</span>
<span class="sd">            Force equilibrium loss components history stored as</span>
<span class="sd">            torch.Tensor(2d) of shape (1 + n_loss_comp, n_time).</span>
<span class="sd">        is_plot : bool, default=True</span>
<span class="sd">            If True, then plot force equilibrium loss components history.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set storage directory</span>
        <span class="n">save_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_directory</span><span class="p">),</span>
                                <span class="s1">&#39;force_equilibrium_loss_components&#39;</span><span class="p">)</span>
        <span class="c1"># Create storage directory</span>
        <span class="n">make_directory</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="n">is_overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Build force equilibrium loss data</span>
        <span class="n">force_equilibrium_loss_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">force_equilibrium_loss_components_hist</span> <span class="o">=</span> \
            <span class="n">force_equilibrium_loss_components_hist</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">force_equilibrium_loss_data</span><span class="p">[</span><span class="s1">&#39;force_equilibrium_loss_components_hist&#39;</span><span class="p">]</span> \
            <span class="o">=</span> <span class="n">force_equilibrium_loss_components_hist</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set data file path</span>
        <span class="n">data_file_path</span> <span class="o">=</span> \
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="s1">&#39;force_equilibrium_loss_data.pkl&#39;</span><span class="p">)</span>
        <span class="c1"># Save data</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">data_file_path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">data_file</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">force_equilibrium_loss_data</span><span class="p">,</span> <span class="n">data_file</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Plot force equilibrium loss components history</span>
        <span class="k">if</span> <span class="n">is_plot</span><span class="p">:</span>
            <span class="c1"># Get number of loss components</span>
            <span class="n">n_loss_comp</span> <span class="o">=</span> <span class="n">force_equilibrium_loss_components_hist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># Get number of time steps</span>
            <span class="n">n_time</span> <span class="o">=</span> <span class="n">force_equilibrium_loss_components_hist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Initialize data labels</span>
            <span class="n">data_labels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Build data array and set data labels</span>
            <span class="n">data_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">n_loss_comp</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_loss_comp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">data_array</span><span class="p">[:,</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_time</span><span class="p">)</span>
                <span class="n">data_array</span><span class="p">[:,</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">force_equilibrium_loss_components_hist</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">data_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Total&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Component </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Plot force equilibrium loss components history</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">plot_xy_data</span><span class="p">(</span><span class="n">data_array</span><span class="p">,</span>
                                     <span class="n">data_labels</span><span class="o">=</span><span class="n">data_labels</span><span class="p">,</span>
                                     <span class="n">x_lims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                     <span class="n">y_lims</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                     <span class="n">x_label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Time step&#39;</span><span class="p">,</span>
                                     <span class="n">y_label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Force equilibrium loss&#39;</span><span class="p">,</span>
                                     <span class="n">y_scale</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">,</span>
                                     <span class="n">is_latex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Set file name</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;force_equilibrium_loss_components_hist&#39;</span>
            <span class="c1"># Save figure</span>
            <span class="n">save_figure</span><span class="p">(</span><span class="n">figure</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;pdf&#39;</span><span class="p">,</span> <span class="n">save_dir</span><span class="o">=</span><span class="n">save_dir</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Close figure</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.build_elements_local_samples"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.build_elements_local_samples">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">build_elements_local_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strain_formulation</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">,</span>
                                     <span class="n">time_hist</span><span class="p">,</span> <span class="n">elements_state_hist</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build elements local strain-stress paths.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strain_formulation: {&#39;infinitesimal&#39;, &#39;finite&#39;}</span>
<span class="sd">            Strain formulation.</span>
<span class="sd">        problem_type : int</span>
<span class="sd">            Problem type: 2D plane strain (1), 2D plane stress (2),</span>
<span class="sd">            2D axisymmetric (3) and 3D (4).</span>
<span class="sd">        time_hist : torch.Tensor(1d)</span>
<span class="sd">            Discrete time history.</span>
<span class="sd">        elements_state_hist : torch.Tensor(4d)</span>
<span class="sd">            Gauss integration points strain and stress path history of finite</span>
<span class="sd">            elements stored as torch.Tensor(4d) of shape</span>
<span class="sd">            (n_elem, n_gauss, n_time, n_strain_comps + n_stress_comps).</span>
<span class="sd"> </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        elements_local_samples : list[dict]</span>
<span class="sd">            Elements local strain-stress paths, each corresponding to a given</span>
<span class="sd">            element Gauss integration point. Each path is stored as a</span>
<span class="sd">            dictionary where each feature (key, str) data is a torch.Tensor(2d)</span>
<span class="sd">            of shape (sequence_length, n_features).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get problem type parameters</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_problem_type_parameters</span><span class="p">(</span><span class="n">problem_type</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set strain and stress components</span>
        <span class="k">if</span> <span class="n">strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="n">strain_comps_order</span> <span class="o">=</span> <span class="n">comp_order_sym</span>
            <span class="n">stress_comps_order</span> <span class="o">=</span> <span class="n">comp_order_sym</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Not implemented.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set strain indexes</span>
        <span class="n">strain_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order_sym</span><span class="p">))</span>
        <span class="c1"># Set stress indexes</span>
        <span class="n">stress_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order_sym</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order_sym</span><span class="p">))</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set elements of specimen local strain-stress data set</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_local_paths_elements</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">elements_idxs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_paths_elements</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">elements_idxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">elements_state_hist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize elements local strain-stress paths</span>
        <span class="n">elements_local_samples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Loop over elements</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">elements_idxs</span><span class="p">:</span>
            <span class="c1"># Loop over Gauss integration points</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">elements_state_hist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="c1"># Get strain path</span>
                <span class="n">strain_path</span> <span class="o">=</span> <span class="n">elements_state_hist</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="n">strain_slice</span><span class="p">]</span>
                <span class="c1"># Get stress path</span>
                <span class="n">stress_path</span> <span class="o">=</span> <span class="n">elements_state_hist</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="n">stress_slice</span><span class="p">]</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Initialize material response path data</span>
                <span class="n">response_path</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="c1"># Assemble strain-stress material response path</span>
                <span class="n">response_path</span><span class="p">[</span><span class="s1">&#39;strain_comps_order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">strain_comps_order</span>
                <span class="n">response_path</span><span class="p">[</span><span class="s1">&#39;strain_path&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">strain_path</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
                <span class="n">response_path</span><span class="p">[</span><span class="s1">&#39;stress_comps_order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stress_comps_order</span>
                <span class="n">response_path</span><span class="p">[</span><span class="s1">&#39;stress_path&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stress_path</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
                <span class="c1"># Assemble time path</span>
                <span class="n">response_path</span><span class="p">[</span><span class="s1">&#39;time_hist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time_hist</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Assemble material response path</span>
                <span class="n">elements_local_samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">response_path</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">elements_local_samples</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.compute_dirichlet_sets_reaction_hist"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.compute_dirichlet_sets_reaction_hist">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">compute_dirichlet_sets_reaction_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">internal_forces_mesh_hist</span><span class="p">,</span>
                                             <span class="n">external_forces_mesh_hist</span><span class="p">,</span>
                                             <span class="n">dirichlet_bc_mesh_hist</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute reaction forces history of Dirichlet boundary sets.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        At a given time step, the reaction force of each Dirichlet boundary</span>
<span class="sd">        set is computed to strictly satisfy the total force equilibrium,</span>
<span class="sd">        assuming that the internal and external forces are known.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        internal_forces_mesh_hist : torch.Tensor(3d)</span>
<span class="sd">            Internal forces history of finite element mesh nodes stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_node_mesh, n_dim, n_time).</span>
<span class="sd">        external_forces_mesh_hist : torch.Tensor(3d)</span>
<span class="sd">            External forces history of finite element mesh nodes stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_node_mesh, n_dim, n_time).</span>
<span class="sd">        dirichlet_bc_mesh_hist : torch.Tensor(3d)</span>
<span class="sd">            Dirichlet boundary constraints history of finite element mesh nodes</span>
<span class="sd">            stored as torch.Tensor(3d) of shape (n_node_mesh, n_dim, n_time).</span>
<span class="sd">            Encodes if each degree of freedom is free (assigned 0) or</span>
<span class="sd">            constrained (greater than 0) under Dirichlet boundary conditions.</span>
<span class="sd">            The encoding depends on the selected force equilibrium loss type.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dirichlet_sets_reaction_hist : torch.Tensor(3d)</span>
<span class="sd">            Reaction forces history of Dirichlet boundary sets stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_sets, 1, n_time). Sets are sorted</span>
<span class="sd">            according with their encoding labels and are associated with a</span>
<span class="sd">            single spatial dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get initial Dirichlet boundary constraints</span>
        <span class="c1"># (vectorized mapping does not support dynamic shaping due to potential</span>
        <span class="c1"># dynamic Dirichlet boundary constrains throughout time)</span>
        <span class="n">dirichlet_bc_mesh_init</span> <span class="o">=</span> <span class="n">dirichlet_bc_mesh_hist</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set vectorized Dirichlet boundary constrained sets reaction forces</span>
        <span class="c1"># computation (batch along time)</span>
        <span class="n">vmap_compute_dirichlet_sets_reaction</span> <span class="o">=</span> \
            <span class="n">torch</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_dirichlet_sets_reaction</span><span class="p">,</span>
                       <span class="n">in_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">out_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
        <span class="c1"># Compute force equilibrium history loss</span>
        <span class="n">dirichlet_sets_reaction_hist</span> <span class="o">=</span> \
            <span class="n">vmap_compute_dirichlet_sets_reaction</span><span class="p">(</span><span class="n">internal_forces_mesh_hist</span><span class="p">,</span>
                                                 <span class="n">external_forces_mesh_hist</span><span class="p">,</span>
                                                 <span class="n">dirichlet_bc_mesh_init</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">dirichlet_sets_reaction_hist</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.compute_dirichlet_sets_reaction"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.compute_dirichlet_sets_reaction">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">compute_dirichlet_sets_reaction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">internal_forces_mesh</span><span class="p">,</span>
                                        <span class="n">external_forces_mesh</span><span class="p">,</span>
                                        <span class="n">dirichlet_bc_mesh</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute reaction forces of Dirichlet boundary sets.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        internal_forces_mesh : torch.Tensor(2d)</span>
<span class="sd">            Internal forces of finite element mesh nodes stored as</span>
<span class="sd">            torch.Tensor(2d) of shape (n_node_mesh, n_dim).</span>
<span class="sd">        external_forces_mesh : torch.Tensor(2d)</span>
<span class="sd">            External forces of finite element mesh nodes stored as</span>
<span class="sd">            torch.Tensor(2d) of shape (n_node_mesh, n_dim).</span>
<span class="sd">            (n_node_mesh, n_dim).</span>
<span class="sd">        dirichlet_bc_mesh : torch.Tensor(2d)</span>
<span class="sd">            Dirichlet boundary constraints of finite element mesh nodes</span>
<span class="sd">            stored as torch.Tensor(2d) of shape (n_node_mesh, n_dim).</span>
<span class="sd">            Encodes if each degree of freedom is free (assigned 0) or</span>
<span class="sd">            constrained (greater than 0) under Dirichlet boundary conditions.</span>
<span class="sd">            The encoding depends on the selected force equilibrium loss type.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dirichlet_sets_reaction : torch.Tensor(2d)</span>
<span class="sd">            Reaction forces of Dirichlet boundary sets stored as</span>
<span class="sd">            torch.Tensor(2d) of shape (n_sets, 1). Sets are sorted according</span>
<span class="sd">            with their encoding labels and are associated with a single spatial</span>
<span class="sd">            dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Flatten mesh data</span>
        <span class="n">internal_forces_mesh_flat</span> <span class="o">=</span> <span class="n">internal_forces_mesh</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">external_forces_mesh_flat</span> <span class="o">=</span> <span class="n">external_forces_mesh</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Flatten mesh sets</span>
        <span class="n">dirichlet_bc_mesh_flat</span> <span class="o">=</span> <span class="n">dirichlet_bc_mesh</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>
        <span class="c1"># Get unique set labels</span>
        <span class="n">unique_labels</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dirichlet_bc_mesh_flat</span><span class="p">)</span>
        <span class="c1"># Set contiguous set labels</span>
        <span class="n">dense_indices</span> <span class="o">=</span> \
            <span class="n">torch</span><span class="o">.</span><span class="n">bucketize</span><span class="p">(</span><span class="n">dirichlet_bc_mesh_flat</span><span class="p">,</span> <span class="n">unique_labels</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get total number of degrees of freedom</span>
        <span class="n">n_total</span> <span class="o">=</span> <span class="n">dirichlet_bc_mesh_flat</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span>
        <span class="c1"># Get number of sets</span>
        <span class="n">n_sets</span> <span class="o">=</span> <span class="n">unique_labels</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span>
        <span class="c1"># Initialize one-hot encoding of mesh degrees of freedom</span>
        <span class="n">one_hot</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_total</span><span class="p">,</span> <span class="n">n_sets</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">dirichlet_bc_mesh</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="c1"># Scatter one-hot encoding based on contiguous set labels</span>
        <span class="n">one_hot</span><span class="o">.</span><span class="n">scatter_</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">dense_indices</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">value</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute force equilibrium (all degrees of freedom)</span>
        <span class="n">force_equilibrium</span> <span class="o">=</span> <span class="p">(</span><span class="n">internal_forces_mesh_flat</span>
                             <span class="o">-</span> <span class="n">external_forces_mesh_flat</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute reaction forces of Dirichlet constrained sets</span>
        <span class="n">dirichlet_sets_reaction</span> <span class="o">=</span> \
            <span class="p">(</span><span class="n">force_equilibrium</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">one_hot</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">n_sets</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">dirichlet_sets_reaction</span></div>
    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<div class="viewcode-block" id="MaterialModelFinder.store_dirichlet_sets_reaction_hist"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.store_dirichlet_sets_reaction_hist">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">store_dirichlet_sets_reaction_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirichlet_sets_reaction_hist</span><span class="p">,</span>
                                           <span class="n">is_export_csv</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">is_plot</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Store reaction forces history of Dirichlet boundary sets.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dirichlet_sets_reaction_hist : torch.Tensor(3d)</span>
<span class="sd">            Reaction forces history of Dirichlet boundary sets stored as</span>
<span class="sd">            torch.Tensor(3d) of shape (n_sets, 1, n_time).</span>
<span class="sd">        is_export_csv : bool, default=True</span>
<span class="sd">            If True, then export the reaction force history of Dirichlet</span>
<span class="sd">            boundary sets to a &#39;.csv&#39; file.</span>
<span class="sd">        is_plot : bool, default=True</span>
<span class="sd">            If True, then plot the reaction force history of each Dirichlet</span>
<span class="sd">            boundary set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set storage directory</span>
        <span class="n">save_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_directory</span><span class="p">),</span>
                                <span class="s1">&#39;dirichlet_sets_reaction_forces&#39;</span><span class="p">)</span>
        <span class="c1"># Create storage directory</span>
        <span class="n">make_directory</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="n">is_overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Build Dirichlet boundary sets data</span>
        <span class="n">dirichlet_sets_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dirichlet_sets_data</span><span class="p">[</span><span class="s1">&#39;dirichlet_sets_reaction_hist&#39;</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">dirichlet_sets_reaction_hist</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set data file path</span>
        <span class="n">data_file_path</span> <span class="o">=</span> \
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="s1">&#39;dirichlet_sets_data.pkl&#39;</span><span class="p">)</span>
        <span class="c1"># Save data</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">data_file_path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">data_file</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">dirichlet_sets_data</span><span class="p">,</span> <span class="n">data_file</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Export Dirichlet boundary sets reaction force history to &#39;.csv&#39; file</span>
        <span class="k">if</span> <span class="n">is_export_csv</span><span class="p">:</span>
            <span class="c1"># Get number of Dirichlet boundary sets</span>
            <span class="n">n_sets</span> <span class="o">=</span> <span class="n">dirichlet_sets_reaction_hist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Set data to export CSV file</span>
            <span class="n">csv_data</span> <span class="o">=</span> <span class="n">dirichlet_sets_reaction_hist</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="c1"># Set data frame headers</span>
            <span class="n">headers</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;SET </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sets</span><span class="p">)]</span>
            <span class="c1"># Build data frame</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">csv_data</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span>
                                  <span class="n">columns</span><span class="o">=</span><span class="n">headers</span><span class="p">)</span>
            <span class="c1"># Set &#39;.csv&#39; data file path</span>
            <span class="n">csv_file_path</span> <span class="o">=</span> \
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="s1">&#39;dirichlet_reaction_hist_sets.csv&#39;</span><span class="p">)</span>
            <span class="c1"># Export &#39;.csv&#39; data file</span>
            <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">csv_file_path</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Plot Dirichlet boundary sets reaction force history</span>
        <span class="k">if</span> <span class="n">is_plot</span><span class="p">:</span>
            <span class="c1"># Get number of Dirichlet boundary sets</span>
            <span class="n">n_sets</span> <span class="o">=</span> <span class="n">dirichlet_sets_reaction_hist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Get number of time steps</span>
            <span class="n">n_time</span> <span class="o">=</span> <span class="n">dirichlet_sets_reaction_hist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="c1"># Loop over Dirichlet boundary sets</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sets</span><span class="p">):</span>
                <span class="c1"># Get Dirichlet boundary set reaction force history</span>
                <span class="n">dirichlet_set_reaction_hist</span> <span class="o">=</span> \
                    <span class="n">dirichlet_sets_reaction_hist</span><span class="p">[</span>
                        <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Build data array</span>
                <span class="n">data_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_time</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">data_array</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_time</span><span class="p">)</span>
                <span class="n">data_array</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dirichlet_set_reaction_hist</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Plot Dirichlet boundary set reaction force history</span>
                <span class="n">figure</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">plot_xy_data</span><span class="p">(</span><span class="n">data_array</span><span class="p">,</span>
                                         <span class="n">x_lims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                                         <span class="n">x_label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Time step&#39;</span><span class="p">,</span>
                                         <span class="n">y_label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Reaction force&#39;</span><span class="p">,</span>
                                         <span class="n">is_latex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Set file name</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;dirichlet_reaction_hist_set_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="c1"># Save figure</span>
                <span class="n">save_figure</span><span class="p">(</span><span class="n">figure</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;pdf&#39;</span><span class="p">,</span> <span class="n">save_dir</span><span class="o">=</span><span class="n">save_dir</span><span class="p">)</span></div>
    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<div class="viewcode-block" id="MaterialModelFinder.vbuild_tensor_from_comps"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.vbuild_tensor_from_comps">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">vbuild_tensor_from_comps</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">comps_array</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build strain/stress tensor from given components.</span>
<span class="sd">        </span>
<span class="sd">        Compatible with vectorized mapping.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_dim : int</span>
<span class="sd">            Problem number of spatial dimensions.</span>
<span class="sd">        comps : tuple[str]</span>
<span class="sd">            Strain/Stress components order.</span>
<span class="sd">        comps_array : torch.Tensor(1d)</span>
<span class="sd">            Strain/Stress components array.</span>
<span class="sd">        device : torch.device, default=None</span>
<span class="sd">            Device on which torch.Tensor is allocated.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tensor : torch.Tensor(2d)</span>
<span class="sd">            Strain/Stress tensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get device from input tensor</span>
        <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">device</span> <span class="o">=</span> <span class="n">comps_array</span><span class="o">.</span><span class="n">device</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set row major components order       </span>
        <span class="n">row_major_order</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}{</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span>
                                <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_dim</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Build indexing mapping</span>
        <span class="n">index_map</span> <span class="o">=</span> <span class="p">[</span><span class="n">comps</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">comps</span>
                     <span class="k">else</span> <span class="n">comps</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">row_major_order</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Build tensor</span>
        <span class="n">tensor</span> <span class="o">=</span> <span class="n">comps_array</span><span class="p">[</span><span class="n">index_map</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">n_dim</span><span class="p">,</span> <span class="n">n_dim</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">tensor</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.vstore_tensor_comps"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.vstore_tensor_comps">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">vstore_tensor_comps</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">tensor</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Store strain/stress tensor components in array.</span>
<span class="sd">        </span>
<span class="sd">        Compatible with vectorized mapping.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        comps : tuple[str]</span>
<span class="sd">            Strain/Stress components order.</span>
<span class="sd">        tensor : torch.Tensor(2d)</span>
<span class="sd">            Strain/Stress tensor.</span>
<span class="sd">        device : torch.device, default=None</span>
<span class="sd">            Device on which torch.Tensor is allocated.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        comps_array : torch.Tensor(1d)</span>
<span class="sd">            Strain/Stress components array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get device from input tensor</span>
        <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">device</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">device</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Build indexing mapping</span>
        <span class="n">index_map</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Build tensor components array</span>
        <span class="n">comps_array</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[</span><span class="n">index_map</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">comps_array</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.features_out_extractor"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.features_out_extractor">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">features_out_extractor</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">model_output</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract output features from generic model output.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model_output : {torch.Tensor, tuple}</span>
<span class="sd">            Model output.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        features_out : torch.Tensor</span>
<span class="sd">            Tensor of output features stored as torch.Tensor(2d) of shape</span>
<span class="sd">            (sequence_length, n_features_out) for unbatched input or</span>
<span class="sd">            torch.Tensor(3d) of shape</span>
<span class="sd">            (sequence_length, batch_size, n_features_out) for batched input.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract output features</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model_output</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="c1"># Assume output features are stored in the first output index</span>
            <span class="c1"># of model output</span>
            <span class="n">features_out</span> <span class="o">=</span> <span class="n">model_output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model_output</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="c1"># Output features correspond directly to model output</span>
            <span class="n">features_out</span> <span class="o">=</span> <span class="n">model_output</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unexpected model output of type &#39;</span>
                               <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">model_output</span><span class="p">)</span><span class="si">}</span><span class="s1">). Output features &#39;</span>
                               <span class="sa">f</span><span class="s1">&#39;extraction is not implemented.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">features_out</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder._init_data_scalers"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder._init_data_scalers">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">_init_data_scalers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize model data scalers.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_scalers</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_scalers</span><span class="p">[</span><span class="s1">&#39;forces&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.set_fitted_force_data_scalers"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.set_fitted_force_data_scalers">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">set_fitted_force_data_scalers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_minimum</span><span class="p">,</span> <span class="n">force_maximum</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set fitted forces data scalers.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        force_minimum : torch.Tensor(1d)</span>
<span class="sd">            Forces normalization minimum tensor stored as a torch.Tensor with</span>
<span class="sd">            shape (n_dim,).</span>
<span class="sd">        force_maximum : torch.Tensor(1d)</span>
<span class="sd">            Forces normalization maximum tensor stored as a torch.Tensor with</span>
<span class="sd">            shape (n_dim,).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize data scalers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_data_scalers</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get number of spatial dimensions</span>
        <span class="n">n_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_specimen_data</span><span class="o">.</span><span class="n">get_n_dim</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Instantiate forces data scaler</span>
        <span class="n">scaler_forces</span> <span class="o">=</span> \
            <span class="n">TorchMinMaxScaler</span><span class="p">(</span><span class="n">n_features</span><span class="o">=</span><span class="n">n_dim</span><span class="p">,</span> <span class="n">device_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_device_type</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set data scaler normalization factors</span>
        <span class="n">scaler_forces</span><span class="o">.</span><span class="n">set_minimum_and_maximum</span><span class="p">(</span><span class="n">force_minimum</span><span class="p">,</span> <span class="n">force_maximum</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set fitted data scalers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_scalers</span><span class="p">[</span><span class="s1">&#39;forces&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">scaler_forces</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.set_material_models_fitted_data_scalers"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.set_material_models_fitted_data_scalers">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">set_material_models_fitted_data_scalers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">models_scaling_type</span><span class="p">,</span>
                                                <span class="n">models_scaling_parameters</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set material constitutive models fitted data scalers.</span>
<span class="sd">        </span>
<span class="sd">        Data scalers are only fitted for material models that support data</span>
<span class="sd">        normalization and for which the corresponding data scaling type and</span>
<span class="sd">        parameters are provided.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        models_scaling_type : dict</span>
<span class="sd">            Type of data scaling (str, {&#39;min-max&#39;, &#39;mean-std&#39;}) for each</span>
<span class="sd">            material model (key, str[int]). Models are labeled from 1 to</span>
<span class="sd">            n_mat_model. Min-Max scaling (&#39;min-max&#39;) or standardization</span>
<span class="sd">            (&#39;mean-std&#39;).</span>
<span class="sd">        models_scaling_type : dict</span>
<span class="sd">            Features data scaling parameters (item, dict) for each material</span>
<span class="sd">            model (key, str[int]), stored as data scaling parameters</span>
<span class="sd">            (item, tuple[2]) for each features type (key, str). Models are</span>
<span class="sd">            labeled from 1 to n_mat_model. Each data scaling parameter is set</span>
<span class="sd">            as a torch.Tensor(1d) according to the corresponding number of</span>
<span class="sd">            features. For &#39;min-max&#39; data scaling, the parameters are the</span>
<span class="sd">            &#39;minimum&#39;[0] and &#39;maximum&#39;[1] tensors, while for &#39;mean-std&#39; data</span>
<span class="sd">            scaling the parameters are the &#39;mean&#39;[0] and &#39;std&#39;[1] tensors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check specimen material state</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_specimen_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;The specimen material data and material state &#39;</span>
                               <span class="s1">&#39;must be set prior to set the material &#39;</span>
                               <span class="s1">&#39;constitutive models fitted data scalers &#39;</span>
                               <span class="s1">&#39;(check method set_specimen_data()).&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Loop over material models</span>
        <span class="k">for</span> <span class="n">model_key</span><span class="p">,</span> <span class="n">model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_material_models</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Check if material model supports features normalization</span>
            <span class="k">if</span> <span class="p">((</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;is_model_in_normalized&#39;</span><span class="p">))</span>
                 <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;is_model_out_normalized&#39;</span><span class="p">))):</span>
                <span class="k">continue</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Check material model features normalization</span>
            <span class="k">if</span> <span class="p">((</span><span class="ow">not</span> <span class="n">model</span><span class="o">.</span><span class="n">is_model_in_normalized</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">model</span><span class="o">.</span><span class="n">is_model_out_normalized</span><span class="p">)):</span>
                <span class="k">continue</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Get material model data scaling type</span>
            <span class="n">scaling_type</span> <span class="o">=</span> <span class="n">models_scaling_type</span><span class="p">[</span><span class="n">model_key</span><span class="p">]</span>
            <span class="c1"># Get material model data scaling parameters</span>
            <span class="n">scaling_parameters</span> <span class="o">=</span> <span class="n">models_scaling_parameters</span><span class="p">[</span><span class="n">model_key</span><span class="p">]</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Set material model fitted data scalers</span>
            <span class="n">set_fitted_data_scalers</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">scaling_type</span><span class="p">,</span> <span class="n">scaling_parameters</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.check_model_in_normalized"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.check_model_in_normalized">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">check_model_in_normalized</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if generic model expects normalized input features.</span>
<span class="sd">        </span>
<span class="sd">        A model expects normalized input features if it has an attribute</span>
<span class="sd">        &#39;is_model_in_normalized&#39; set to True.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model : torch.nn.Module</span>
<span class="sd">            Model.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_model_in_normalized : bool</span>
<span class="sd">            If True, then model expects normalized input features (normalized</span>
<span class="sd">            input data has been seen during model training).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get model input features normalization</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;is_model_in_normalized&#39;</span><span class="p">):</span>
            <span class="n">is_model_in_normalized</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">is_model_in_normalized</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_model_in_normalized</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">is_model_in_normalized</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="MaterialModelFinder.check_model_out_normalized"><a class="viewcode-back" href="../../../_autosummary/hookeai.material_model_finder.train.training.MaterialModelFinder.html#hookeai.material_model_finder.train.training.MaterialModelFinder.check_model_out_normalized">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">check_model_out_normalized</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if generic model expects normalized output features.</span>
<span class="sd">        </span>
<span class="sd">        A model expects normalized output features if it has an attribute</span>
<span class="sd">        &#39;is_model_out_normalized&#39; set to True.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        model : torch.nn.Module</span>
<span class="sd">            Model.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_model_out_normalized : bool</span>
<span class="sd">            If True, then model expects normalized output features (normalized</span>
<span class="sd">            output data has been seen during model training).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get model output features normalization</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s1">&#39;is_model_out_normalized&#39;</span><span class="p">):</span>
            <span class="n">is_model_out_normalized</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">is_model_out_normalized</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_model_out_normalized</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">is_model_out_normalized</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Bernardo Ferreira.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>